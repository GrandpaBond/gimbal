{"entries":[{"timestamp":1724515575490,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n   */\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n * A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n* XYZ: the microbit's Sensor-Frame\n* RFD: the buggy's Body-Frame (Right, Front, Down)\n* ENG: the World - Frame in which it is navigating(East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt((this.w * this.w)\n            + (this.i * this.i)\n            + (this.j * this.j)\n            + (this.k * this.k))\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n\n    }\n}\n\n\nwhile (true) {\n    basic.pause(500)\n    let field = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let down = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    let dot = field.dottedWith(down)\n    basic.showNumber(dot)\n\n}"],[0,"\n"]],"start1":0,"start2":0,"length1":4699,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":230,"start2":230,"length1":32,"length2":31}]}]},{"timestamp":1724516153024,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n}\n"],[-1,"input.onButtonPressed(Button.A, function() {"],[1,"\n\nwhile (true) {\n    basic.pause(500)"],[0,"\n   "]],"start1":4397,"start2":4397,"length1":52,"length2":45},{"diffs":[[0,"    let "],[-1,"gravity"],[1,"down"],[0," = new V"]],"start1":4538,"start2":4538,"length1":23,"length2":20},{"diffs":[[0,"ith("],[-1,"gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log(datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z),\n        datalogger.createCV(\"dot\", dot),\n        datalogger.createCV(\"crossx\", cross.x),\n        datalogger.createCV(\"crossy\", cross.y),\n        datalogger.createCV(\"crossz\", cross.z)"],[1,"down)\n    basic.showNumber(dot"],[0,")\n\n}"],[-1,")"],[0,"\n"]],"start1":4660,"start2":4660,"length1":527,"length2":39}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\":"],[-1," \"*\",\n        \"datalogger\":"],[0," \"*\""]],"start1":129,"start2":129,"length1":35,"length2":8}]}]},{"timestamp":1724516593329,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    }\n}\n"],[-1,"\n\n"],[0,"input.on"]],"start1":4393,"start2":4393,"length1":18,"length2":16}]}]},{"timestamp":1724565638543,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"z))\n\n})\n"],[-1,"\n\n"]],"start1":5191,"start2":5191,"length1":10,"length2":8}]}]},{"timestamp":1724565643932,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"})\n\n"],[-1,"let lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\nlet count = 0\nwhile (count < 25) {\n    let field = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let gravity = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    let px=0\n    let py=0\n    if (gravity.z>0) {\n    px = gravity.\n    }\n\n}"],[0,"\n"]],"start1":5196,"start2":5196,"length1":408,"length2":5}]}]},{"timestamp":1724566004833,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   let f"],[1,"ield"],[0," = new V"]],"start1":5332,"start2":5332,"length1":16,"length2":20},{"diffs":[[0,"   let g"],[1,"ravity"],[0," = new V"]],"start1":5431,"start2":5431,"length1":16,"length2":22},{"diffs":[[0,"   if (g"],[1,"ravity"],[0,".z>0) {\n"]],"start1":5555,"start2":5555,"length1":16,"length2":22},{"diffs":[[0,"    "],[-1,"    if (g.x > 0) {\n            if (g.x > g.z) px = 1\n        }\n"],[1,"px = gravity."],[0,"\n   "]],"start1":5577,"start2":5577,"length1":71,"length2":21}]}]},{"timestamp":1724566577235,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," if (g.z"],[-1," > "],[1,">"],[0,"0) {\n   "]],"start1":5547,"start2":5547,"length1":19,"length2":17},{"diffs":[[0,"0) {\n        if "],[-1,"("],[0,"(g.x > 0) {\n    "]],"start1":5556,"start2":5556,"length1":33,"length2":32},{"diffs":[[0," (g.x > g.z)"],[-1,")"],[0," px = 1\n    "]],"start1":5598,"start2":5598,"length1":25,"length2":24},{"diffs":[[0,"    "],[-1,"if ((g.x < 0) && (-g.x > g.z)) px = -1\n    } else {\n        if ((g.x > 0) && (g.x < -g.z)) px = 2\n        if ((g.x < 0) && (g.x > g.z)) px = -2"],[1,"}\n"],[0,"\n   "]],"start1":5622,"start2":5622,"length1":151,"length2":10}]}]},{"timestamp":1724567161173,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"x > 0) {"],[-1,"&&"],[1,"\n            if"],[0," (g.x > "]],"start1":5578,"start2":5578,"length1":18,"length2":31}]}]},{"timestamp":1724568236308,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  if ((g.x > 0) "],[1,"{"],[0,"&& (g.x > g.z)) "]],"start1":5569,"start2":5569,"length1":32,"length2":33}]}]},{"timestamp":1724568239305,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= 0\n"],[-1,"let fxLo = 99999\nlet fyLo = 99999\nlet fzLo = 99999\nlet fxHi = -99999\nlet fyHi = -99999\nlet fzHi = -99999\n\nlet gxLo = 99999\nlet gyLo = 99999\nlet gzLo = 99999\nlet gxHi = -99999\nlet gyHi = -99999\nlet gzHi = -99999\n"],[0,"whil"]],"start1":5306,"start2":5306,"length1":219,"length2":8},{"diffs":[[0," let px="],[-1,"2"],[1,"0"],[0,"\n    let"]],"start1":5521,"start2":5521,"length1":17,"length2":17},{"diffs":[[0," let py="],[-1,"2"],[1,"0"],[0,"\n    if "]],"start1":5534,"start2":5534,"length1":17,"length2":17},{"diffs":[[0,".z)) px "],[-1,"+"],[0,"= 1\n    "]],"start1":5596,"start2":5596,"length1":17,"length2":16},{"diffs":[[0," px "],[-1,"-"],[0,"= "],[-1,"1\n        if ((g.y > 0) && (g.y > g.z)) py += 1\n        if ((g.y < 0) && (-g.y > g.z)) py -= "],[1,"-"],[0,"1\n  "]],"start1":5646,"start2":5646,"length1":104,"length2":11},{"diffs":[[0,".z)) px "],[-1,"+"],[0,"= 2\n    "]],"start1":5702,"start2":5702,"length1":17,"length2":16},{"diffs":[[0," px "],[-1,"-"],[0,"= "],[-1,"2\n        if ((g.y > 0) && (g.y < -g.z)) py += 2\n        if ((g.y < 0) && (g.y > g.z)) py -= 2\n    }\n    if (lit[px][py] = 0) {\n        lit[px][py] = 1\n        led.plot(px,4-py)\n        count++\n        if (f.x < fxLo) fxLo = f.x\n\n    }"],[1,"-2\n    }\n"],[0,"\n}\n"]],"start1":5751,"start2":5751,"length1":245,"length2":18}]}]},{"timestamp":1724568836502,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"f.x\n"],[-1,"        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n}\n\nlet fxOff = (fxHi - fxLo) / 2\nlet fyOff = (fyHi - fyLo) / 2\nlet fzOff = (fzHi - fzLo) / 2\nlet fxSCale = (fxHi - fxLo) / 2"],[1,"\n    }\n}"],[0,"\n"]],"start1":6289,"start2":6289,"length1":521,"length2":13}]}]},{"timestamp":1724569227111,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," / 2"],[-1,"4551"],[0,"\n"]],"start1":6805,"start2":6805,"length1":9,"length2":5}]}]},{"timestamp":1724570514156,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," fxSCale = (fxHi - fxLo) / 2"],[1,"4551"],[0,"\n"]],"start1":6781,"start2":6781,"length1":29,"length2":33}]}]},{"timestamp":1724570516815,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"M:SciCt5=r_@qnW?L}Vn\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ver\""],[-1," id=\"z~fvBBKsP[m}2SF9+`sB\""],[0," x=\""]],"start1":151,"start2":151,"length1":34,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"2))\n"],[-1,"    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n"],[0,"    "]],"start1":4641,"start2":4641,"length1":140,"length2":8},{"diffs":[[0," datalogger.log("],[-1," "],[0,"datalogger.creat"]],"start1":4732,"start2":4732,"length1":33,"length2":32},{"diffs":[[0,", field.x),\n"],[-1,"            "],[0,"        data"]],"start1":4772,"start2":4772,"length1":36,"length2":24},{"diffs":[[0,"y),\n        "],[-1,"      "],[-1,"      "],[0,"datalogger.c"]],"start1":4824,"start2":4824,"length1":36,"length2":24},{"diffs":[[0,", field.z),\n"],[-1,"            "],[0,"        data"]],"start1":4860,"start2":4860,"length1":36,"length2":24},{"diffs":[[0,"gravity.x),\n"],[-1,"            "],[0,"        data"]],"start1":4906,"start2":4906,"length1":36,"length2":24},{"diffs":[[0,"gravity.y),\n"],[-1,"            "],[0,"        data"]],"start1":4952,"start2":4952,"length1":36,"length2":24},{"diffs":[[0,"ity.z),\n"],[-1,"            "],[0,"        "]],"start1":5002,"start2":5002,"length1":28,"length2":16},{"diffs":[[0,"t),\n        "],[-1,"      "],[-1,"      "],[0,"datalogger.c"]],"start1":5047,"start2":5047,"length1":36,"length2":24},{"diffs":[[0,"oss.x),\n"],[-1,"            "],[0,"        "]],"start1":5091,"start2":5091,"length1":28,"length2":16},{"diffs":[[0,"oss.y),\n"],[-1,"            "],[0,"        "]],"start1":5139,"start2":5139,"length1":28,"length2":16},{"diffs":[[0,"= (fxHi "],[-1,"+"],[1,"-"],[0," fxLo) /"]],"start1":6698,"start2":6698,"length1":17,"length2":17},{"diffs":[[0,"= (fyHi "],[-1,"+"],[1,"-"],[0," fyLo) /"]],"start1":6728,"start2":6728,"length1":17,"length2":17},{"diffs":[[0,"= (fzHi "],[-1,"+"],[1,"-"],[0," fzLo) /"]],"start1":6758,"start2":6758,"length1":17,"length2":17},{"diffs":[[0,"t fx"],[-1,"Mag = (fxHi - fxLo) / 2\nlet fyMag = (fyHi - fyLo) / 2\nlet fzMag = (fzHi - fzLo) / 2\n\nlet gxOff = (gxHi + gxLo) / 2\nlet gyOff = (gyHi + gyLo) / 2\nlet gzOff = (gzHi + gzLo) / 2\nlet gxMag = (g"],[1,"SCale = (f"],[0,"xHi - "],[-1,"g"],[1,"f"],[0,"xLo)"]],"start1":6780,"start2":6780,"length1":204,"length2":25},{"diffs":[[0,"/ 2\n"],[-1,"let gyMag = (gyHi - gyLo) / 2\nlet gzMag = (gzHi - gzLo) / 2\n\ndatalogger.log( datalogger.createCV(\"fxMag\", fxMag),\n                datalogger.createCV(\"fyMag\", fyMag),\n                datalogger.createCV(\"fzMag\", fzMag),\n                datalogger.createCV(\"gxMag\", gxMag),\n                datalogger.createCV(\"gyMag\", gyMag),\n                datalogger.createCV(\"gzMag\", gzMag))\n\n\n"]],"start1":6806,"start2":6806,"length1":385,"length2":4}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n"],[0,"    "]],"start1":252,"start2":252,"length1":194,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]},{"timestamp":1724571021107,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"x][py] ="],[-1,"="],[0," 0) {\n  "]],"start1":6419,"start2":6419,"length1":17,"length2":16}]}]},{"timestamp":1724601796489,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".x > 0) && ("],[-1,"-"],[0,"g.x < -g.z))"]],"start1":6228,"start2":6228,"length1":25,"length2":24}]}]},{"timestamp":1724601997766,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(2))"],[-1,"\n\n    // independent"],[0,"\n   "]],"start1":5965,"start2":5965,"length1":28,"length2":8},{"diffs":[[0,"0) {"],[-1," // upper hemisphere"],[0,"\n   "]],"start1":6010,"start2":6010,"length1":28,"length2":8},{"diffs":[[0,"+= 1"],[-1," // x beyond 45 degrees right"],[0,"\n   "]],"start1":6056,"start2":6056,"length1":37,"length2":8},{"diffs":[[0,"-= 1"],[-1," // x beyond 45 degrees left"],[0,"\n   "]],"start1":6103,"start2":6103,"length1":36,"length2":8},{"diffs":[[0,"+= 1"],[-1,"   // y beyond 45 degrees forwards"],[0,"\n   "]],"start1":6149,"start2":6149,"length1":42,"length2":8},{"diffs":[[0,"-= 1"],[-1,"  // y beyond 45 degrees backwards\n    } else { // lower hemisphere\n        if ((g.x > 0) && (g.x > g.z)) px += 1 // x beyond 45 degrees right\n        if ((g.x < 0) && (-g.x > g.z)) px -= 1 // x beyond 45 degrees left\n        if ((g.y > 0) && (g.y > g.z)) py += 1   // y beyond 45 degrees forwards\n        if ((g.y < 0) && (-g.y > g.z)) py -= 1  // y beyond 45 degrees backwards\n\n        if ((g.x > 0) && ("],[1,"\n    } else {\n        if ((g.x > 0) && (-"],[0,"g.x "]],"start1":6196,"start2":6196,"length1":414,"length2":49},{"diffs":[[0,"&& ("],[-1,"-"],[0,"g.x > "],[-1,"-"],[0,"g.z)"]],"start1":6284,"start2":6284,"length1":16,"length2":14},{"diffs":[[0,"&& ("],[-1,"-"],[0,"g.y > "],[-1,"-"],[0,"g.z)"]],"start1":6377,"start2":6377,"length1":16,"length2":14},{"diffs":[[0,"plot(px,"],[1,"4-"],[0,"py)\n    "]],"start1":6471,"start2":6471,"length1":16,"length2":18}]}]},{"timestamp":1724602596384,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"dent"],[-1,"ly for px & px:\n    //            -45  mid +45   degrees \n    // upper:   -1 :  0 : 0 : 1\n    // lower:   -1 : -2 : 2 : 1"],[0,"\n   "]],"start1":5985,"start2":5985,"length1":129,"length2":8},{"diffs":[[0,"y=2\n"],[-1,"    let absZ = Math.abs(g.z)\n"],[0,"    "]],"start1":6012,"start2":6012,"length1":37,"length2":8},{"diffs":[[0," (g."],[-1,"x > absZ) px += 1\n    if (-g.x > absZ) px -= 1"],[1,"z > 0) { // upper hemisphere"],[0,"\n    "],[-1,"\n\n"],[0,"    "]],"start1":6022,"start2":6022,"length1":61,"length2":41},{"diffs":[[0,"s right\n    "],[1,"    "],[0,"if ((g.x < 0"]],"start1":6122,"start2":6122,"length1":24,"length2":28},{"diffs":[[0,"egrees left\n"],[1,"    "],[0,"    if ((g.y"]],"start1":6193,"start2":6193,"length1":24,"length2":28},{"diffs":[[0,"orwards\n    "],[1,"    "],[0,"if ((g.y < 0"]],"start1":6277,"start2":6277,"length1":24,"length2":28},{"diffs":[[0,"rds\n"],[-1,"\n\n\n\n\n\n\n    if (g.z > 0) { // upper hemisphere\n"],[0,"    "]],"start1":6362,"start2":6362,"length1":54,"length2":8}]}]},{"timestamp":1724603114821,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,": 2 : 1\n"],[-1,"\n\n\n"],[0,"    let "]],"start1":6103,"start2":6103,"length1":19,"length2":16},{"diffs":[[0,"    "],[-1,"// special cases\n    if (g.z < 0)"],[0,"\n\n  "]],"start1":6223,"start2":6223,"length1":41,"length2":8}]}]},{"timestamp":1724603699264,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,":   "],[1,"-"],[0,"1 : "],[-1,"2 : 2 : 3"],[1," 0 : 0 : 1"],[0,"\n   "]],"start1":6059,"start2":6059,"length1":21,"length2":23},{"diffs":[[0,":   "],[1,"-"],[0,"1 : "],[-1,"0 : 4 : 3"],[1,"-2 : 2 : 1"],[0,"\n\n\n\n"]],"start1":6091,"start2":6091,"length1":21,"length2":23},{"diffs":[[0,"if (g.x "],[-1,"< -"],[1,"> "],[0,"absZ) px"]],"start1":6173,"start2":6173,"length1":19,"length2":18},{"diffs":[[0,"bsZ) px "],[1,"+"],[0,"= 1"],[-1," // outer left"],[0,"\n    if "]],"start1":6184,"start2":6184,"length1":33,"length2":20},{"diffs":[[0,"px += 1\n    if ("],[1,"-"],[0,"g.x > absZ) px ="]],"start1":6189,"start2":6189,"length1":32,"length2":33},{"diffs":[[0," px "],[-1,"= 3 // outer right\n    if (g.y > absZ) py = 1 // outer left\n    if (g.y > absZ) py = 3 // outer right\n    // special lower hemisphere cases\n    if (g.z < 0) {\n        if ((-g.x > -g.z) && (g.x < 0)) px = 0 // lower inner left\n        if ((g.x < -g.z) && (g.x > 0)) px = 4 // lower inner right\n    }"],[1,"-= 1\n    // special cases\n    if (g.z < 0)"],[0,"\n\n  "]],"start1":6217,"start2":6217,"length1":306,"length2":50}]}]},{"timestamp":1724604298893,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," // "],[-1,"set LED pixel (px,py) if tilt angle is: \n    //         outer -45 inner +45 outer \n    // topside:  "],[1,"independently for px & px:\n    //            -45  mid +45   degrees \n    // upper:"],[0,"   1 "],[-1,"| 2 | 2 |"],[1,": 2 : 2 :"],[0," 3\n "]],"start1":5974,"start2":5974,"length1":122,"length2":104},{"diffs":[[0," // "],[-1,"underside"],[1,"lower"],[0,":   1 "],[-1,"| 0 | 4 |"],[1,": 0 : 4 :"],[0," 3\n"],[1,"\n\n\n"],[0,"    "]],"start1":6080,"start2":6080,"length1":35,"length2":34},{"diffs":[[0,"if (g.y "],[-1,"< -"],[1,"> "],[0,"absZ) py"]],"start1":6253,"start2":6253,"length1":19,"length2":18},{"diffs":[[0,"/ outer "],[-1,"fron"],[1,"lef"],[0,"t\n    if"]],"start1":6277,"start2":6277,"length1":20,"length2":19},{"diffs":[[0,"/ outer "],[-1,"back"],[1,"right"],[0,"\n    // "]],"start1":6318,"start2":6318,"length1":20,"length2":21},{"diffs":[[0,"    "],[1,"}\n\n"],[0,"    if ("],[1,"(g.x > 0) && (g.x > g.z)) px += 1 // x beyond 45 degrees right\n    if ((g.x < 0) && "],[0,"(-g."],[-1,"y > -g.z) && (g.y < 0"],[1,"x > g.z)) px -= 1 // x beyond 45 degrees left\n    if ((g.y > 0) && (g.y > g.z)) py += 1   // y beyond 45 degrees forwards\n    if ((g.y < 0) && (-g.y > g.z"],[0,")) py "],[1,"-"],[0,"= "],[-1,"0 // lower inner fron"],[1,"1  // y beyond 45 degrees backwards\n\n\n\n\n\n\n\n    if (g.z > 0) { // upper hemisphere\n    } else { // lower hemisphere\n        if ((g.x > 0) && (g.x > g.z)) px += 1 // x beyond 45 degrees righ"],[0,"t\n  "]],"start1":6523,"start2":6523,"length1":70,"length2":458},{"diffs":[[0,"((g."],[-1,"y < -g.z"],[1,"x < 0) && (-g.x > g.z)) px -= 1 // x beyond 45 degrees left\n        if ((g.y > 0"],[0,") &&"]],"start1":6990,"start2":6990,"length1":16,"length2":88},{"diffs":[[0,"y > "],[-1,"0"],[1,"g.z"],[0,")) py "],[1,"+"],[0,"= "],[-1,"4"],[1,"1  "],[0," // "],[-1,"lower inner back\n    }\n"],[1,"y beyond 45 degrees forwards\n        if ((g.y < 0) && (-g.y > g.z)) py -= 1  // y beyond 45 degrees backwards\n\n        if ((g.x > 0) && (g.x < -g.z)) px += 2\n        if ((g.x < 0) && (-g.x > -g.z)) px -= 2\n        if ((g.y > 0) && (g.y < -g.z)) py += 2\n        if ((g.y < 0) && (-g.y > -g.z)) py -= 2\n    }"],[0,"\n   "]],"start1":7082,"start2":7082,"length1":45,"length2":333}]}]},{"timestamp":1724604752507,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"        "],[-1,"//"],[0,"led.plot"]],"start1":6736,"start2":6736,"length1":18,"length2":16},{"diffs":[[0,"py)\n"],[-1,"        meter.show(px*10+py)\n        basic.pause(1000)\n"],[0,"    "]],"start1":6756,"start2":6756,"length1":63,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n   "]],"start1":160,"start2":160,"length1":69,"length2":8}]}]},{"timestamp":1724605284522,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ases"],[-1," ()"],[0,"\n   "]],"start1":6385,"start2":6385,"length1":11,"length2":8},{"diffs":[[0,"if (g.z "],[-1,">"],[1,"<"],[0," 0) {\n  "]],"start1":6394,"start2":6394,"length1":17,"length2":17},{"diffs":[[0,"   }"],[-1,"\n    meter.show(px*10+py)\n    basic.pause(1000)"],[0,"\n\n  "]],"start1":6678,"start2":6678,"length1":55,"length2":8},{"diffs":[[0,"(px,py)\n"],[1,"        meter.show(px*10+py)\n        basic.pause(1000)\n"],[0,"        "]],"start1":6754,"start2":6754,"length1":16,"length2":71}]}]},{"timestamp":1724605883151,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".z)\n"],[-1,"    // topside tilts (note g.z is NEGATIVE, as it's mounted on the reverse!)\n"],[0,"    "]],"start1":6180,"start2":6180,"length1":85,"length2":8},{"diffs":[[0,"es ("],[-1,"note g.z now POSITIVE"],[0,")\n  "]],"start1":6387,"start2":6387,"length1":29,"length2":8},{"diffs":[[0,"  if ((-g.x "],[-1,"< "],[1,"> -"],[0,"g.z) && (g.x"]],"start1":6418,"start2":6418,"length1":26,"length2":27},{"diffs":[[0,"((g.x < "],[1,"-"],[0,"g.z) && "]],"start1":6490,"start2":6490,"length1":16,"length2":17},{"diffs":[[0,"  if ((-g.y "],[-1,"< "],[1,"> -"],[0,"g.z) && (g.y"]],"start1":6552,"start2":6552,"length1":26,"length2":27},{"diffs":[[0,"((g.y < "],[1,"-"],[0,"g.z) && "]],"start1":6625,"start2":6625,"length1":16,"length2":17},{"diffs":[[0,"r back\n    }"],[1,"\n    meter.show(px*10+py)\n    basic.pause(1000)"],[0,"\n\n    if (li"]],"start1":6673,"start2":6673,"length1":24,"length2":71},{"diffs":[[0,"        "],[1,"//"],[0,"led.plot"]],"start1":6786,"start2":6786,"length1":16,"length2":18}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"er\": \"*\""],[1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n    },\n"]],"start1":156,"start2":156,"length1":16,"length2":77}]}]},{"timestamp":1724606978703,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ger.log("],[1," "],[0,"datalogg"]],"start1":7672,"start2":7672,"length1":16,"length2":17},{"diffs":[[0,"g\", fxMag),\n"],[1,"            "],[0,"    datalogg"]],"start1":7706,"start2":7706,"length1":24,"length2":36},{"diffs":[[0,"g\", fyMag),\n"],[1,"            "],[0,"    datalogg"]],"start1":7759,"start2":7759,"length1":24,"length2":36},{"diffs":[[0,"g\", fzMag),\n"],[1,"            "],[0,"    datalogg"]],"start1":7812,"start2":7812,"length1":24,"length2":36},{"diffs":[[0,"g\", gxMag),\n"],[1,"            "],[0,"    datalogg"]],"start1":7865,"start2":7865,"length1":24,"length2":36},{"diffs":[[0,"g\", gyMag),\n"],[1,"            "],[0,"    datalogg"]],"start1":7918,"start2":7918,"length1":24,"length2":36}]}]},{"timestamp":1724654274752,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,")\n\n\n"],[-1,"\ndatalogger.log(datalogger.createCV(\"fxMag\", fxMag),\n    datalogger.createCV(\"fyMag\", fyMag),\n    datalogger.createCV(\"fzMag\", fzMag),\n    datalogger.createCV(\"gxMag\", gxMag),\n    datalogger.createCV(\"gyMag\", gyMag),\n    datalogger.createCV(\"gzMag\", gzMag))\n\n\n"]],"start1":7920,"start2":7920,"length1":264,"length2":4}]}]},{"timestamp":1724654279024,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n}\n"],[-1,"input.onButtonPressed(Button.A, function() {\n    //set North\n    \n})\n"],[0,"\n\nin"]],"start1":4397,"start2":4397,"length1":77,"length2":8},{"diffs":[[0,"(Button."],[-1,"B"],[1,"A"],[0,", functi"]],"start1":4424,"start2":4424,"length1":17,"length2":17},{"diffs":[[0,"z))\n\n})\n"],[1,"\n"],[0,"let lit "]],"start1":5432,"start2":5432,"length1":16,"length2":17},{"diffs":[[0,"\ndatalogger.log("],[-1," "],[0,"datalogger.creat"]],"start1":7664,"start2":7664,"length1":33,"length2":32},{"diffs":[[0,"(\"fx"],[-1,"Off"],[1,"Mag"],[0,"\", fx"],[-1,"Off"],[1,"Mag"],[0,"),\n"],[-1,"            "],[0,"    "]],"start1":7699,"start2":7699,"length1":34,"length2":22},{"diffs":[[0,"(\"fy"],[-1,"Off"],[1,"Mag"],[0,"\", fy"],[-1,"Off),\n            "],[1,"Mag),\n"],[0,"    "]],"start1":7740,"start2":7740,"length1":34,"length2":22},{"diffs":[[0,"(\"fz"],[-1,"Off"],[1,"Mag"],[0,"\", fz"],[-1,"Off),\n            "],[1,"Mag),\n"],[0,"    "]],"start1":7781,"start2":7781,"length1":34,"length2":22},{"diffs":[[0,"(\"gx"],[-1,"Off"],[1,"Mag"],[0,"\", gx"],[-1,"Off),\n            "],[1,"Mag),\n"],[0,"    "]],"start1":7822,"start2":7822,"length1":34,"length2":22},{"diffs":[[0,"(\"gy"],[-1,"Off"],[1,"Mag"],[0,"\", gy"],[-1,"Off"],[1,"Mag"],[0,"),\n"],[-1,"            "],[0,"    "]],"start1":7863,"start2":7863,"length1":34,"length2":22},{"diffs":[[0,"(\"gz"],[-1,"Off"],[1,"Mag"],[0,"\", gz"],[-1,"Off"],[1,"Mag"],[0,"))\n\n"]],"start1":7904,"start2":7904,"length1":19,"length2":19},{"diffs":[[0,"\ndatalogger.log("],[-1," "],[0,"datalogger.creat"]],"start1":7924,"start2":7924,"length1":33,"length2":32},{"diffs":[[0,"g\", fxMag),\n"],[-1,"            "],[0,"    datalogg"]],"start1":7965,"start2":7965,"length1":36,"length2":24},{"diffs":[[0,"g\", fyMag),\n"],[-1,"            "],[0,"    datalogg"]],"start1":8006,"start2":8006,"length1":36,"length2":24},{"diffs":[[0,"g\", fzMag),\n"],[-1,"            "],[0,"    datalogg"]],"start1":8047,"start2":8047,"length1":36,"length2":24},{"diffs":[[0,"g\", gxMag),\n"],[-1,"            "],[0,"    datalogg"]],"start1":8088,"start2":8088,"length1":36,"length2":24},{"diffs":[[0,"gyMag),\n"],[-1,"            "],[0,"    data"]],"start1":8133,"start2":8133,"length1":28,"length2":16},{"diffs":[[0,"g))\n"],[-1,"let northXYZ: Vector\nlet fromXYZtoENG: Quaternion\n\nfunction correctedField(): Vector {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    f.x = \n    return f\n}"],[0,"\n\n"]],"start1":8178,"start2":8178,"length1":213,"length2":6}]}]},{"timestamp":1724654855210,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"z))\n\n})\n"],[-1,"\n\n\n\n"],[0,"let lit "]],"start1":5501,"start2":5501,"length1":20,"length2":16},{"diffs":[[0," }\n}"],[-1,"\nbasic.showIcon(IconNames.Happy)"],[0,"\n\nle"]],"start1":7365,"start2":7365,"length1":40,"length2":8},{"diffs":[[0," 2\n\n"],[-1,"let fxScale = 1000 / fxMag\nlet fyScale = 1000 / fyMag\nlet fzScale = 1000 / fzMag\n\n"],[0,"let "]],"start1":7548,"start2":7548,"length1":90,"length2":8},{"diffs":[[0,"- gyLo) / 2\n"],[1,""],[0,"let gzMag = "]],"start1":7690,"start2":7690,"length1":24,"length2":24},{"diffs":[[0," 2\n\n"],[-1,"let gxScale = 1000 / gxMag\nlet gyScale = 1000 / gyMag\nlet gzScale = 1000 / gzMag\n\n"],[0,"data"]],"start1":7729,"start2":7729,"length1":90,"length2":8},{"diffs":[[0,"f.x "],[-1,"*"],[0,"= "],[-1,"fxScale\n    f.y *= fyScale\n    f.x *= fxScale"],[0,"\n   "]],"start1":8558,"start2":8558,"length1":56,"length2":10}]}]},{"timestamp":1724655453451,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    fromXYZtoENG.toAlignVectors()\n    \n})\n\n\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity("],[1,"//set North\n    \n})\n\n\ninput.onButtonPressed(Button.B, function() {\n    let field = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let gravity = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2)"],[0,")\n  "]],"start1":4446,"start2":4446,"length1":226,"length2":270},{"diffs":[[0,"(\"fx"],[-1,"Scale\", fxScale"],[1,"Mag\", fxMag"],[0,"),\n "]],"start1":8289,"start2":8289,"length1":23,"length2":19},{"diffs":[[0,"(\"fy"],[-1,"Scale\", fyScale"],[1,"Mag\", fyMag"],[0,"),\n "]],"start1":8342,"start2":8342,"length1":23,"length2":19},{"diffs":[[0,"(\"fz"],[-1,"Scale\", fzScale"],[1,"Mag\", fzMag"],[0,"),\n "]],"start1":8395,"start2":8395,"length1":23,"length2":19},{"diffs":[[0,"(\"gx"],[-1,"Scale\", gxScale"],[1,"Mag\", gxMag"],[0,"),\n "]],"start1":8448,"start2":8448,"length1":23,"length2":19},{"diffs":[[0,"(\"gy"],[-1,"Scale\", gyScale"],[1,"Mag\", gyMag"],[0,"),\n "]],"start1":8501,"start2":8501,"length1":23,"length2":19},{"diffs":[[0,"(\"gz"],[-1,"Scale\", gzScale"],[1,"Mag\", gzMag"],[0,"))\n"],[-1,"\n"],[0,"let "]],"start1":8554,"start2":8554,"length1":27,"length2":22},{"diffs":[[0,"tor\n"],[-1,"let downXYZ: Vector\n"],[0,"let "]],"start1":8589,"start2":8589,"length1":28,"length2":8},{"diffs":[[0,"  f."],[-1,"z"],[1,"x"],[0," *= f"],[-1,"z"],[1,"x"],[0,"Scal"]],"start1":8794,"start2":8794,"length1":15,"length2":15},{"diffs":[[0,"\n}\n\n"],[-1,"function correctedGravity(): Vector {\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    g.x *= gxScale\n    g.y *= gyScale\n    g.z *= gzScale\n    return g\n}\n"]],"start1":8823,"start2":8823,"length1":206,"length2":4}]}]},{"timestamp":1724655867129,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"te()"],[-1,"\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))"],[0,"\n   "]],"start1":2993,"start2":2993,"length1":241,"length2":8},{"diffs":[[0,"ors("],[-1,"downXYZ, new Vector(0,0,1000)"],[0,")\n  "]],"start1":4539,"start2":4539,"length1":37,"length2":8}]}]},{"timestamp":1724656738535,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," gxHi = "],[-1,"Math"],[0,"g.x\n    "]],"start1":7502,"start2":7502,"length1":20,"length2":16}]}]},{"timestamp":1724656740113,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"f.z\n"],[-1,"        /* not much point ranging gravity: distorted by inertial movement!"],[0,"\n   "]],"start1":7369,"start2":7369,"length1":82,"length2":8},{"diffs":[[0,"o = "],[-1,"Math.max(g.x, 0)"],[1,"g.x"],[0,"\n   "]],"start1":7401,"start2":7401,"length1":24,"length2":11},{"diffs":[[0,"o = "],[-1,"Math.max(g.y, 0)"],[1,"g.y"],[0,"\n   "]],"start1":7436,"start2":7436,"length1":24,"length2":11},{"diffs":[[0,"o = "],[-1,"Math.max(g.z, 0)"],[1,"g.z"],[0,"\n   "]],"start1":7471,"start2":7471,"length1":24,"length2":11},{"diffs":[[0,"Math"],[-1,".min(g.x, 1000)"],[1,"g.x"],[0,"\n   "]],"start1":7510,"start2":7510,"length1":23,"length2":11},{"diffs":[[0,"i = "],[-1,"Math.min(g.y, 1000)"],[1,"g.y"],[0,"\n   "]],"start1":7545,"start2":7545,"length1":27,"length2":11},{"diffs":[[0,"i = "],[-1,"Math.min(g.z, 1000)\n        */"],[1,"g.z"],[0,"\n   "]],"start1":7580,"start2":7580,"length1":38,"length2":11},{"diffs":[[0,"(2))\n   "],[-1," //"],[0," g.x *= "]],"start1":9219,"start2":9219,"length1":19,"length2":16},{"diffs":[[0,"cale\n   "],[-1," //"],[0," g.y *= "]],"start1":9238,"start2":9238,"length1":19,"length2":16},{"diffs":[[0,"cale\n   "],[-1," //"],[0," g.z *= "]],"start1":9257,"start2":9257,"length1":19,"length2":16}]}]},{"timestamp":1724657079923,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"count < "],[-1,"9"],[1,"25"],[0,") {\n    "]],"start1":6059,"start2":6059,"length1":17,"length2":18}]}]},{"timestamp":1724662130774,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n    // "],[1,"top"],[0,"side til"]],"start1":6472,"start2":6472,"length1":16,"length2":19}]}]},{"timestamp":1724668192472,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"side"],[-1,"wa"],[0," til"]],"start1":6480,"start2":6480,"length1":10,"length2":8}]}]},{"timestamp":1724668203459,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ixel"],[-1,"s"],[1," "],[0,"(px,py) "],[-1,"based on"],[1,"if"],[0," til"]],"start1":6276,"start2":6276,"length1":25,"length2":19},{"diffs":[[0,"gle "],[-1,"zones. \n    // using qx = (x / |z|); qy = (y / |z|) \n    //         outer| mid || mid |outer\n    // bound q:      \n    // topside:     1  |     |  2  |     |   2  | "],[1,"is: \n    //         outer -45 inner +45 outer \n    // topside:     1 | 2 | 2 |"],[0," 3\n "]],"start1":6299,"start2":6299,"length1":173,"length2":86},{"diffs":[[0,"  1 "],[-1," "],[0,"| "],[-1,"    |   0  |     |   4  | "],[1,"0 | 4 |"],[0," 3\n "]],"start1":6402,"start2":6402,"length1":37,"length2":17},{"diffs":[[0,"dewa"],[-1,"ys"],[0," til"]],"start1":6482,"start2":6482,"length1":10,"length2":8},{"diffs":[[0,"Z) px = 1 //"],[-1," far"],[0," outer left\n"]],"start1":6567,"start2":6567,"length1":28,"length2":24},{"diffs":[[0,"Z) px = 3 //"],[-1," far"],[0," outer right"]],"start1":6608,"start2":6608,"length1":28,"length2":24},{"diffs":[[0,"y = 1 //"],[-1," far"],[0," outer f"]],"start1":6655,"start2":6655,"length1":20,"length2":16},{"diffs":[[0,"3 //"],[-1," far"],[0," out"]],"start1":6701,"start2":6701,"length1":12,"length2":8}]}]},{"timestamp":1724668744109,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," let px="],[-1,"0"],[1,"2"],[0,"\n    let"]],"start1":6534,"start2":6534,"length1":17,"length2":17}]}]},{"timestamp":1724669862770,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    let "],[1,"p"],[0,"x=0\n    "]],"start1":6531,"start2":6531,"length1":16,"length2":17}]}]},{"timestamp":1724669865789,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s. \n    "],[1,"// using qx = (x / |z|); qy = (y / |z|) \n    //         outer| mid || mid |outer\n    // bound q:      \n    // topside:     1  |     |  2  |     |   2  |  3\n    // underside:   1  |     |   0  |     |   4  |  3\n    "],[0,"let "],[-1,"d"],[0,"x=0\n    "]],"start1":6313,"start2":6313,"length1":21,"length2":234},{"diffs":[[0,"let "],[-1,"dy=0"],[1,"py=2"],[0,"\n    "],[-1,"// left-right \n    if (g.x < -0.9) dx--\n    if (g.x < -0.1) dx--\n    if (g.x > 0.1) dx++\n    if (g.x > 0.9) dx++\n    // front-back\n    if (g.y < -0.9) dy--\n    if (g.y < -0.1) dy--"],[1,"let absZ = Math.abs(g.z)\n    // sideways tilts (note g.z is NEGATIVE, as it's mounted on the reverse!)\n    if (g.x < -absZ) px = 1 // far outer left\n    if (g.x > absZ) px = 3 // far outer right\n    if (g.y < -absZ) py = 1 // far outer front\n    if (g.y > absZ) py = 3 // far outer back\n    // special lower hemisphere cases (note g.z now POSITIVE)"],[0,"\n   "]],"start1":6547,"start2":6547,"length1":197,"length2":365},{"diffs":[[0," (g."],[-1,"y"],[1,"z"],[0," > 0"],[-1,".1) dy++\n    if (g.y > 0.9) dy++\n    // up-down\n    if (g.z > 0) {\n        dx = 2-dx\n        dy = 2-dy\n    }\n    let px = 2+dx\n    let py = 2+dy"],[1,") {\n        if ((-g.x < g.z) && (g.x < 0)) px = 0 // lower inner left\n        if ((g.x < g.z) && (g.x > 0)) px = 4 // lower inner right\n        if ((-g.y < g.z) && (g.y < 0)) py = 0 // lower inner front\n        if ((g.y < g.z) && (g.y > 0)) py = 4 // lower inner back\n    }"],[0,"\n\n  "]],"start1":6915,"start2":6915,"length1":157,"length2":286}]}]},{"timestamp":1724670435015,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"et dy=0\n"],[-1,"    \n"],[0,"    // l"]],"start1":6335,"start2":6335,"length1":21,"length2":16}]}]},{"timestamp":1724672515364,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"y=0\n    "],[-1,"let"],[0,"\n    // "]],"start1":6339,"start2":6339,"length1":19,"length2":16}]}]},{"timestamp":1724672517132,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," let"],[-1," zAbs = Math.abs(g.z)"],[0,"\n   "]],"start1":6346,"start2":6346,"length1":29,"length2":8},{"diffs":[[0,"x < -0.9"],[-1," * zAbs"],[0,") dx--\n "]],"start1":6380,"start2":6380,"length1":23,"length2":16},{"diffs":[[0,"x < -0.1"],[-1," * zAbs"],[0,") dx--\n "]],"start1":6405,"start2":6405,"length1":23,"length2":16},{"diffs":[[0,".x > 0.1"],[-1," * zAbs"],[0,") dx++\n "]],"start1":6429,"start2":6429,"length1":23,"length2":16},{"diffs":[[0,".x > 0.9"],[-1," * zAbs"],[0,") dx++\n "]],"start1":6453,"start2":6453,"length1":23,"length2":16},{"diffs":[[0,"y < -0.9"],[-1," * zAbs"],[0,") dy--\n "]],"start1":6496,"start2":6496,"length1":23,"length2":16},{"diffs":[[0,"y < -0.1"],[-1," * zAbs"],[0,") dy--\n "]],"start1":6521,"start2":6521,"length1":23,"length2":16},{"diffs":[[0,".y > 0.1"],[-1," * zAbs"],[0,") dy++\n "]],"start1":6545,"start2":6545,"length1":23,"length2":16},{"diffs":[[0," 0.9"],[-1," * zAbs"],[0,") dy"]],"start1":6573,"start2":6573,"length1":15,"length2":8}]}]},{"timestamp":1724672606555,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"count < "],[1,"9"],[0,") {\n    "]],"start1":6059,"start2":6059,"length1":16,"length2":17}]}]},{"timestamp":1724673325876,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t < "],[-1,"25"],[0,") {\n"]],"start1":6063,"start2":6063,"length1":10,"length2":8}]}]},{"timestamp":1724673326552,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," -0."],[-1,"1"],[1,"9"],[0," * zAbs)"],[-1," {\n       "],[0," dx--\n"],[-1,"    "],[0,"    "]],"start1":6405,"start2":6405,"length1":37,"length2":23},{"diffs":[[0,"   if (g.x < -0."],[-1,"9"],[1,"1"],[0," * zAbs) dx--\n  "]],"start1":6425,"start2":6425,"length1":33,"length2":33},{"diffs":[[0,"s) dx--\n"],[-1,"    }\n"],[0,"    if ("]],"start1":6448,"start2":6448,"length1":22,"length2":16},{"diffs":[[0,"Abs)"],[-1," {\n       "],[0," dx++\n"],[-1,"    "],[0,"    "]],"start1":6477,"start2":6477,"length1":28,"length2":14},{"diffs":[[0,"s) dx++\n"],[-1,"    }\n"],[0,"    // f"]],"start1":6510,"start2":6510,"length1":22,"length2":16},{"diffs":[[0," -0."],[-1,"1"],[1,"9"],[0," * zAbs)"],[-1," {\n       "],[0," dy--\n"],[-1,"    "],[0,"    "]],"start1":6549,"start2":6549,"length1":37,"length2":23},{"diffs":[[0,"   if (g.y < -0."],[-1,"9"],[1,"1"],[0," * zAbs) dy--\n  "]],"start1":6569,"start2":6569,"length1":33,"length2":33},{"diffs":[[0,"s) dy--\n"],[-1,"    }\n"],[0,"    if ("]],"start1":6592,"start2":6592,"length1":22,"length2":16},{"diffs":[[0,"Abs)"],[-1," {\n       "],[0," dy++\n"],[-1,"    "],[0,"    "]],"start1":6621,"start2":6621,"length1":28,"length2":14},{"diffs":[[0,"s) dy++\n"],[-1,"    }\n"],[0,"    // u"]],"start1":6654,"start2":6654,"length1":22,"length2":16}]}]},{"timestamp":1724677017130,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," up-down"],[-1,": "],[0,"\n    if "]],"start1":6748,"start2":6748,"length1":18,"length2":16},{"diffs":[[0,"    "],[-1," //               -2 -1  0  0  1  2\n          if (g.x < 0)"],[0," dx "],[-1,"-"],[0,"= "],[-1,"8\n      //            -> -2 -3 -4  4  3  2"],[1,"2-dx"],[0,"\n   "]],"start1":6779,"start2":6779,"length1":115,"length2":18},{"diffs":[[0,"y = "],[-1,"4"],[1,"2"],[0,"-dy"],[-1," //      6  5  4  4  3  2"],[0,"\n"],[1," "],[0,"   }"]],"start1":6803,"start2":6803,"length1":38,"length2":14}]}]},{"timestamp":1724688644269,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"dx -= 8\n    "],[1,"  "],[0,"//          "]],"start1":6844,"start2":6844,"length1":24,"length2":26}]}]},{"timestamp":1724688675856,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n        "],[-1,"           "],[1,"//"],[0,"            "]],"start1":6774,"start2":6774,"length1":35,"length2":26},{"diffs":[[0,"/           "],[-1,"  //"],[0,"    -2 -1  0"]],"start1":6787,"start2":6787,"length1":28,"length2":24},{"diffs":[[0,"1  0"],[-1,"|"],[1,"  "],[0,"0  1  2\n"],[1,"  "],[0,"    "]],"start1":6807,"start2":6807,"length1":17,"length2":20},{"diffs":[[0," dx -= 8"],[1,"\n"],[0,"    //"],[1,"           "],[0," -> -2 -"]],"start1":6843,"start2":6843,"length1":22,"length2":34},{"diffs":[[0,"-2 -3 -4"],[-1,"|"],[1,"  "],[0,"4  3  2\n"]],"start1":6873,"start2":6873,"length1":17,"length2":18},{"diffs":[[0,"-dy "],[1,"//"],[0,"    "],[-1,"          // ->"],[0,"  6 "]],"start1":6905,"start2":6905,"length1":27,"length2":14},{"diffs":[[0,"5  4"],[-1,"|"],[1,"  "],[0,"4  3"]],"start1":6920,"start2":6920,"length1":9,"length2":10}]}]},{"timestamp":1724688857973,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(g.x < -"],[1,"0.9"],[0," * zAbs)"]],"start1":6445,"start2":6445,"length1":16,"length2":19}]}]},{"timestamp":1724740597279,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(g.x < -"],[-1,"10"],[0," * zAbs)"]],"start1":6445,"start2":6445,"length1":18,"length2":16}]}]},{"timestamp":1724740610813,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," (g.x > "],[-1,"1"],[0,"0"],[1,".9"],[0," * zAbs)"]],"start1":6526,"start2":6526,"length1":18,"length2":19},{"diffs":[[0," if (g.y < -"],[-1,"1"],[0,"0"],[1,".9"],[0," * zAbs) dy-"]],"start1":6624,"start2":6624,"length1":26,"length2":27},{"diffs":[[0," (g.y > "],[-1,"1"],[0,"0"],[1,".9"],[0," * zAbs)"]],"start1":6710,"start2":6710,"length1":18,"length2":19},{"diffs":[[0,"z > 0) {"],[1,"\n"],[0,"        "]],"start1":6768,"start2":6768,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"//"],[0,"    "],[-1,"-2 -1  0|0  1"],[1,"      "],[0,"  "],[-1,"2\n"],[0,"      "],[-1,"  dx = 4-dx\n   "],[1,"//    -2 -1  0|0"],[0,"  "],[1,"1"],[0,"  "],[-1," dy = 4-dy           "],[1,"2\n        if (g.x < 0) dx -= 8"],[0,"    "]],"start1":6787,"start2":6787,"length1":77,"length2":77},{"diffs":[[0," -> "],[-1," 6  5  "],[1,"-2 -3 -"],[0,"4|4 "]],"start1":6866,"start2":6866,"length1":15,"length2":15},{"diffs":[[0,"    "],[-1," if (g.y < 0)"],[0," dy "],[-1,"-"],[0,"= "],[-1,"8\n  "],[1,"4-dy"],[0,"      "],[-1,"if (g.x < 0) dx -= 8"],[1,"     "],[0,"    "]],"start1":6890,"start2":6890,"length1":58,"length2":29},{"diffs":[[0,"          // -> "],[-1,"-2 -3 -"],[1," 6  5  "],[0,"4|4  3  2\n   }\n "]],"start1":6909,"start2":6909,"length1":39,"length2":39}]}]},{"timestamp":1724741383055,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".x < -0."],[-1,"2"],[1,"1"],[0," * zAbs)"]],"start1":6401,"start2":6401,"length1":17,"length2":17}]}]},{"timestamp":1724741389607,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"if (g.x > 0."],[-1,"2"],[1,"1"],[0," * zAbs) {\n "]],"start1":6479,"start2":6479,"length1":25,"length2":25},{"diffs":[[0,"f (g.y < -0."],[-1,"2"],[1,"1"],[0," * zAbs) {\n "]],"start1":6579,"start2":6579,"length1":25,"length2":25},{"diffs":[[0,"g.y > 0."],[-1,"2"],[1,"1"],[0," * zAbs)"]],"start1":6665,"start2":6665,"length1":17,"length2":17},{"diffs":[[0,"\n       "],[-1,"//"],[0," led.plo"]],"start1":7060,"start2":7060,"length1":18,"length2":16},{"diffs":[[0,",py)"],[-1,"\n\n        meter.show(px*10+py)\n        "],[0,"\n   "]],"start1":7080,"start2":7080,"length1":47,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n   "]],"start1":160,"start2":160,"length1":69,"length2":8}]}]},{"timestamp":1724741551805,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n       "],[1,"//"],[0," led.plo"]],"start1":7060,"start2":7060,"length1":16,"length2":18},{"diffs":[[0,"\n       "],[-1," //"],[0," meter.s"]],"start1":7087,"start2":7087,"length1":19,"length2":16}]}]},{"timestamp":1724742150348,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"er\": \"*\""],[1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n    },\n"]],"start1":156,"start2":156,"length1":16,"length2":77}]}]},{"timestamp":1724742163535,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"999\n"],[-1,"let f: \n"],[0,"whil"]],"start1":6048,"start2":6048,"length1":16,"length2":8}]}]},{"timestamp":1724742763183,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"et f"],[1,":"],[0," "],[-1,"= new Vector(0,0,0)\nlet g = new Vector(0,0,0)\nlet zAbs: number\nlet dx = 0\nlet dy = 0"],[0,"\nwhi"]],"start1":6053,"start2":6053,"length1":93,"length2":10},{"diffs":[[0,"    "],[-1,"f.x = "],[1,"let f = new Vector("],[0,"inpu"]],"start1":6081,"start2":6081,"length1":14,"length2":27},{"diffs":[[0,"e(0)"],[-1,"\n    f.y ="],[1,","],[0," inp"]],"start1":6122,"start2":6122,"length1":18,"length2":9},{"diffs":[[0,"e(1)"],[-1,"\n    f.z ="],[1,","],[0," inp"]],"start1":6146,"start2":6146,"length1":18,"length2":9},{"diffs":[[0,"e(2)"],[1,")"],[0,"\n    "],[-1,"g.x = "],[1,"let g = new Vector("],[0,"inpu"]],"start1":6170,"start2":6170,"length1":19,"length2":33},{"diffs":[[0,"n(0)"],[-1,"\n    g.y ="],[1,","],[0," inp"]],"start1":6216,"start2":6216,"length1":18,"length2":9},{"diffs":[[0,"n(1)"],[-1,"\n    g.z ="],[1,","],[0," inp"]],"start1":6239,"start2":6239,"length1":18,"length2":9},{"diffs":[[0,"ation(2)"],[1,")"],[0,"\n\n    //"]],"start1":6258,"start2":6258,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"dx = 0\n    dy = 0\n    let z = g.z\n   "],[1,"let dx=0\n    let dy=0\n    let"],[0," zAb"]],"start1":6326,"start2":6326,"length1":45,"length2":37},{"diffs":[[0,"ath.abs("],[1,"g."],[0,"z)\n    /"]],"start1":6368,"start2":6368,"length1":16,"length2":18}]}]},{"timestamp":1724743131637,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"th.abs(z"],[-1,","],[0,")\n    //"]],"start1":6468,"start2":6468,"length1":17,"length2":16}]}]},{"timestamp":1724766218773,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"h.abs(z,"],[-1,"3"],[0,")\n    //"]],"start1":6469,"start2":6469,"length1":17,"length2":16}]}]},{"timestamp":1724766223597,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n(2)"],[-1,"\n    zAbs = Math.abs(g.z)"],[0,"\n\n  "]],"start1":6354,"start2":6354,"length1":33,"length2":8},{"diffs":[[0,"    "],[-1,"// face-up, g is {0,0,-1024}"],[1,"let z = g.z\n    zAbs = Math.abs(z,3)"],[0,"\n   "]],"start1":6439,"start2":6439,"length1":36,"length2":44},{"diffs":[[0,"f (g.x < -0."],[-1,"1"],[1,"2"],[0," * zAbs) {  "]],"start1":6504,"start2":6504,"length1":25,"length2":25},{"diffs":[[0,"s) {"],[-1,"       //  ~5 degrees left"],[0,"\n   "]],"start1":6523,"start2":6523,"length1":34,"length2":8},{"diffs":[[0,"dx--"],[-1," // ~85 degrees left"],[0,"\n   "]],"start1":6571,"start2":6571,"length1":28,"length2":8},{"diffs":[[0,"if (g.x > 0."],[-1,"1"],[1,"2"],[0," * zAbs) {  "]],"start1":6586,"start2":6586,"length1":25,"length2":25},{"diffs":[[0,"s) {"],[-1,"       //  ~5 degrees right"],[0,"\n   "]],"start1":6605,"start2":6605,"length1":35,"length2":8},{"diffs":[[0,"dx++"],[-1," // ~85 degrees right"],[0,"\n   "]],"start1":6652,"start2":6652,"length1":29,"length2":8},{"diffs":[[0,".y < -0."],[-1,"1"],[1,"2"],[0," * zAbs)"]],"start1":6690,"start2":6690,"length1":17,"length2":17},{"diffs":[[0,"s) {"],[-1,"       //  ~5 degrees front"],[0,"\n   "]],"start1":6705,"start2":6705,"length1":35,"length2":8},{"diffs":[[0,"dy--"],[-1," // ~85 degrees front"],[0,"\n   "]],"start1":6753,"start2":6753,"length1":29,"length2":8},{"diffs":[[0,"g.y > 0."],[-1,"1"],[1,"2"],[0," * zAbs)"]],"start1":6772,"start2":6772,"length1":17,"length2":17},{"diffs":[[0,"s) {"],[-1,"       //  ~5 degrees back"],[0,"\n   "]],"start1":6787,"start2":6787,"length1":34,"length2":8},{"diffs":[[0,"dy++"],[-1," // ~85 degrees back"],[0,"\n   "]],"start1":6834,"start2":6834,"length1":28,"length2":8},{"diffs":[[0,"wn: "],[-1,"                       -85 -5 0  5 85"],[0,"\n   "]],"start1":6857,"start2":6857,"length1":45,"length2":8}]}]},{"timestamp":1724766820237,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    pause(200)\n"],[0,"    "]],"start1":6160,"start2":6160,"length1":23,"length2":8},{"diffs":[[0," (g."],[-1,"x"],[1,"y"],[0," < 0) d"],[-1,"x"],[1,"y"],[0," -= "]],"start1":7242,"start2":7242,"length1":17,"length2":17},{"diffs":[[0,"      if (g."],[-1,"y"],[1,"x"],[0," < 0) d"],[-1,"y"],[1,"x"],[0," -= 8    // "]],"start1":7263,"start2":7263,"length1":33,"length2":33},{"diffs":[[0,"\n   "],[-1," "],[0,"}\n    "],[-1,"d"],[1,"let p"],[0,"x "],[-1,"+"],[0,"= 2"],[1,"+dx"],[0,"\n    "],[-1,"d"],[1,"let p"],[0,"y "],[-1,"+"],[0,"= 2"],[1,"+dy"],[0,"\n\n  "]],"start1":7315,"start2":7315,"length1":34,"length2":45},{"diffs":[[0,"    if (lit["],[-1,"dx][d"],[1,"px][p"],[0,"y] == 0) {\n "]],"start1":7358,"start2":7358,"length1":29,"length2":29},{"diffs":[[0,"lit["],[-1,"dx][d"],[1,"px][p"],[0,"y] ="]],"start1":7394,"start2":7394,"length1":13,"length2":13},{"diffs":[[0,"lot("],[-1,"dx,d"],[1,"px,p"],[0,"y)\n\n"]],"start1":7423,"start2":7423,"length1":12,"length2":12},{"diffs":[[0,"how("],[-1,"d"],[1,"p"],[0,"x*10+"],[-1,"d"],[1,"p"],[0,"y)\n "]],"start1":7453,"start2":7453,"length1":15,"length2":15}]}]},{"timestamp":1724767371520,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n       "],[-1," //"],[0," led.plo"]],"start1":7413,"start2":7413,"length1":19,"length2":16},{"diffs":[[0,"\n       "],[1," //"],[0," meter.s"]],"start1":7438,"start2":7438,"length1":16,"length2":19}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n   "]],"start1":160,"start2":160,"length1":69,"length2":8}]}]},{"timestamp":1724767947932,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"    // here, dx or dy can each only range from -2 to +2 \n\n"],[0,"    "]],"start1":7061,"start2":7061,"length1":66,"length2":8}]}]},{"timestamp":1724768494369,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," (g.x < "],[-1,"("],[0,"-0.1 * z"]],"start1":6537,"start2":6537,"length1":17,"length2":16},{"diffs":[[0,"x < -0.1 * zAbs)"],[-1,")"],[0," {       // >5 d"]],"start1":6541,"start2":6541,"length1":33,"length2":32},{"diffs":[[0,"     // "],[-1,">"],[1," ~"],[0,"5 degree"]],"start1":6561,"start2":6561,"length1":17,"length2":18},{"diffs":[[0," (g.x < "],[-1,"("],[0,"-10 * zA"]],"start1":6609,"start2":6609,"length1":17,"length2":16},{"diffs":[[0," * zAbs)"],[-1,")"],[0," dx-- //"]],"start1":6620,"start2":6620,"length1":17,"length2":16},{"diffs":[[0,"bs) dx-- // "],[-1,">"],[1,"~"],[0,"85 degrees l"]],"start1":6625,"start2":6625,"length1":25,"length2":25},{"diffs":[[0," (g.x > "],[-1,"("],[0,"0.1 * zA"]],"start1":6666,"start2":6666,"length1":17,"length2":16},{"diffs":[[0,".x > 0.1 * zAbs)"],[-1,")"],[0," {       //  >5 "]],"start1":6669,"start2":6669,"length1":33,"length2":32},{"diffs":[[0,"bs) {       //  "],[-1,">"],[1,"~"],[0,"5 degrees right\n"]],"start1":6682,"start2":6682,"length1":33,"length2":33},{"diffs":[[0," (g.x > "],[-1,"("],[0,"10 * zAb"]],"start1":6738,"start2":6738,"length1":17,"length2":16},{"diffs":[[0," * zAbs)"],[-1,")"],[0," dx++ //"]],"start1":6748,"start2":6748,"length1":17,"length2":16},{"diffs":[[0,"bs) dx++ // "],[-1,">"],[1,"~"],[0,"85 degrees r"]],"start1":6753,"start2":6753,"length1":25,"length2":25},{"diffs":[[0," (g.y < "],[-1,"("],[0,"-0.1 * z"]],"start1":6813,"start2":6813,"length1":17,"length2":16},{"diffs":[[0,"y < -0.1 * zAbs)"],[-1,")"],[0," {       //  >5 "]],"start1":6817,"start2":6817,"length1":33,"length2":32},{"diffs":[[0,"bs) {       //  "],[-1,">"],[1,"~"],[0,"5 degrees forwar"]],"start1":6830,"start2":6830,"length1":33,"length2":33},{"diffs":[[0,"~5 degrees f"],[-1,"orwards"],[1,"ront"],[0,"\n        dy-"]],"start1":6846,"start2":6846,"length1":31,"length2":28},{"diffs":[[0," (g.y < "],[-1,"("],[0,"-10 * zA"]],"start1":6886,"start2":6886,"length1":17,"length2":16},{"diffs":[[0," * zAbs)"],[-1,")"],[0," dy-- //"]],"start1":6897,"start2":6897,"length1":17,"length2":16},{"diffs":[[0,"bs) dy-- // "],[-1,">"],[1,"~"],[0,"85 degrees f"]],"start1":6902,"start2":6902,"length1":25,"length2":25},{"diffs":[[0,"es f"],[-1,"orwards"],[1,"ront"],[0,"\n   "]],"start1":6923,"start2":6923,"length1":15,"length2":12},{"diffs":[[0," (g.y > "],[-1,"("],[0,"0.1 * zA"]],"start1":6944,"start2":6944,"length1":17,"length2":16},{"diffs":[[0," * zAbs)"],[-1,")"],[0," {      "]],"start1":6955,"start2":6955,"length1":17,"length2":16},{"diffs":[[0,"    //  "],[-1,">"],[1,"~"],[0,"5 degree"]],"start1":6968,"start2":6968,"length1":17,"length2":17},{"diffs":[[0,"degrees back"],[-1,"wards"],[0,"\n        dy+"]],"start1":6979,"start2":6979,"length1":29,"length2":24},{"diffs":[[0," (g.y > "],[-1,"("],[0,"10 * zAb"]],"start1":7015,"start2":7015,"length1":17,"length2":16},{"diffs":[[0," * zAbs)"],[-1,")"],[0," dy++ //"]],"start1":7025,"start2":7025,"length1":17,"length2":16},{"diffs":[[0,"dy++ // "],[-1,">"],[1,"~"],[0,"85 degre"]],"start1":7034,"start2":7034,"length1":17,"length2":17},{"diffs":[[0,"back"],[-1,"wards"],[0,"\n   "]],"start1":7054,"start2":7054,"length1":13,"length2":8},{"diffs":[[0," // "],[-1,"at this point"],[1,"here"],[0,", dx"]],"start1":7068,"start2":7068,"length1":21,"length2":12},{"diffs":[[0," // "],[-1,"lower hemisphere"],[1,"up-down:    "],[0,"    "]],"start1":7126,"start2":7126,"length1":24,"length2":20},{"diffs":[[0,"    "],[1,"      "],[0,"-85"],[-1,":"],[0," -5"],[-1,":"],[0," 0  "],[-1," "],[-1,":"],[0,"5 "],[-1,":"],[0,"85\n "]],"start1":7152,"start2":7152,"length1":25,"length2":26},{"diffs":[[0,"/    -2 "],[-1," "],[0,"-1  0|0 "]],"start1":7210,"start2":7210,"length1":17,"length2":16},{"diffs":[[0," ->  6  "],[-1," "],[0,"5  4|4  "]],"start1":7284,"start2":7284,"length1":17,"length2":16},{"diffs":[[0,"/ -> -2 "],[-1," "],[0,"-3 -4|4 "]],"start1":7367,"start2":7367,"length1":17,"length2":16}]}]},{"timestamp":1724769093027,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"-5: "],[-1," "],[0,"0"],[1," "],[0,"  :5 :85"],[-1," degrees"],[0,"\n   "]],"start1":7205,"start2":7205,"length1":26,"length2":18}]}]},{"timestamp":1724769130462,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,")\n\n\n"],[-1,"// r"],[0,"\n\nle"]],"start1":5725,"start2":5725,"length1":12,"length2":8}]}]},{"timestamp":1724771270592,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"})\n\n\n// "],[1,"r"],[0,"\n\nlet li"]],"start1":5724,"start2":5724,"length1":16,"length2":17}]}]},{"timestamp":1724771271631,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n// "],[-1,"REMEMBER: chip is on the underside, so Z is -1023 when microbit is face-up!"],[0,"\n\nle"]],"start1":5728,"start2":5728,"length1":83,"length2":8},{"diffs":[[0,"r(0,"],[-1," "],[0,"0,"],[-1," "],[0,"0)\n"],[-1,"let xAbs: number\nlet yAbs: number\n"],[0,"let "]],"start1":6098,"start2":6098,"length1":49,"length2":13},{"diffs":[[0,"g.z)"],[-1,"\n    xAbs = Math.abs(g.x)\n    yAbs = Math.abs(g.y)"],[0,"\n\n  "]],"start1":6397,"start2":6397,"length1":58,"length2":8},{"diffs":[[0,"es. "],[-1,"\n\n    if(                             )\n\n\n\n\n\n"],[0,"\n   "]],"start1":6455,"start2":6455,"length1":53,"length2":8},{"diffs":[[0,"024}"],[-1,"\n\n    \n\n\n\n\n"],[0,"\n   "]],"start1":6510,"start2":6510,"length1":19,"length2":8}]}]},{"timestamp":1724771780760,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ber\nlet "],[-1,"p"],[1,"d"],[0,"x = 0\nle"]],"start1":6231,"start2":6231,"length1":17,"length2":17},{"diffs":[[0,"= 0\nlet "],[-1,"p"],[1,"d"],[0,"y = 0\nwh"]],"start1":6242,"start2":6242,"length1":17,"length2":17},{"diffs":[[0,"  if"],[-1," (g.z > 10 * (-g.x)) px = 0\n    if (g.z > 10 * (-g.y)) py = 0\n"],[1,"(                             )\n\n\n\n\n\n\n    dx = 0\n    dy = 0\n    // face-up, g is {0,0,-1024}\n\n    \n\n\n\n\n\n    // left-right \n    if (g.x < (-0.1 * zAbs)) {       // >5 degrees left\n        dx--\n    "],[0,"    if ("],[-1,"(-"],[0,"g.x"],[-1,") > "],[1," < (-"],[0,"10 *"]],"start1":6624,"start2":6624,"length1":87,"length2":220},{"diffs":[[0,"Abs)"],[-1," px = 1\n    if ((-g.y) > 10 * zAbs) py = 1\n"],[1,") dx-- // >85 degrees left\n    }\n    if (g.x > (0.1 * zAbs)) {       //  >5 degrees right\n        dx++\n    "],[0,"    if ("],[-1,"(-g.z)"],[1,"g.x"],[0," > "],[1,"("],[0,"10 * "],[-1,"x"],[1,"z"],[0,"Abs)"],[-1," px = 2\n    if ((-g.z) > "],[1,") dx++ // >85 degrees right\n    }\n    // front-back\n    if (g.y < (-0.1 * zAbs)) {       //  >5 degrees forwards\n        dy--\n        if (g.y < (-"],[0,"10 * "],[-1,"y"],[1,"z"],[0,"Abs)"],[-1," py = 2"],[1,") dy-- // >85 degrees forwards\n    }"],[0,"\n   "]],"start1":6846,"start2":6846,"length1":120,"length2":332},{"diffs":[[0," (g."],[-1,"x"],[1,"y"],[0," > "],[1,"(0."],[0,"1"],[-1,"0"],[0," * zAbs)"],[-1," px = 3\n"],[1,") {       //  >5 degrees backwards\n        dy++\n    "],[0,"    "]],"start1":7181,"start2":7181,"length1":30,"length2":76},{"diffs":[[0," (g.y > "],[1,"("],[0,"10 * zAb"]],"start1":7259,"start2":7259,"length1":16,"length2":17},{"diffs":[[0,"Abs)"],[-1," py = 3\n    if (g.z > 10 * g.x) px = 4\n"],[1,") dy++ // >85 degrees backwards\n    }\n    // at this point, dx or dy can each only range from -2 to +2 \n\n    // lower hemisphere              -85: -5:  0  :5 :85 degrees\n    if (g.z > 0) {              //    -2  -1  0|0  1  2\n        dx = 4-dx\n        dy = 4-dy               // ->  6   5  4|4  3  2\n    "],[0,"    "]],"start1":7274,"start2":7274,"length1":47,"length2":312},{"diffs":[[0," (g."],[-1,"z > 10 * g.y) p"],[1,"x < 0) dx -= 8\n        if (g.y < 0) d"],[0,"y "],[1,"-"],[0,"= "],[-1,"4"],[1,"8    // -> -2  -3 -4|4  3  2\n    }\n    dx += 2\n    dy += 2"],[0,"\n\n  "]],"start1":7588,"start2":7588,"length1":28,"length2":108},{"diffs":[[0,"    if (lit["],[-1,"px][p"],[1,"dx][d"],[0,"y] == 0) {\n "]],"start1":7694,"start2":7694,"length1":29,"length2":29},{"diffs":[[0,"lit["],[-1,"px][p"],[1,"dx][d"],[0,"y] ="]],"start1":7730,"start2":7730,"length1":13,"length2":13},{"diffs":[[0,"\n       "],[1," //"],[0," led.plo"]],"start1":7745,"start2":7745,"length1":16,"length2":19},{"diffs":[[0,"lot("],[-1,"px, p"],[1,"dx,d"],[0,"y)\n\n"]],"start1":7762,"start2":7762,"length1":13,"length2":12},{"diffs":[[0,"       m"],[-1,"//"],[0,"eter.sho"]],"start1":7775,"start2":7775,"length1":18,"length2":16}]}]},{"timestamp":1724772384008,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"       m"],[1,"//"],[0,"eter.sho"]],"start1":7036,"start2":7036,"length1":16,"length2":18}]}]},{"timestamp":1724772385274,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,". \n\n"],[-1,"    // face-down from left/front\n"],[0,"    "]],"start1":6618,"start2":6618,"length1":41,"length2":8},{"diffs":[[0,".x)) px = 0\n"],[1,""],[0,"    if (g.z "]],"start1":6644,"start2":6644,"length1":24,"length2":24},{"diffs":[[0,"= 0\n"],[-1,"    // facing left/front\n"],[0,"    "]],"start1":6686,"start2":6686,"length1":33,"length2":8},{"diffs":[[0,"= 1\n"],[-1,"    // face-up\n"],[0,"    "]],"start1":6756,"start2":6756,"length1":23,"length2":8},{"diffs":[[0,"= 2\n"],[-1,"    // facing right/back\n"],[0,"    "]],"start1":6826,"start2":6826,"length1":33,"length2":8},{"diffs":[[0,"= 3\n"],[-1,"    // face-down from right/back\n"],[0,"    "]],"start1":6890,"start2":6890,"length1":41,"length2":8},{"diffs":[[0,"x, py)\n\n"],[1,""],[0,"       "],[-1," //"],[0," meter.s"]],"start1":7027,"start2":7027,"length1":26,"length2":23}]}]},{"timestamp":1724772726092,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n       "],[-1," //"],[0," led.plo"]],"start1":7139,"start2":7139,"length1":19,"length2":16},{"diffs":[[0,"\n       "],[1," //"],[0," meter.s"]],"start1":7165,"start2":7165,"length1":16,"length2":19}]}]},{"timestamp":1724776384265,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 4\n\n"],[-1,"        meter.show(dx*10+dy)\n"],[0,"    "]],"start1":7084,"start2":7084,"length1":37,"length2":8},{"diffs":[[0,"ot(px, py)\n\n"],[1,"        meter.show(dx*10+dy)\n"],[0,"        \n   "]],"start1":7157,"start2":7157,"length1":24,"length2":53}]}]},{"timestamp":1724776388832,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"unt < 25) {\n"],[1,"    pause(200)\n"],[0,"    f.x = in"]],"start1":6266,"start2":6266,"length1":24,"length2":39},{"diffs":[[0,"ront"],[-1,":    gx/gy near 0; gz +1000"],[0,"\n   "]],"start1":6650,"start2":6650,"length1":35,"length2":8},{"diffs":[[0,"  if (g.z > "],[-1,"5"],[1,"10"],[0," * (-g.x)) p"]],"start1":6657,"start2":6657,"length1":25,"length2":26},{"diffs":[[0," (g.z > "],[-1,"5"],[1,"10"],[0," * (-g.y"]],"start1":6695,"start2":6695,"length1":17,"length2":18},{"diffs":[[0,"ront"],[-1,"             gx/gy -1000; gz near 0"],[0,"\n   "]],"start1":6743,"start2":6743,"length1":43,"length2":8},{"diffs":[[0,"f ((-g.x) > "],[-1,"5"],[1,"10"],[0," * zAbs) px "]],"start1":6753,"start2":6753,"length1":25,"length2":26},{"diffs":[[0,"-g.y) > "],[-1,"5"],[1,"10"],[0," * zAbs)"]],"start1":6792,"start2":6792,"length1":17,"length2":18},{"diffs":[[0,"-g.z) > "],[-1,"5"],[1,"10"],[0," * xAbs)"]],"start1":6842,"start2":6842,"length1":17,"length2":18},{"diffs":[[0,"-g.z) > "],[-1,"5"],[1,"10"],[0," * yAbs)"]],"start1":6877,"start2":6877,"length1":17,"length2":18},{"diffs":[[0," (g.x > "],[-1,"5"],[1,"10"],[0," * zAbs)"]],"start1":6934,"start2":6934,"length1":17,"length2":18},{"diffs":[[0," (g.y > "],[-1,"5"],[1,"10"],[0," * zAbs)"]],"start1":6966,"start2":6966,"length1":17,"length2":18},{"diffs":[[0,"  if (g.z > "],[-1,"5"],[1,"10"],[0," * g.x) px ="]],"start1":7027,"start2":7027,"length1":25,"length2":26},{"diffs":[[0," (g.z > "],[-1,"5"],[1,"10"],[0," * g.y) "]],"start1":7062,"start2":7062,"length1":17,"length2":18},{"diffs":[[0,"    "],[-1,"datalogger.log(\n        datalogger.createCV(\"g.x\", g.x), \n        datalogger.createCV(\"g.y\", g.y), \n        datalogger.createCV(\"g.z\", g.z),\n        datalogger.createCV(\"px\", px), \n        datalogger.createCV(\"py\", g.x))\n"],[0,"    "]],"start1":7088,"start2":7088,"length1":229,"length2":8},{"diffs":[[0,"how("],[-1,"p"],[1,"d"],[0,"x*10"],[-1," + py)\n    pause(1000)\n"],[1,"+dy)"],[0,"\n   "]],"start1":7103,"start2":7103,"length1":36,"length2":17}]}]},{"timestamp":1724776988090,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"V(\"py\", "],[-1,"py"],[1,"g.x"],[0,"))\n    m"]],"start1":7336,"start2":7336,"length1":18,"length2":19}]}]},{"timestamp":1724776998755,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"))\n\n"],[-1,"input.onLogoEvent(TouchButtonEvent.Pressed, function() {\n    \n})"],[0,"\n\nda"]],"start1":8974,"start2":8974,"length1":72,"length2":8}]}]},{"timestamp":1724778333613,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"zOff))\n\n"],[1,"input.onLogoEvent(TouchButtonEvent.Pressed, function() {\n    \n})\n"],[0,"\ndatalog"]],"start1":8970,"start2":8970,"length1":16,"length2":81}]}]},{"timestamp":1724778339035,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"})\n\n"],[-1,"input.onLogoEvent(TouchButtonEvent.Pressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n})\n\n\n"],[0,"\n// "]],"start1":5724,"start2":5724,"length1":131,"length2":8}]}]},{"timestamp":1724778390125,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"mes.No)\n"],[-1,"    \n"],[0,"})\n\n\n\n//"]],"start1":5838,"start2":5838,"length1":21,"length2":16}]}]},{"timestamp":1724779185711,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"No)\n    "],[-1,"pa"],[0,"\n})\n\n\n\n/"]],"start1":5842,"start2":5842,"length1":18,"length2":16}]}]},{"timestamp":1724779187341,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  pa"],[-1,"use(2000)\n    basic.clearScreen()"],[0,"\n})\n"]],"start1":5848,"start2":5848,"length1":41,"length2":8}]}]},{"timestamp":1724779205937,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"onEvent."],[1,"Pressed"],[0,", functi"]],"start1":5755,"start2":5755,"length1":16,"length2":23}]}]},{"timestamp":1724793560570,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ent."],[-1,"LongPressed"],[0,", fu"]],"start1":5759,"start2":5759,"length1":19,"length2":8}]}]},{"timestamp":1724793563683,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"/gy "],[-1,"just below"],[1,"near"],[0," 0; "]],"start1":6813,"start2":6813,"length1":18,"length2":12},{"diffs":[[0," facing "],[-1,"right/back:"],[1,"left/front "],[0,"        "]],"start1":6906,"start2":6906,"length1":27,"length2":27},{"diffs":[[0,"  gx/gy "],[-1,"+"],[1,"-"],[0,"1000; gz"]],"start1":6935,"start2":6935,"length1":17,"length2":17},{"diffs":[[0,"    if ("],[1,"(-"],[0,"g.x"],[1,")"],[0," > 5 * z"]],"start1":6960,"start2":6960,"length1":19,"length2":22},{"diffs":[[0,"    if ("],[1,"(-"],[0,"g.y"],[1,")"],[0," > 5 * z"]],"start1":6994,"start2":6994,"length1":19,"length2":22},{"diffs":[[0,"e-up"],[-1,":                      gx/gy near 0; gz -1000"],[0,"\n   "]],"start1":7038,"start2":7038,"length1":53,"length2":8},{"diffs":[[0,"ing "],[-1,"left/front             gx/gy -1000; gz near 0"],[1,"right/back"],[0,"\n   "]],"start1":7121,"start2":7121,"length1":53,"length2":18},{"diffs":[[0,"ht/back\n    if ("],[-1,"(-"],[0,"g.x"],[-1,")"],[0," > 5 * zAbs) px "]],"start1":7128,"start2":7128,"length1":38,"length2":35},{"diffs":[[0," px = 3\n    if ("],[-1,"(-"],[0,"g.y"],[-1,")"],[0," > 5 * zAbs) py "]],"start1":7159,"start2":7159,"length1":38,"length2":35},{"diffs":[[0,"back"],[-1,":   gx/gy just above 0; gz +1000"],[0,"\n   "]],"start1":7226,"start2":7226,"length1":40,"length2":8}]}]},{"timestamp":1724794424254,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gy just "],[1,"below"],[0," 0; gz +"]],"start1":6814,"start2":6814,"length1":16,"length2":21}]}]},{"timestamp":1724826752853,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"bove"],[-1,"below"],[0," 0; "]],"start1":7327,"start2":7327,"length1":13,"length2":8}]}]},{"timestamp":1724826756656,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,", 0, 0)\n"],[1,"let xAbs: number\nlet yAbs: number\n"],[0,"let zAbs"]],"start1":6343,"start2":6343,"length1":16,"length2":50},{"diffs":[[0,"abs(g.z)"],[1,"\n    xAbs = Math.abs(g.x)\n    yAbs = Math.abs(g.y)"],[0,"\n\n    //"]],"start1":6656,"start2":6656,"length1":16,"length2":66},{"diffs":[[0,"ust "],[-1,"above"],[0," 0; "]],"start1":6818,"start2":6818,"length1":13,"length2":8},{"diffs":[[0," if "],[-1,"("],[0,"(g.z > "],[-1,"10 * g.x) &&"],[1,"5 *"],[0," ("],[1,"-"],[0,"g.x"],[-1," > 0"],[0,")) p"]],"start1":6838,"start2":6838,"length1":37,"length2":24},{"diffs":[[0," if "],[-1,"("],[0,"(g.z > "],[-1,"10"],[1,"5"],[0," * "],[1,"(-"],[0,"g.y"],[-1,") && (g.y > 0"],[0,")) p"]],"start1":6871,"start2":6871,"length1":37,"length2":24},{"diffs":[[0," (g.x > "],[-1,"10"],[1,"5"],[0," * zAbs)"]],"start1":6967,"start2":6967,"length1":18,"length2":17},{"diffs":[[0," (g.y > "],[-1,"10"],[1,"5"],[0," * zAbs)"]],"start1":6998,"start2":6998,"length1":18,"length2":17},{"diffs":[[0,") > "],[-1,"10 * Math.abs(g.x)"],[1,"5 * xAbs"],[0,") px"]],"start1":7096,"start2":7096,"length1":26,"length2":16},{"diffs":[[0,") > "],[-1,"10 * Math.abs(g.y)"],[1,"5 * yAbs"],[0,") py"]],"start1":7130,"start2":7130,"length1":26,"length2":16},{"diffs":[[0,"f ((-g.x) > "],[-1,"10"],[1,"5"],[0," * zAbs) px "]],"start1":7216,"start2":7216,"length1":26,"length2":25},{"diffs":[[0,"-g.y) > "],[-1,"10"],[1,"5"],[0," * zAbs)"]],"start1":7254,"start2":7254,"length1":18,"length2":17},{"diffs":[[0,"gy just "],[1,"above"],[0,"below 0;"]],"start1":7318,"start2":7318,"length1":16,"length2":21},{"diffs":[[0," if "],[-1,"("],[0,"(g.z > "],[-1,"10"],[1,"5"],[0," * "],[-1,"(-"],[0,"g.x)"],[-1,") && (g.x < 0))"],[0," px "]],"start1":7352,"start2":7352,"length1":42,"length2":23},{"diffs":[[0," if "],[-1,"("],[0,"(g.z > "],[-1,"10"],[1,"5"],[0," * "],[-1,"(-"],[0,"g.y)"],[-1,") && (g.y < 0))"],[0," py "]],"start1":7382,"start2":7382,"length1":42,"length2":23}]}]},{"timestamp":1724827180503,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"10 * zAbs) px = "],[-1,"3"],[1,"1"],[0,"\n    if (g.y > 1"]],"start1":6922,"start2":6922,"length1":33,"length2":33},{"diffs":[[0,"10 * zAbs) py = "],[-1,"1"],[1,"3"],[0,"\n    // face-dow"]],"start1":7232,"start2":7232,"length1":33,"length2":33}]}]},{"timestamp":1724827651236,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"left"],[-1,":                 gx"],[1,"/front:    gx/gy"],[0," jus"]],"start1":6712,"start2":6712,"length1":28,"length2":24},{"diffs":[[0,"= 0\n"],[-1,"    // facing right:                        gx +1000; gz near 0\n"],[0,"    if "],[1,"("],[0,"(g."],[-1,"x"],[1,"z"],[0," > 10 * "],[-1,"zAbs) px = 3\n    // face-up:                             gx near 0; gz -1000\n    if ((-g.z) > 10 * Math.abs(g.x"],[1,"g.y) && (g.y > 0"],[0,")) p"],[-1,"x = 2"],[1,"y = 0"],[0,"\n   "]],"start1":6798,"start2":6798,"length1":211,"length2":53},{"diffs":[[0,"ing "],[-1,"left:         "],[1,"right/back:"],[0,"    "]],"start1":6858,"start2":6858,"length1":22,"length2":19},{"diffs":[[0,"    "],[-1,"    gx -"],[1,"gx/gy +"],[0,"1000"]],"start1":6881,"start2":6881,"length1":16,"length2":15},{"diffs":[[0,"    if ("],[-1,"(-"],[0,"g.x"],[-1,")"],[0," > 10 * "]],"start1":6908,"start2":6908,"length1":22,"length2":19},{"diffs":[[0,"x = "],[-1,"1\n    // face-down from right:                gx just below 0; gz +1000"],[1,"3"],[0,"\n    if "],[-1,"("],[0,"(g."],[-1,"z"],[1,"y"],[0," > 10 * "],[-1,"(-g.x)) && (g.x < 0)) px = 4\n"],[1,"zAbs) py = 1"],[0,"\n   "]],"start1":6934,"start2":6934,"length1":129,"length2":41},{"diffs":[[0,"ace-"],[-1,"down from front:"],[1,"up:      "],[0,"    "]],"start1":6980,"start2":6980,"length1":24,"length2":17},{"diffs":[[0,"       g"],[-1,"y just above"],[1,"x/gy near"],[0," 0; gz "],[-1,"+"],[1,"-"],[0,"1000\n   "]],"start1":7002,"start2":7002,"length1":36,"length2":33},{"diffs":[[0,"f (("],[1,"-"],[0,"g.z"],[1,")"],[0," > 10 * "],[-1,"g.y) && (g.y > 0)) py = 0\n    // facing back:                         gy +1000; gz near 0\n    if (g.y > 10 * zAbs) py = 1\n    // face-up:                             gy near 0; gz -1000"],[1,"Math.abs(g.x)) px = 2"],[0,"\n   "]],"start1":7037,"start2":7037,"length1":204,"length2":42},{"diffs":[[0," facing "],[1,"left/"],[0,"front"],[-1,":"],[0,"        "]],"start1":7126,"start2":7126,"length1":22,"length2":26},{"diffs":[[0,"        "],[-1,"           "],[1,"gx/"],[0,"gy -1000"]],"start1":7149,"start2":7149,"length1":27,"length2":19},{"diffs":[[0,"1000; gz near 0\n"],[1,"    if ((-g.x) > 10 * zAbs) px = 3\n"],[0,"    if ((-g.y) >"]],"start1":7164,"start2":7164,"length1":32,"length2":67},{"diffs":[[0,"s) py = "],[-1,"3"],[1,"1"],[0,"\n    // "]],"start1":7240,"start2":7240,"length1":17,"length2":17},{"diffs":[[0,"rom "],[1,"right/"],[0,"back:   "],[-1,"              "],[1,"gx/"],[0,"gy j"]],"start1":7268,"start2":7268,"length1":30,"length2":25},{"diffs":[[0,"low 0; gz +1000\n"],[1,"    if ((g.z > 10 * (-g.x)) && (g.x < 0)) px = 4\n"],[0,"    if ((g.z > 1"]],"start1":7299,"start2":7299,"length1":32,"length2":81},{"diffs":[[0,"py = 4\n\n"],[-1,"\n"],[0,"    data"]],"start1":7406,"start2":7406,"length1":17,"length2":16}]}]},{"timestamp":1724828099151,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"de, "],[-1,";\n// X is +1000 when facing left; Y is +1000 when facing front;"],[0,"so Z is "],[-1,"+1000"],[1,"-1023"],[0," whe"]],"start1":5931,"start2":5931,"length1":84,"length2":21},{"diffs":[[0,"is face-"],[-1,"down"],[1,"up!"],[0,"\n\nlet li"]],"start1":5963,"start2":5963,"length1":20,"length2":19}]}]},{"timestamp":1724828552898,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g front;"],[1,"so "],[0,"Z is +10"]],"start1":5990,"start2":5990,"length1":16,"length2":19}]}]},{"timestamp":1724837202310,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g front;"],[-1," "],[0,"Z is +10"]],"start1":5990,"start2":5990,"length1":17,"length2":16}]}]},{"timestamp":1724837203336,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"()\n})\n\n\n"],[1,"\n// REMEMBER: chip is on the underside, ;\n// X is +1000 when facing left; Y is +1000 when facing front; Z is +1000 when microbit is face-down"],[0,"\n\nlet li"]],"start1":5887,"start2":5887,"length1":16,"length2":157},{"diffs":[[0,"nes."],[-1,"\n    // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed:\n    // X is -1000 with button A at the top; +1000 with Button B at the top.  \n    // Y is -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n    // Z is -1000 when microbit is face-up; +1000 when face-down.\n"],[1," "],[0,"\n\n  "]],"start1":6745,"start2":6745,"length1":336,"length2":9},{"diffs":[[0,"= 0\n"],[-1,"    // facing left:                         gx -1000; gz near 0\n    if ((-g.x) > 10 * zAbs) px = 1\n"],[0,"    "]],"start1":6864,"start2":6864,"length1":107,"length2":8},{"diffs":[[0,"ear 0; gz -1000\n"],[-1,""],[0,"    if ((-g.z) >"]],"start1":7012,"start2":7012,"length1":32,"length2":32},{"diffs":[[0,".x)) px = 2\n"],[1,"    // facing left:                         gx -1000; gz near 0\n    if ((-g.x) > 10 * zAbs) px = 1\n"],[0,"    // face-"]],"start1":7060,"start2":7060,"length1":24,"length2":123}]}]},{"timestamp":1724837888232,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0)) px = 0\n"],[1,"    // facing left:                         gx -1000; gz near 0\n    if ((-g.x) > 10 * zAbs) px = 1\n"],[0,"    // facin"]],"start1":7042,"start2":7042,"length1":24,"length2":123},{"diffs":[[0,"= 2\n"],[-1,"    // facing left:                         gx -1000; gz near 0\n    if ((-g.x) > 10 * zAbs) px = 1\n"],[0,"    "]],"start1":7353,"start2":7353,"length1":107,"length2":8}]}]},{"timestamp":1724837888745,"editorVersion":"7.0.25","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," // "],[-1,"Button B at the top:"],[1,"facing right:       "],[0,"    "]],"start1":7057,"start2":7057,"length1":28,"length2":28},{"diffs":[[0,"s) px = "],[-1,"1"],[1,"3"],[0,"\n    // "]],"start1":7140,"start2":7140,"length1":17,"length2":17},{"diffs":[[0," // "],[-1,"Button A at the top:"],[1,"facing left:        "],[0,"    "]],"start1":7261,"start2":7261,"length1":28,"length2":28},{"diffs":[[0,"10 * zAbs) px = "],[-1,"3"],[1,"1"],[0,"\n    // face-dow"]],"start1":7339,"start2":7339,"length1":33,"length2":33},{"diffs":[[0," // "],[-1,"Logo at the top:"],[1,"facing back:    "],[0,"    "]],"start1":7596,"start2":7596,"length1":24,"length2":24},{"diffs":[[0,"     gy "],[-1,"-"],[1,"+"],[0,"1000; gz"]],"start1":7632,"start2":7632,"length1":17,"length2":17},{"diffs":[[0,"    if ("],[-1,"(-"],[0,"g.y"],[-1,")"],[0," > 10 * "]],"start1":7657,"start2":7657,"length1":22,"length2":19},{"diffs":[[0," // "],[-1,"Logo at the bottom:"],[1,"facing front:      "],[0,"    "]],"start1":7800,"start2":7800,"length1":27,"length2":27},{"diffs":[[0,"             gy "],[-1,"+"],[1,"-"],[0,"1000; gz near 0\n"]],"start1":7828,"start2":7828,"length1":33,"length2":33},{"diffs":[[0," near 0\n    if ("],[1,"(-"],[0,"g.y"],[1,")"],[0," > 10 * zAbs) py"]],"start1":7853,"start2":7853,"length1":35,"length2":38}]}]},{"timestamp":1724838542493,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gx +"],[-1," mkm m j mjm j"],[0,"1000"]],"start1":7098,"start2":7098,"length1":22,"length2":8}]}]},{"timestamp":1724912888545,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," j mjm j"],[-1," "],[0,"1000; gz"]],"start1":7108,"start2":7108,"length1":17,"length2":16}]}]},{"timestamp":1724912891910,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    gx +"],[1," mkm m j mjm j "],[0,"1000; gz"]],"start1":7094,"start2":7094,"length1":16,"length2":31},{"diffs":[[0,"1000; gz near 0\n"],[-1,""],[0,"    if (g.x > 10"]],"start1":7117,"start2":7117,"length1":32,"length2":32},{"diffs":[[0,"    gy just "],[-1,"below"],[1,"above"],[0," 0; gz +1000"]],"start1":7532,"start2":7532,"length1":29,"length2":29},{"diffs":[[0,"0 * "],[-1,"(-"],[0,"g.y)"],[-1,")"],[0," && "]],"start1":7578,"start2":7578,"length1":15,"length2":12},{"diffs":[[0,"&& (g.y "],[-1,"<"],[1,">"],[0," 0)) py "]],"start1":7587,"start2":7587,"length1":17,"length2":17},{"diffs":[[0,"        gy just "],[-1,"above"],[1,"below"],[0," 0; gz +1000\n   "]],"start1":7947,"start2":7947,"length1":37,"length2":37},{"diffs":[[0,"if ((g.z > 10 * "],[1,"(-"],[0,"g.y)"],[1,")"],[0," && (g.y > 0)) p"]],"start1":7985,"start2":7985,"length1":36,"length2":39},{"diffs":[[0,"(-g.y)) && (g.y "],[-1,">"],[1,"<"],[0," 0)) py = 4\n\n\n  "]],"start1":8001,"start2":8001,"length1":33,"length2":33}]}]},{"timestamp":1724913458840,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," button "],[1,"A"],[0," at the "]],"start1":6722,"start2":6722,"length1":16,"length2":17}]}]},{"timestamp":1724914574936,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"with button "],[-1,"B"],[0," at the top;"]],"start1":6718,"start2":6718,"length1":25,"length2":24}]}]},{"timestamp":1724914578620,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"000 with Button "],[-1,"A"],[1,"B"],[0," at the top.  \n "]],"start1":6746,"start2":6746,"length1":33,"length2":33},{"diffs":[[0,"    gx just "],[-1,"below"],[1,"above"],[0," 0; gz +1000"]],"start1":6978,"start2":6978,"length1":29,"length2":29},{"diffs":[[0,"0 * "],[-1,"(-"],[0,"g.x)"],[-1,")"],[0," && "]],"start1":7024,"start2":7024,"length1":15,"length2":12},{"diffs":[[0,"&& (g.x "],[-1,"<"],[1,">"],[0," 0)) px "]],"start1":7033,"start2":7033,"length1":17,"length2":17},{"diffs":[[0,"     gx "],[-1,"-"],[1,"+"],[0,"1000; gz"]],"start1":7093,"start2":7093,"length1":17,"length2":17},{"diffs":[[0,"if ("],[-1,"(-"],[0,"g.x"],[-1,")"],[0," > 1"]],"start1":7122,"start2":7122,"length1":14,"length2":11},{"diffs":[[0,"             gx "],[-1,"+"],[1,"-"],[0,"1000; gz near 0\n"]],"start1":7289,"start2":7289,"length1":33,"length2":33},{"diffs":[[0," near 0\n    if ("],[1,"(-"],[0,"g.x"],[1,")"],[0," > 10 * zAbs) px"]],"start1":7314,"start2":7314,"length1":35,"length2":38},{"diffs":[[0,"        gx just "],[-1,"above"],[1,"below"],[0," 0; gz +1000\n   "]],"start1":7393,"start2":7393,"length1":37,"length2":37},{"diffs":[[0,"if ((g.z > 10 * "],[1,"(-"],[0,"g.x)"],[1,")"],[0," && (g.x > 0)) p"]],"start1":7431,"start2":7431,"length1":36,"length2":39},{"diffs":[[0,"(-g.x)) && (g.x "],[-1,">"],[1,"<"],[0," 0)) px = 4\n\n   "]],"start1":7447,"start2":7447,"length1":33,"length2":33}]}]},{"timestamp":1724914780318,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"py))\n   "],[-1," //"],[0," meter.s"]],"start1":8236,"start2":8236,"length1":19,"length2":16},{"diffs":[[0,"ause(100"],[1,"0"],[0,")\n\n    i"]],"start1":8273,"start2":8273,"length1":16,"length2":17},{"diffs":[[0,"\n       "],[1," //"],[0," led.plo"]],"start1":8336,"start2":8336,"length1":16,"length2":19}]}]},{"timestamp":1724915240069,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"          gx"],[-1,"/gy"],[0," just below "]],"start1":6972,"start2":6972,"length1":27,"length2":24},{"diffs":[[0,"      gx"],[-1,"/gy"],[0," -1000; "]],"start1":7095,"start2":7095,"length1":19,"length2":16},{"diffs":[[0,"      gx"],[-1,"/gy"],[0," near 0;"]],"start1":7194,"start2":7194,"length1":19,"length2":16},{"diffs":[[0,"ton "],[-1,"B"],[1,"A"],[0," at the "],[-1,"bot"],[0,"to"],[-1,"m"],[1,"p"],[0,":   "]],"start1":7274,"start2":7274,"length1":23,"length2":20},{"diffs":[[0,"      gx"],[-1,"/gy"],[0," +1000; "]],"start1":7302,"start2":7302,"length1":19,"length2":16},{"diffs":[[0,"  gx"],[-1,"/gy"],[0," jus"]],"start1":7402,"start2":7402,"length1":11,"length2":8},{"diffs":[[0,"4\n\n\n    "],[-1,"//"],[0,"datalogg"]],"start1":8013,"start2":8013,"length1":18,"length2":16},{"diffs":[[0,"er.log(\n    "],[-1,"//"],[0,"    datalogg"]],"start1":8029,"start2":8029,"length1":26,"length2":24},{"diffs":[[0,".x\", g.x), \n    "],[-1,"//"],[0,"    datalogger.c"]],"start1":8067,"start2":8067,"length1":34,"length2":32},{"diffs":[[0,".y\", g.y), \n    "],[-1,"//"],[0,"    datalogger.c"]],"start1":8109,"start2":8109,"length1":34,"length2":32},{"diffs":[[0,", g.z),\n    "],[-1,"//"],[0,"    datalogg"]],"start1":8154,"start2":8154,"length1":26,"length2":24},{"diffs":[[0,"), \n    "],[-1,"//"],[0,"    data"]],"start1":8198,"start2":8198,"length1":18,"length2":16},{"diffs":[[0,"  pause("],[-1,"2"],[1,"1"],[0,"00)\n\n   "]],"start1":8273,"start2":8273,"length1":17,"length2":17}]}]},{"timestamp":1724915833729,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n()\n"],[-1,"    lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n    let count = 0\n})\n\n\n\n\nbasic.clearScreen()"],[1,"})\n\n\n\n"],[0,"\nlet"]],"start1":5886,"start2":5886,"length1":148,"length2":14},{"diffs":[[0,"left"],[-1,"/Logo down:"],[1,":          "],[0,"    "]],"start1":6960,"start2":6960,"length1":19,"length2":19},{"diffs":[[0," 0)) px = 0\n"],[1,"    // Button B at the top:                 gx/gy -1000; gz near 0\n"],[0,"    if ((g.z"]],"start1":7048,"start2":7048,"length1":24,"length2":91},{"diffs":[[0,"f (("],[1,"-"],[0,"g."],[-1,"z"],[1,"x)"],[0," > 10 * "],[-1,"(-g.y)) && (g.y < 0"],[1,"zAbs) px = 1\n    // face-up:                             gx/gy near 0; gz -1000\n    if ((-g.z) > 10 * Math.abs(g.x"],[0,")) p"],[-1,"y = 0"],[1,"x = 2"],[0,"\n   "]],"start1":7132,"start2":7132,"length1":47,"length2":144},{"diffs":[[0,"n B "],[-1,"or Logo at the top:"],[1,"at the bottom:     "],[0,"    "]],"start1":7285,"start2":7285,"length1":27,"length2":27},{"diffs":[[0,"m:              "],[1,"   "],[0,"gx/gy "],[-1,"-"],[1,"+"],[0,"1000; gz near 0\n"]],"start1":7301,"start2":7301,"length1":39,"length2":42},{"diffs":[[0," near 0\n    if ("],[-1,"(-"],[0,"g.x"],[-1,")"],[0," > 10 * zAbs) px"]],"start1":7335,"start2":7335,"length1":38,"length2":35},{"diffs":[[0," zAbs) px = "],[-1,"1"],[1,"3\n    // face-down from right:                gx/gy just above 0; gz +1000"],[0,"\n    if ((-g"]],"start1":7361,"start2":7361,"length1":25,"length2":98},{"diffs":[[0,"f (("],[-1,"-"],[0,"g."],[-1,"y)"],[1,"z"],[0," > 10 * "],[-1,"zAbs) py = 1"],[1,"g.x) && (g.x > 0)) px = 4\n"],[0,"\n   "]],"start1":7453,"start2":7453,"length1":33,"length2":45},{"diffs":[[0," 4\n\n    // face-"],[-1,"up"],[1,"down from front"],[0,":               "]],"start1":7491,"start2":7491,"length1":34,"length2":47},{"diffs":[[0,"                "],[1,"gy just below 0; gz +1000\n    if ((g.z > 10 * (-g.y)) && (g.y < 0)) py = 0\n    // Logo at the top:       "],[0,"             gx/"]],"start1":7523,"start2":7523,"length1":32,"length2":137},{"diffs":[[0,"        "],[-1,"gx/gy near 0;"],[0," g"],[-1,"z"],[1,"y"],[0," -1000"],[1,"; gz near 0"],[0,"\n    if "]],"start1":7649,"start2":7649,"length1":38,"length2":36},{"diffs":[[0,"r 0\n    if ((-g."],[-1,"z"],[1,"y"],[0,") > 10 * Math.ab"]],"start1":7674,"start2":7674,"length1":33,"length2":33},{"diffs":[[0," > 10 * "],[-1,"Math.abs(g.x)) px = 2"],[1,"zAbs) py = 1\n    // face-up:                             gy near 0; gz -1000"],[0,"\n    if "]],"start1":7692,"start2":7692,"length1":37,"length2":92},{"diffs":[[0,"  //"],[-1," Button B or"],[0," Log"]],"start1":7823,"start2":7823,"length1":20,"length2":8},{"diffs":[[0,"ottom:      "],[-1,"gx/"],[1,"            "],[0,"gy +1000; gz"]],"start1":7841,"start2":7841,"length1":27,"length2":36},{"diffs":[[0,"r 0\n"],[-1,"    if (g.x > 10 * zAbs) px = 3\n"],[0,"    "]],"start1":7881,"start2":7881,"length1":40,"length2":8},{"diffs":[[0,"rom "],[-1,"right/Logo up:"],[1,"back:         "],[0,"        "],[-1,"gx/"],[0,"gy j"]],"start1":7935,"start2":7935,"length1":33,"length2":30},{"diffs":[[0,"* g."],[-1,"x"],[1,"y"],[0,") && (g."],[-1,"x"],[1,"y"],[0," > 0)) p"],[-1,"x"],[1,"y"],[0," = 4\n"],[1,"\n\n"],[0,"    "],[-1,"if ((g.z > 10 * g.y) && (g.y > 0)) py = 4"],[1,"//datalogger.log(\n    //    datalogger.createCV(\"g.x\", g.x), \n    //    datalogger.createCV(\"g.y\", g.y), \n    //    datalogger.createCV(\"g.z\", g.z),\n    //    datalogger.createCV(\"px\", px), \n    //    datalogger.createCV(\"py\", py))\n    // meter.show(px*10 + py)"],[0,"\n   "]],"start1":8005,"start2":8005,"length1":77,"length2":299},{"diffs":[[0,"   /"],[-1,"/ difficul"],[1,"* not much poin"],[0,"t ra"]],"start1":8635,"start2":8635,"length1":18,"length2":23},{"diffs":[[0," gxLo = "],[-1,"g.x"],[1,"Math.max(g.x, 0)"],[0,"\n       "]],"start1":8728,"start2":8728,"length1":19,"length2":32},{"diffs":[[0," gyLo = "],[-1,"g.y"],[1,"Math.max(g.y, 0)"],[0,"\n       "]],"start1":8776,"start2":8776,"length1":19,"length2":32},{"diffs":[[0," gzLo = "],[-1,"g.z"],[1,"Math.max(g.z, 0)"],[0,"\n       "]],"start1":8824,"start2":8824,"length1":19,"length2":32},{"diffs":[[0," gxHi = "],[-1,"g.x"],[1,"Math.min(g.x, 1000)"],[0,"\n       "]],"start1":8872,"start2":8872,"length1":19,"length2":35},{"diffs":[[0," gyHi = "],[-1,"g.y"],[1,"Math.min(g.y, 1000)"],[0,"\n       "]],"start1":8923,"start2":8923,"length1":19,"length2":35},{"diffs":[[0," gzHi = "],[-1,"g.z"],[1,"Math.min(g.z, 1000)\n        */"],[0,"\n    }\n}"]],"start1":8974,"start2":8974,"length1":19,"length2":46}]}]},{"timestamp":1724916282222,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ew Vector(0,"],[-1," "],[0,"0,"],[-1," "],[0,"0)\nlet g = n"]],"start1":6361,"start2":6361,"length1":28,"length2":26},{"diffs":[[0,"   let f"],[-1,"New"],[0," = new V"]],"start1":9778,"start2":9778,"length1":19,"length2":16},{"diffs":[[0,"tor("],[-1,"0, 0, 0)\n    fNew.x = "],[0,"inpu"]],"start1":9796,"start2":9796,"length1":30,"length2":8},{"diffs":[[0,"e(0)"],[-1,"\n    fNew.y ="],[1,","],[0," inp"]],"start1":9818,"start2":9818,"length1":21,"length2":9},{"diffs":[[0,"e(1)"],[-1,"\n    fNew.z ="],[1,","],[0," inp"]],"start1":9842,"start2":9842,"length1":21,"length2":9},{"diffs":[[0,"Force(2)"],[1,")"],[0,"\n    f"],[-1,"New"],[0,".x *= fx"]],"start1":9862,"start2":9862,"length1":25,"length2":23},{"diffs":[[0,"le\n    f"],[-1,"New"],[0,".y *= fy"]],"start1":9888,"start2":9888,"length1":19,"length2":16},{"diffs":[[0,"le\n    f"],[-1,"New"],[0,".z *= fz"]],"start1":9907,"start2":9907,"length1":19,"length2":16},{"diffs":[[0,"return f"],[-1,"New"],[0,"\n}\n\nfunc"]],"start1":9933,"start2":9933,"length1":19,"length2":16},{"diffs":[[0,"   let g"],[-1,"New"],[0," = new V"]],"start1":9984,"start2":9984,"length1":19,"length2":16},{"diffs":[[0,"tor("],[-1,"0, 0, 0)\n    gNew.x = "],[0,"inpu"]],"start1":10002,"start2":10002,"length1":30,"length2":8},{"diffs":[[0,"n(0)"],[-1,"\n    gNew.y ="],[1,","],[0," inp"]],"start1":10023,"start2":10023,"length1":21,"length2":9},{"diffs":[[0,"n(1)"],[-1,"\n    gNew.z ="],[1,","],[0," inp"]],"start1":10046,"start2":10046,"length1":21,"length2":9},{"diffs":[[0,"ation(2)"],[1,")"],[0,"\n    "],[-1,"gNew"],[1,"// g"],[0,".x *= gx"]],"start1":10065,"start2":10065,"length1":25,"length2":26},{"diffs":[[0,"ale\n    "],[-1,"gNew"],[1,"// g"],[0,".y *= gy"]],"start1":10093,"start2":10093,"length1":20,"length2":20},{"diffs":[[0,"ale\n    "],[-1,"gNew"],[1,"// g"],[0,".z *= gz"]],"start1":10115,"start2":10115,"length1":20,"length2":20},{"diffs":[[0,"rn g"],[-1,"New"],[0,"\n}\n"]],"start1":10149,"start2":10149,"length1":10,"length2":7}]}]},{"timestamp":1724916886053,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"Force(0)"],[-1," - "],[0,"\n    fNe"]],"start1":9841,"start2":9841,"length1":19,"length2":16}]}]},{"timestamp":1724916887176,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   fNew.x = "],[-1,"("],[0,"input.magnet"]],"start1":9815,"start2":9815,"length1":25,"length2":24},{"diffs":[[0,") - "],[-1,"fxOff) * gxScale"],[0,"\n   "]],"start1":9848,"start2":9848,"length1":24,"length2":8},{"diffs":[[0,"   fNew.y = "],[-1,"("],[0,"input.magnet"]],"start1":9854,"start2":9854,"length1":25,"length2":24},{"diffs":[[0,"e(1)"],[-1," - fyOff) * gyScale"],[0,"\n   "]],"start1":9884,"start2":9884,"length1":27,"length2":8},{"diffs":[[0,"   fNew.z = "],[-1,"("],[0,"input.magnet"]],"start1":9890,"start2":9890,"length1":25,"length2":24},{"diffs":[[0,"e(2)"],[-1," - fzOff) * g"],[1,"\n    fNew.x *= fxScale\n    fNew.y *= fyScale\n    fNew.z *= f"],[0,"zSca"]],"start1":9920,"start2":9920,"length1":21,"length2":68},{"diffs":[[0,"New.x = "],[-1,"("],[0,"input.ac"]],"start1":10088,"start2":10088,"length1":17,"length2":16},{"diffs":[[0,"n(0)"],[-1," - gxOff) * gxScale"],[0,"\n   "]],"start1":10113,"start2":10113,"length1":27,"length2":8},{"diffs":[[0,"New.y = "],[-1,"("],[0,"input.ac"]],"start1":10123,"start2":10123,"length1":17,"length2":16},{"diffs":[[0,"n(1)"],[-1," - gyOff) * gyScale"],[0,"\n   "]],"start1":10148,"start2":10148,"length1":27,"length2":8},{"diffs":[[0,"New.z = "],[-1,"("],[0,"input.ac"]],"start1":10158,"start2":10158,"length1":17,"length2":16},{"diffs":[[0,"n(2)"],[-1," - gzOff)"],[1,"\n    gNew.x *= gxScale\n    gNew.y *= gyScale\n    gNew.z"],[0," *"],[1,"="],[0," gzS"]],"start1":10183,"start2":10183,"length1":19,"length2":66}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".0.2"],[-1,"6"],[1,"5"],[0,"\",\n "]],"start1":405,"start2":405,"length1":9,"length2":9}]}]},{"timestamp":1724917058909,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lit = [[0, 0, 0,"],[1," 0,"],[0," 0], [0, 0, 0, 0"]],"start1":5894,"start2":5894,"length1":32,"length2":35}]}]},{"timestamp":1724931607330,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lit = [["],[-1,"1"],[1,"0"],[0,", 0, 0, "]],"start1":5894,"start2":5894,"length1":17,"length2":17}]}]},{"timestamp":1724931609244,"editorVersion":"7.0.26","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ty()"],[-1," \n    datalogger.log(\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n"],[0,"\n   "]],"start1":4739,"start2":4739,"length1":309,"length2":8},{"diffs":[[0," lit = [[1, "],[-1,"1"],[1,"0"],[0,", 0, "],[-1,"1, 1"],[1,"0"],[0,"], ["],[-1,"1"],[1,"0"],[0,", 0, 0, 0, 1"]],"start1":5893,"start2":5893,"length1":39,"length2":36},{"diffs":[[0,"], [0, 0, 0, 0, "],[-1,"1"],[1,"0"],[0,"], [0, 0, 0, 0, "]],"start1":5912,"start2":5912,"length1":33,"length2":33},{"diffs":[[0,", 0, 0, 0, 0], ["],[-1,"1"],[1,"0"],[0,", 0, 0, 0, 1], ["]],"start1":5934,"start2":5934,"length1":33,"length2":33},{"diffs":[[0,", 0, 0, "],[-1,"1"],[1,"0"],[0,"], ["],[-1,"1, 1"],[1,"0, 0"],[0,", 0, "],[-1,"1, 1"],[1,"0, 0"],[0,"]]\n    l"]],"start1":5954,"start2":5954,"length1":34,"length2":34},{"diffs":[[0,"n()\n"],[-1,"// only need to visit the central diamond pixels\n"],[0,"let "]],"start1":6024,"start2":6024,"length1":57,"length2":8},{"diffs":[[0,"= [["],[-1,"1, 1"],[1,"0, 0"],[0,", 0, "],[-1,"1, 1"],[1,"0, 0"],[0,"], ["],[-1,"1"],[1,"0"],[0,", 0,"]],"start1":6036,"start2":6036,"length1":26,"length2":26},{"diffs":[[0,"0, 0, 0, 0, "],[-1,"1"],[1,"0"],[0,"], [0, 0, 0,"]],"start1":6057,"start2":6057,"length1":25,"length2":25},{"diffs":[[0,"0, 0], ["],[-1,"1"],[1,"0"],[0,", 0, 0, "]],"start1":6083,"start2":6083,"length1":17,"length2":17},{"diffs":[[0," 0, "],[-1,"1"],[1,"0"],[0,"], ["],[-1,"1, 1"],[1,"0, 0, 0"],[0,", 0, "],[-1,"1, 1"],[1,"0"],[0,"]]\nl"]],"start1":6099,"start2":6099,"length1":26,"length2":26},{"diffs":[[0,"t < "],[-1,"13"],[1,"25"],[0,") {\n"]],"start1":6455,"start2":6455,"length1":10,"length2":10}]}]},{"timestamp":1724932499721,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n})\n"],[-1,"function cali"],[0,"\n\n\n\n"]],"start1":6304,"start2":6304,"length1":21,"length2":8}]}]},{"timestamp":1724942510006,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ion cali"],[-1,"b"],[0,"\n\n\n\nbasi"]],"start1":6313,"start2":6313,"length1":17,"length2":16}]}]},{"timestamp":1724942510138,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n})\n"],[-1,"\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    "],[1,"function calib\n\n\n\nbasic.clearScreen()\n"],[0,"// o"]],"start1":6304,"start2":6304,"length1":89,"length2":46},{"diffs":[[0," pixels\n"],[-1,"    "],[0,"let lit "]],"start1":6387,"start2":6387,"length1":20,"length2":16},{"diffs":[[0,"1, 1, 0, 1, 1]]\n"],[-1,"    "],[0,"let count = 0\n  "]],"start1":6475,"start2":6475,"length1":36,"length2":32},{"diffs":[[0,"t count = 0\n"],[-1,"    "],[0,"let fxLo = 9"]],"start1":6493,"start2":6493,"length1":28,"length2":24},{"diffs":[[0,"xLo = 99999\n"],[-1,"    "],[0,"let fyLo = 9"]],"start1":6510,"start2":6510,"length1":28,"length2":24},{"diffs":[[0,"yLo = 99999\n"],[-1,"    "],[0,"let fzLo = 9"]],"start1":6527,"start2":6527,"length1":28,"length2":24},{"diffs":[[0,"zLo = 99999\n"],[-1,"    "],[0,"let fxHi = -"]],"start1":6544,"start2":6544,"length1":28,"length2":24},{"diffs":[[0,"Hi = -99999\n"],[-1,"    "],[0,"let fyHi = -"]],"start1":6562,"start2":6562,"length1":28,"length2":24},{"diffs":[[0,"Hi = -99999\n"],[-1,"    "],[0,"let fzHi = -"]],"start1":6580,"start2":6580,"length1":28,"length2":24},{"diffs":[[0,"-99999\n\n"],[-1,"    "],[0,"let gxLo"]],"start1":6603,"start2":6603,"length1":20,"length2":16},{"diffs":[[0,"xLo = 99999\n"],[-1,"    "],[0,"let gyLo = 9"]],"start1":6616,"start2":6616,"length1":28,"length2":24},{"diffs":[[0,"yLo = 99999\n"],[-1,"    "],[0,"let gzLo = 9"]],"start1":6633,"start2":6633,"length1":28,"length2":24},{"diffs":[[0,"zLo = 99999\n"],[-1,"    "],[0,"let gxHi = -"]],"start1":6650,"start2":6650,"length1":28,"length2":24},{"diffs":[[0,"Hi = -99999\n"],[-1,"    "],[0,"let gyHi = -"]],"start1":6668,"start2":6668,"length1":28,"length2":24},{"diffs":[[0,"Hi = -99999\n"],[-1,"    "],[0,"let gzHi = -"]],"start1":6686,"start2":6686,"length1":28,"length2":24},{"diffs":[[0," -99999\n"],[-1,"    "],[0,"let f = "]],"start1":6708,"start2":6708,"length1":20,"length2":16},{"diffs":[[0,"or(0, 0, 0)\n"],[-1,"    "],[0,"let g = new "]],"start1":6732,"start2":6732,"length1":28,"length2":24},{"diffs":[[0,", 0, 0)\n"],[-1,"    "],[0,"let zAbs"]],"start1":6764,"start2":6764,"length1":20,"length2":16},{"diffs":[[0," number\n"],[-1,"    "],[0,"let px ="]],"start1":6781,"start2":6781,"length1":20,"length2":16},{"diffs":[[0," px = 0\n"],[-1,"    "],[0,"let py ="]],"start1":6792,"start2":6792,"length1":20,"length2":16},{"diffs":[[0," py = 0\n"],[-1,"    "],[0,"while (c"]],"start1":6803,"start2":6803,"length1":20,"length2":16},{"diffs":[[0,"unt < 13) {\n"],[-1,"    "],[0,"    f.x = in"]],"start1":6820,"start2":6820,"length1":28,"length2":24},{"diffs":[[0,"ticForce(0)\n"],[-1,"    "],[0,"    f.y = in"]],"start1":6853,"start2":6853,"length1":28,"length2":24},{"diffs":[[0,"ticForce(1)\n"],[-1,"    "],[0,"    f.z = in"]],"start1":6886,"start2":6886,"length1":28,"length2":24},{"diffs":[[0,"(2)\n    "],[-1," "],[-1,"   "],[0,"g.x = in"]],"start1":6927,"start2":6927,"length1":20,"length2":16},{"diffs":[[0,"(0)\n    "],[-1," "],[-1,"   "],[0,"g.y = in"]],"start1":6959,"start2":6959,"length1":20,"length2":16},{"diffs":[[0,"(1)\n    "],[-1," "],[-1,"   "],[0,"g.z = in"]],"start1":6991,"start2":6991,"length1":20,"length2":16},{"diffs":[[0,"(2)\n    "],[-1," "],[-1,"   "],[0,"zAbs = M"]],"start1":7023,"start2":7023,"length1":20,"length2":16},{"diffs":[[0,"s(g.z)\n\n"],[-1,"    "],[0,"    // s"]],"start1":7045,"start2":7045,"length1":20,"length2":16},{"diffs":[[0,"es.\n    "],[-1," "],[-1,"   "],[0,"// REMEM"]],"start1":7105,"start2":7105,"length1":20,"length2":16},{"diffs":[[0,"versed:\n"],[-1,"    "],[0,"    // X"]],"start1":7192,"start2":7192,"length1":20,"length2":16},{"diffs":[[0,".  \n    "],[-1," "],[-1,"   "],[0,"// Y is "]],"start1":7274,"start2":7274,"length1":20,"length2":16},{"diffs":[[0,"bottom.\n"],[-1,"    "],[0,"    // Z"]],"start1":7362,"start2":7362,"length1":20,"length2":16},{"diffs":[[0,"down.\n\n\n    "],[-1,"  "],[-1,"  "],[0,"// face-down"]],"start1":7430,"start2":7430,"length1":28,"length2":24},{"diffs":[[0,"low 0; gz +1000\n"],[-1,"    "],[0,"    if ((g.z > 1"]],"start1":7495,"start2":7495,"length1":36,"length2":32},{"diffs":[[0," px = 0\n    "],[-1,"  "],[-1,"  "],[0,"if ((g.z > 1"]],"start1":7552,"start2":7552,"length1":28,"length2":24},{"diffs":[[0," py = 0\n"],[-1,"    "],[0,"    // B"]],"start1":7601,"start2":7601,"length1":20,"length2":16},{"diffs":[[0," near 0\n    "],[-1,"   "],[-1," "],[0,"if ((-g.x) >"]],"start1":7668,"start2":7668,"length1":28,"length2":24},{"diffs":[[0," px = 1\n    "],[-1,"   "],[-1," "],[0,"if ((-g.y) >"]],"start1":7703,"start2":7703,"length1":28,"length2":24},{"diffs":[[0," py = 1\n    "],[-1,"   "],[-1," "],[0,"// face-up: "]],"start1":7738,"start2":7738,"length1":28,"length2":24},{"diffs":[[0,"0; gz -1000\n"],[-1,"    "],[0,"    if ((-g."]],"start1":7801,"start2":7801,"length1":28,"length2":24},{"diffs":[[0,".x)) px = 2\n"],[-1,"    "],[0,"    if ((-g."]],"start1":7845,"start2":7845,"length1":28,"length2":24},{"diffs":[[0," py = 2\n"],[-1,"    "],[0,"    // B"]],"start1":7893,"start2":7893,"length1":20,"length2":16},{"diffs":[[0," near 0\n"],[-1,"    "],[0,"    if ("]],"start1":7960,"start2":7960,"length1":20,"length2":16},{"diffs":[[0,"Abs) px = 3\n"],[-1,"    "],[0,"    if (g.y "]],"start1":7988,"start2":7988,"length1":28,"length2":24},{"diffs":[[0," py = 3\n"],[-1,"    "],[0,"    // f"]],"start1":8024,"start2":8024,"length1":20,"length2":16},{"diffs":[[0,"z +1000\n"],[-1,"    "],[0,"    if ("]],"start1":8097,"start2":8097,"length1":20,"length2":16},{"diffs":[[0," 0)) px = 4\n"],[-1,"    "],[0,"    if ((g.z"]],"start1":8139,"start2":8139,"length1":28,"length2":24},{"diffs":[[0," py = 4\n"],[-1,"    "],[0,"    paus"]],"start1":8189,"start2":8189,"length1":20,"length2":16},{"diffs":[[0,"e(200)\n\n"],[-1,"    "],[0,"    if ("]],"start1":8205,"start2":8205,"length1":20,"length2":16},{"diffs":[[0,"        "],[-1," "],[-1,"   "],[0,"lit[px]["]],"start1":8241,"start2":8241,"length1":20,"length2":16},{"diffs":[[0,"py] = 1\n"],[-1,"    "],[0,"        "]],"start1":8257,"start2":8257,"length1":20,"length2":16},{"diffs":[[0,"x, py)\n\n"],[-1,"\n"],[0,"        "],[1,"\n    "],[0,"    coun"]],"start1":8283,"start2":8283,"length1":25,"length2":29},{"diffs":[[0,"count++\n"],[-1,"    "],[0,"        "]],"start1":8308,"start2":8308,"length1":20,"length2":16},{"diffs":[[0,"o = f.x\n        "],[-1,"    "],[0,"if (f.y < fyLo) "]],"start1":8343,"start2":8343,"length1":36,"length2":32},{"diffs":[[0," fyLo = f.y\n"],[-1,"    "],[0,"        if ("]],"start1":8374,"start2":8374,"length1":28,"length2":24},{"diffs":[[0,"f.z\n        "],[-1,"    "],[0,"if (f.x > fx"]],"start1":8417,"start2":8417,"length1":28,"length2":24},{"diffs":[[0,"f.x\n        "],[-1," "],[-1,"   "],[0,"if (f.y > fy"]],"start1":8452,"start2":8452,"length1":28,"length2":24},{"diffs":[[0,"f.y\n        "],[-1," "],[-1,"   "],[0,"if (f.z > fz"]],"start1":8487,"start2":8487,"length1":28,"length2":24},{"diffs":[[0," fzHi = f.z\n"],[-1,"    "],[0,"        // d"]],"start1":8514,"start2":8514,"length1":28,"length2":24},{"diffs":[[0,"vement!\n        "],[-1," "],[-1,"   "],[0,"if (g.x < gxLo) "]],"start1":8588,"start2":8588,"length1":36,"length2":32},{"diffs":[[0,"o = g.x\n        "],[-1,"  "],[-1,"  "],[0,"if (g.y < gyLo) "]],"start1":8623,"start2":8623,"length1":36,"length2":32},{"diffs":[[0,"o = g.y\n        "],[-1,"  "],[-1,"  "],[0,"if (g.z < gzLo) "]],"start1":8658,"start2":8658,"length1":36,"length2":32},{"diffs":[[0," gzLo = g.z\n"],[-1,"    "],[0,"        if ("]],"start1":8689,"start2":8689,"length1":28,"length2":24},{"diffs":[[0,"g.x\n        "],[-1,"  "],[-1,"  "],[0,"if (g.y > gy"]],"start1":8732,"start2":8732,"length1":28,"length2":24},{"diffs":[[0,"g.y\n        "],[-1,"   "],[-1," "],[0,"if (g.z > gz"]],"start1":8767,"start2":8767,"length1":28,"length2":24},{"diffs":[[0,"g.z\n    "],[-1,"   "],[-1," "],[0,"}\n"],[-1,"    }\n    "],[1,"}\n"],[0,"basic.sh"]],"start1":8802,"start2":8802,"length1":32,"length2":20},{"diffs":[[0,"Happy)\n\n"],[-1,"    "],[0,"let fxOf"]],"start1":8839,"start2":8839,"length1":20,"length2":16},{"diffs":[[0,"+ fxLo) / 2\n"],[-1,"    "],[0,"let fyOff = "]],"start1":8865,"start2":8865,"length1":28,"length2":24},{"diffs":[[0,"+ fyLo) / 2\n"],[-1,"    "],[0,"let fzOff = "]],"start1":8895,"start2":8895,"length1":28,"length2":24},{"diffs":[[0,"+ fzLo) / 2\n"],[-1,"    "],[0,"let fxMag = "]],"start1":8925,"start2":8925,"length1":28,"length2":24},{"diffs":[[0,"- fxLo) / 2\n"],[-1,"    "],[0,"let fyMag = "]],"start1":8955,"start2":8955,"length1":28,"length2":24},{"diffs":[[0,"- fyLo) / 2\n"],[-1,"    "],[0,"let fzMag = "]],"start1":8985,"start2":8985,"length1":28,"length2":24},{"diffs":[[0," fzLo) / 2\n\n"],[-1,"    "],[0,"let fxScale "]],"start1":9016,"start2":9016,"length1":28,"length2":24},{"diffs":[[0,"000 / fxMag\n"],[-1,"    "],[0,"let fyScale "]],"start1":9043,"start2":9043,"length1":28,"length2":24},{"diffs":[[0,"000 / fyMag\n"],[-1,"    "],[0,"let fzScale "]],"start1":9070,"start2":9070,"length1":28,"length2":24},{"diffs":[[0," fzMag\n\n"],[-1,"    "],[0,"let gxOf"]],"start1":9102,"start2":9102,"length1":20,"length2":16},{"diffs":[[0,"+ gxLo) / 2\n"],[-1,"    "],[0,"let gyOff = "]],"start1":9128,"start2":9128,"length1":28,"length2":24},{"diffs":[[0,"+ gyLo) / 2\n"],[-1,"    "],[0,"let gzOff = "]],"start1":9158,"start2":9158,"length1":28,"length2":24},{"diffs":[[0,"+ gzLo) / 2\n"],[-1,"    "],[0,"let gxMag = "]],"start1":9188,"start2":9188,"length1":28,"length2":24},{"diffs":[[0,"- gxLo) / 2\n"],[-1,"    "],[0,"let gyMag = "]],"start1":9218,"start2":9218,"length1":28,"length2":24},{"diffs":[[0,"Lo) / 2\n"],[-1,"    "],[0,"let gzMa"]],"start1":9252,"start2":9252,"length1":20,"length2":16},{"diffs":[[0,"o) / 2\n\n"],[-1,"    "],[0,"let gxSc"]],"start1":9283,"start2":9283,"length1":20,"length2":16},{"diffs":[[0,"000 / gxMag\n"],[-1,"    "],[0,"let gyScale "]],"start1":9306,"start2":9306,"length1":28,"length2":24},{"diffs":[[0,"/ gyMag\n"],[-1,"    "],[0,"let gzSc"]],"start1":9337,"start2":9337,"length1":20,"length2":16},{"diffs":[[0,"ag\n\n"],[-1,"}\n\n// set scaling and offsets\nif (simulating) {\n    fakeCali\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\n"],[0,"data"]],"start1":9369,"start2":9369,"length1":119,"length2":8}]}]},{"timestamp":1724942699042,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"fakeCali"],[-1,"i"],[0,"\n} else "]],"start1":9804,"start2":9804,"length1":17,"length2":16}]}]},{"timestamp":1724948585592,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"akeCalii"],[-1,"brate"],[0,"\n} else "]],"start1":9805,"start2":9805,"length1":21,"length2":16}]}]},{"timestamp":1724948587024,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"\nlet simulating = true\n\n"],[0,"/* 3"]],"start1":0,"start2":0,"length1":28,"length2":4},{"diffs":[[0,"t. \n"],[-1,"*/\n"],[0,"   "],[1,"*/\n"],[0,"clas"]],"start1":75,"start2":75,"length1":14,"length2":14},{"diffs":[[0,"    }\n    }\n"],[-1,"\n"],[0,"    dottedWi"]],"start1":475,"start2":475,"length1":25,"length2":24},{"diffs":[[0,"y, z)\n    }\n"],[-1,"\n"],[0,"    // we ar"]],"start1":788,"start2":788,"length1":25,"length2":24},{"diffs":[[0,"s.z))\n    }\n"],[-1,"\n"],[0,"    getMagni"]],"start1":974,"start2":974,"length1":25,"length2":24},{"diffs":[[0,"he World"],[-1,"-"],[1," - "],[0,"Frame in"]],"start1":1292,"start2":1292,"length1":17,"length2":19},{"diffs":[[0,"vigating"],[-1," "],[0,"(East, N"]],"start1":1326,"start2":1326,"length1":17,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"\nfakeCalibrate() {\n}\n\n"],[0,"// s"]],"start1":9751,"start2":9751,"length1":30,"length2":8},{"diffs":[[0,"   f"],[-1,"xOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86"],[1,"akeCaliibrate"],[0,"\n} e"]],"start1":9801,"start2":9801,"length1":229,"length2":21},{"diffs":[[0," 0)\n"],[-1,"    if (simulating) {\n        fNew.x = 8.16\n        fNew.y = 7.91\n        fNew.z = 32.72\n    } else {\n    "],[0,"    "]],"start1":10670,"start2":10670,"length1":114,"length2":8},{"diffs":[[0,"gxScale\n    "],[-1,"  "],[-1,"  "],[0,"fNew.y = (in"]],"start1":10722,"start2":10722,"length1":28,"length2":24},{"diffs":[[0,") * gyScale\n"],[-1,"    "],[0,"    fNew.z ="]],"start1":10774,"start2":10774,"length1":28,"length2":24},{"diffs":[[0,"zOff) * gzScale\n"],[-1,"    }\n"],[0,"    return fNew\n"]],"start1":10826,"start2":10826,"length1":38,"length2":32},{"diffs":[[0," 0)\n"],[-1,"    if (simulating) {\n        gNew.x = -23.53\n        gNew.y = 30.43\n        gNew.z = -762.48\n    } else {\n    "],[0,"    "]],"start1":10930,"start2":10930,"length1":119,"length2":8},{"diffs":[[0,") * gxScale\n"],[-1,"    "],[0,"    gNew.y ="]],"start1":10977,"start2":10977,"length1":28,"length2":24},{"diffs":[[0,"ale\n    "],[-1,"   "],[-1," "],[0,"gNew.z ="]],"start1":11040,"start2":11040,"length1":20,"length2":16},{"diffs":[[0,"gzScale\n"],[-1,"    }\n"],[0,"    retu"]],"start1":11091,"start2":11091,"length1":22,"length2":16}]}]},{"timestamp":1724949184684,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n}\n/**\n"],[1," "],[0,"* A Quat"]],"start1":1096,"start2":1096,"length1":16,"length2":17},{"diffs":[[0,"using:\n*"],[-1,"\n*      "],[0," XYZ: th"]],"start1":1218,"start2":1218,"length1":24,"length2":16},{"diffs":[[0,"microbit"],[1,"'s"],[0," Sensor-"]],"start1":1236,"start2":1236,"length1":16,"length2":18},{"diffs":[[0,"-Frame\n*"],[-1,"\n*      "],[0," RFD: th"]],"start1":1253,"start2":1253,"length1":24,"length2":16},{"diffs":[[0,"he buggy"],[1,"'s"],[0," Body-Fr"]],"start1":1268,"start2":1268,"length1":16,"length2":18},{"diffs":[[0,"n)\n*"],[-1,"\n*      "],[0," ENG"]],"start1":1308,"start2":1308,"length1":16,"length2":8},{"diffs":[[0,"esult.x "],[-1,"\n            "],[0,"= v.x * "]],"start1":3411,"start2":3411,"length1":29,"length2":16},{"diffs":[[0,"s.jj - this.kk)\n"],[1,""],[0,"            + v."]],"start1":3451,"start2":3451,"length1":32,"length2":32},{"diffs":[[0,"esult.y "],[-1,"\n            "],[0,"= v.y * "]],"start1":3561,"start2":3561,"length1":29,"length2":16},{"diffs":[[0,"esult.z "],[-1,"\n            "],[0,"= v.z * "]],"start1":3711,"start2":3711,"length1":29,"length2":16},{"diffs":[[0,"qrt("],[1,"("],[0,"this.w"],[-1,"w"],[1," * this.w)\n           "],[0," + "],[1,"("],[0,"this.i"],[-1,"i"],[1," * this.i)\n           "],[0," + "],[1,"("],[0,"this.j"],[-1,"j"],[1," * this.j)\n           "],[0," + "],[1,"("],[0,"this.k"],[-1,"k"],[1," * this.k)"],[0,")\n  "]],"start1":3998,"start2":3998,"length1":45,"length2":121},{"diffs":[[0,".i * this.k * 2\n"],[-1,""],[0,"        this.jk2"]],"start1":4596,"start2":4596,"length1":32,"length2":32},{"diffs":[[0," this.k * 2\n"],[1,"\n"],[0,"    }\n}\ninpu"]],"start1":4639,"start2":4639,"length1":24,"length2":25},{"diffs":[[0,"i = f.z\n"],[-1,"\n"],[0,"        "]],"start1":8811,"start2":8811,"length1":17,"length2":16},{"diffs":[[0,"     // "],[1,"difficult"],[0," ranging"]],"start1":8826,"start2":8826,"length1":16,"length2":25}]}]},{"timestamp":1724949783859,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"true"],[-1,"\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number"],[0,"\n\n/*"]],"start1":18,"start2":18,"length1":472,"length2":8},{"diffs":[[0,"px, py)\n"],[1,"\n\n"],[0,"        "]],"start1":8536,"start2":8536,"length1":16,"length2":18},{"diffs":[[0,"t++\n"],[-1,"            // find range of field\n"],[0,"    "]],"start1":8562,"start2":8562,"length1":43,"length2":8},{"diffs":[[0,"      //"],[1," "],[0," ranging"]],"start1":8807,"start2":8807,"length1":16,"length2":17},{"diffs":[[0,"vity"],[1,":"],[0," "],[-1,"is inaccurate ("],[0,"dist"]],"start1":8828,"start2":8828,"length1":24,"length2":10},{"diffs":[[0,"ovement!"],[-1,")"],[0,"\n       "]],"start1":8857,"start2":8857,"length1":17,"length2":16},{"diffs":[[0,"xOff) * "],[-1,"f"],[1,"g"],[0,"xScale\n "]],"start1":11049,"start2":11049,"length1":17,"length2":17},{"diffs":[[0,"yOff) * "],[-1,"f"],[1,"g"],[0,"yScale\n "]],"start1":11109,"start2":11109,"length1":17,"length2":17},{"diffs":[[0,"zOff) * "],[-1,"f"],[1,"g"],[0,"zScale\n "]],"start1":11169,"start2":11169,"length1":17,"length2":17}]}]},{"timestamp":1724950375612,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"\n"],[0,"let simulati"]],"start1":0,"start2":0,"length1":12,"length2":13},{"diffs":[[0,"true"],[-1," // for debugging\n\n"],[0,"\n// "]],"start1":18,"start2":18,"length1":27,"length2":8},{"diffs":[[0,"mber"],[-1,"\n// calibration map\nlet lit: number[][]"],[0,"\n\n/*"]],"start1":482,"start2":482,"length1":47,"length2":8},{"diffs":[[0,"\n    }\n}"],[-1,"\n\n// set "],[0,"\ninput.o"]],"start1":5096,"start2":5096,"length1":25,"length2":16},{"diffs":[[0," pixels\n    "],[1,"let "],[0,"lit = [[1, 1"]],"start1":6901,"start2":6901,"length1":24,"length2":28},{"diffs":[[0,"py)\n"],[-1,"    // field offsets"],[0,"\n   "]],"start1":9659,"start2":9659,"length1":28,"length2":8},{"diffs":[[0,"/ 2\n"],[-1,"    // field magnitudes\n"],[0,"    "]],"start1":9762,"start2":9762,"length1":32,"length2":8},{"diffs":[[0,"/ 2\n"],[-1,"    // field scaling factors (nominal strength of 1000)"],[0,"\n   "]],"start1":9864,"start2":9864,"length1":63,"length2":8},{"diffs":[[0,"Mag\n"],[-1,"    // gravity offsets"],[0,"\n   "]],"start1":9958,"start2":9958,"length1":30,"length2":8},{"diffs":[[0,"/ 2\n"],[-1,"    // gravity magnitudes\n"],[0,"    "]],"start1":10061,"start2":10061,"length1":34,"length2":8},{"diffs":[[0,"/ 2\n"],[-1,"    // gravity scaling factors (in milli-gravities)"],[0,"\n   "]],"start1":10163,"start2":10163,"length1":59,"length2":8},{"diffs":[[0,"\n\n\nf"],[-1,"unction correctedField(): Vector {\n    let fNew = new Vector(0, 0, 0)\n    if (simulating) {\n        fNew.x = 8.16\n        fNew.y = 7.91\n        fNew.z = 32.72\n    } else {\n        fNew.x = (input.magneticForce(0) - fxOff) * fxScale\n        fNew.y = (input.magneticForce(1) - fyOff) * fyScale\n        fNew.z = (input.magneticForc"],[1,"akeCalibrat"],[0,"e("],[-1,"2"],[0,") "],[-1,"- fzOff) * fzScale\n    }\n    return fNew\n}\n\nfunction correctedGravity(): Vector {\n    let gNew = new Vector(0, 0, 0)\n    if (simulating) {\n        gNew.x = -23.53\n        gNew.y = 30.43\n        gNew.z = -762.48\n    } else {\n        gNew.x = (input.acceleration(0) - gxOff) * gxScale\n        gNew.y = (input.acceleration(1) - gyOff) * gyScale\n        gNew.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return gNew\n}\n\n\n// ================================"],[1,"{\n}"],[0,"\n\n//"]],"start1":10263,"start2":10263,"length1":803,"length2":26},{"diffs":[[0,"g) {"],[-1," // taken from Bit:Commander"],[0,"\n   "]],"start1":10327,"start2":10327,"length1":36,"length2":8},{"diffs":[[0,"ion\n"],[-1,"// await button-pressing..."],[1,"\nfunction correctedField(): Vector {\n    let fNew = new Vector(0, 0, 0)\n    if (simulating) {\n        fNew.x = 8.16\n        fNew.y = 7.91\n        fNew.z = 32.72\n    } else {\n        fNew.x = (input.magneticForce(0) - fxOff) * fxScale\n        fNew.y = (input.magneticForce(1) - fyOff) * fyScale\n        fNew.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return fNew\n}\n\nfunction correctedGravity(): Vector {\n    let gNew = new Vector(0, 0, 0)\n    if (simulating) {\n        gNew.x = -23.53\n        gNew.y = 30.43\n        gNew.z = -762.48\n    } else {\n        gNew.x = (input.acceleration(0) - gxOff) * gxScale\n        gNew.y = (input.acceleration(1) - gyOff) * gyScale\n        gNew.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return gNew\n}\n"]],"start1":11338,"start2":11338,"length1":31,"length2":764}]}]},{"timestamp":1724950975018,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"set "],[-1,"NorthXYZ, and thence fromXYZtoENG"],[0,"\ninp"]],"start1":5166,"start2":5166,"length1":41,"length2":8},{"diffs":[[0,"})\n\n"],[-1,"// test dot-products and cross-products between field and gravity"],[0,"\n"],[1,""],[0,"inpu"]],"start1":5650,"start2":5650,"length1":74,"length2":9},{"diffs":[[0,"ctedField()\n"],[-1,""],[0,"    let grav"]],"start1":5721,"start2":5721,"length1":24,"length2":24},{"diffs":[[0,"avity()\n"],[1,"    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n"],[0,"    let "]],"start1":5762,"start2":5762,"length1":16,"length2":148},{"diffs":[[0,"XYZtoENG"],[-1," = new"],[1,":"],[0," Quatern"]],"start1":12386,"start2":12386,"length1":22,"length2":17},{"diffs":[[0,"nion"],[-1,"(0, new Vector(0,0,1))\nlet from"],[0,"\n// "]],"start1":12402,"start2":12402,"length1":39,"length2":8}]}]},{"timestamp":1724951405674,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g = "],[-1,"isSimulating()"],[1,"true"],[0," // "]],"start1":13,"start2":13,"length1":22,"length2":12}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".0.2"],[-1,"9"],[1,"6"],[0,"\",\n "]],"start1":405,"start2":405,"length1":9,"length2":9}]}]},{"timestamp":1724951917062,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"function isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let Y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0)\n}\n\n"],[0,"\n// "]],"start1":11258,"start2":11258,"length1":196,"length2":8}]}]},{"timestamp":1724952515576,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"py)\n"],[-1,"            if (px == 0)  px = \n\n            }\n            if (px == 4) {\n\n            }\n            if (py == 0) {\n\n            }\n            if (py == 4) {\n\n            }\n"],[0,"    "]],"start1":9042,"start2":9042,"length1":181,"length2":8},{"diffs":[[0,"offsets\n    "],[1,"let "],[0,"fxOff = (fxH"]],"start1":9714,"start2":9714,"length1":24,"length2":28},{"diffs":[[0,"Lo) / 2\n    "],[1,"let "],[0,"fyOff = (fyH"]],"start1":9748,"start2":9748,"length1":24,"length2":28},{"diffs":[[0,"Lo) / 2\n    "],[1,"let "],[0,"fzOff = (fzH"]],"start1":9782,"start2":9782,"length1":24,"length2":28},{"diffs":[[0,"des\n    "],[1,"let "],[0,"fxMag = "]],"start1":9844,"start2":9844,"length1":16,"length2":20},{"diffs":[[0,"/ 2\n    "],[1,"let "],[0,"fyMag = "]],"start1":9878,"start2":9878,"length1":16,"length2":20},{"diffs":[[0,"/ 2\n    "],[1,"let "],[0,"fzMag = "]],"start1":9912,"start2":9912,"length1":16,"length2":20},{"diffs":[[0,"f 1000)\n    "],[1,"let "],[0,"fxScale = 10"]],"start1":9998,"start2":9998,"length1":24,"length2":28},{"diffs":[[0,"/ fxMag\n    "],[1,"let "],[0,"fyScale = 10"]],"start1":10029,"start2":10029,"length1":24,"length2":28},{"diffs":[[0,"/ fyMag\n    "],[1,"let "],[0,"fzScale = 10"]],"start1":10060,"start2":10060,"length1":24,"length2":28},{"diffs":[[0,"offsets\n    "],[1,"let "],[0,"gxOff = (gxH"]],"start1":10114,"start2":10114,"length1":24,"length2":28},{"diffs":[[0,"Lo) / 2\n    "],[1,"let "],[0,"gyOff = (gyH"]],"start1":10148,"start2":10148,"length1":24,"length2":28},{"diffs":[[0,"Lo) / 2\n    "],[1,"let "],[0,"gzOff = (gzH"]],"start1":10182,"start2":10182,"length1":24,"length2":28},{"diffs":[[0,"des\n    "],[1,"let "],[0,"gxMag = "]],"start1":10246,"start2":10246,"length1":16,"length2":20},{"diffs":[[0,"/ 2\n    "],[1,"let "],[0,"gyMag = "]],"start1":10280,"start2":10280,"length1":16,"length2":20},{"diffs":[[0,"/ 2\n    "],[1,"let "],[0,"gzMag = "]],"start1":10314,"start2":10314,"length1":16,"length2":20},{"diffs":[[0,"vities)\n    "],[1,"let "],[0,"gxScale = 10"]],"start1":10396,"start2":10396,"length1":24,"length2":28},{"diffs":[[0,"/ gxMag\n    "],[1,"let "],[0,"gyScale = 10"]],"start1":10427,"start2":10427,"length1":24,"length2":28},{"diffs":[[0,"/ gyMag\n    "],[1,"let "],[0,"gzScale = 10"]],"start1":10458,"start2":10458,"length1":24,"length2":28},{"diffs":[[0,"    let "],[-1,"y"],[1,"Y"],[0," = input"]],"start1":11332,"start2":11332,"length1":17,"length2":17},{"diffs":[[0,"(z == 0)"],[-1,")"],[0,"\n}\n\n\n// "]],"start1":11438,"start2":11438,"length1":17,"length2":16}]}]},{"timestamp":1724953115250,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= 0\n"],[-1,"    basic.clearScreen()\n"],[0,"    "]],"start1":7435,"start2":7435,"length1":32,"length2":8},{"diffs":[[0,"-down.\n\n"],[-1,"/*"],[0,"\n       "]],"start1":8109,"start2":8109,"length1":18,"length2":16},{"diffs":[[0,"    "],[-1,"count++\n */\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(1, 2)\n        if (g.x < -950) show(1, 2)\n        if (g.x < -950) show(1, 2)\n        if (g.x < -950) show(1, 2)\n        if (g.x < -950) show(1, 2)\n"],[1,"if (px == 0)  px = \n\n            }\n            if (px == 4) {\n\n            }\n            if (py == 0) {\n\n            }\n            if (py == 4) {\n\n            }\n            count++"],[0,"\n   "]],"start1":9054,"start2":9054,"length1":229,"length2":188}]}]},{"timestamp":1724953693312,"editorVersion":"7.0.29","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,", 0, 1, 1], [1, "],[-1,"1"],[1,"0"],[0,", 0, "],[-1,"1"],[1,"0"],[0,", 1], [0, 0, 0, "]],"start1":6720,"start2":6720,"length1":39,"length2":39},{"diffs":[[0,", 0, 0, 0], [1, "],[-1,"1"],[1,"0"],[0,", 0, "],[-1,"1"],[1,"0"],[0,", 1], [1, 1, 0, "]],"start1":6754,"start2":6754,"length1":39,"length2":39},{"diffs":[[0," 1, 1], [1, "],[-1,"1"],[1,"0"],[0,", 0, "],[-1,"1"],[1,"0"],[0,", 1], [0, 0,"]],"start1":6971,"start2":6971,"length1":31,"length2":31},{"diffs":[[0," 0, 0], [1, "],[-1,"1"],[1,"0"],[0,", 0, "],[-1,"1"],[1,"0"],[0,", 1], [1, 1,"]],"start1":7005,"start2":7005,"length1":31,"length2":31},{"diffs":[[0,"count < "],[-1,"9"],[1,"13"],[0,") {\n    "]],"start1":7474,"start2":7474,"length1":17,"length2":18},{"diffs":[[0,"wn.\n"],[-1,"        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)"],[1,"\n/*\n        // face-down from left/Logo down:       gx/gy just below 0; gz +1000\n        if ((g.z > 10 * (-g.x)) && (g.x < 0)) px = 0\n        if ((g.z > 10 * (-g.y)) && (g.y < 0)) py = 0\n        // Button B or Logo at the top:         gx/gy -1000; gz near 0\n        if ((-g.x) > 10 * zAbs) px = 1\n        if ((-g.y) > 10 * zAbs) py = 1\n        // face-up:                             gx/gy near 0; gz -1000\n        if ((-g.z) > 10 * Math.abs(g.x)) px = 2\n        if ((-g.z) > 10 * Math.abs(g.y)) py = 2\n        // Button B or Logo at the bottom:      gx/gy +1000; gz near 0\n        if (g.x > 10 * zAbs) px = 3\n        if (g.y > 10 * zAbs) py = 3\n        // face-down from right/Logo up:        gx/gy just above 0; gz +1000\n        if ((g.z > 10 * g.x) && (g.x > 0)) px = 4\n        if ((g.z > 10 * g.y) && (g.y > 0)) py = 4\n        pause(200)\n\n        if (lit[px][py] == 0) {\n            lit[px][py] = 1\n            led.plot(px, py)\n            count++\n */"],[0,"\n   "]],"start1":8136,"start2":8136,"length1":145,"length2":963},{"diffs":[[0,"  if (g."],[-1,"z"],[1,"x"],[0," < -950)"]],"start1":9102,"start2":9102,"length1":17,"length2":17},{"diffs":[[0,"0) show("],[-1,"2"],[1,"1"],[0,", 2)\n   "]],"start1":9117,"start2":9117,"length1":17,"length2":17},{"diffs":[[0,"50) "],[-1,"{\n           "],[1,"show(1, 2)\n        if (g.x < -950)"],[0," show("],[-1,"0"],[1,"1"],[0,", 2)"]],"start1":9150,"start2":9150,"length1":28,"length2":49},{"diffs":[[0,"        "],[-1,"   "],[1,"if (g.x < -950)"],[0," show("],[-1,"4"],[1,"1"],[0,", 2)\n   "]],"start1":9200,"start2":9200,"length1":26,"length2":38},{"diffs":[[0,"    "],[-1,"   "],[1,"if (g.x < -950)"],[0," show("],[-1,"2, 0"],[1,"1, 2"],[0,")\n  "]],"start1":9239,"start2":9239,"length1":21,"length2":33},{"diffs":[[0,"    "],[-1,"   "],[1,"if (g.x < -950)"],[0," show("],[-1,"4, 4)\n   "],[1,"1, 2)\n\n"],[0,"     "],[-1,"}\n\n"],[0,"       "],[-1," "],[0,"// f"]],"start1":9274,"start2":9274,"length1":42,"length2":48},{"diffs":[[0,"f field\n"],[1,"    "],[0,"        "]],"start1":9333,"start2":9333,"length1":16,"length2":20},{"diffs":[[0,"o = f.x\n        "],[1,"    "],[0,"if (f.y < fyLo) "]],"start1":9372,"start2":9372,"length1":32,"length2":36},{"diffs":[[0," fyLo = f.y\n"],[1,"    "],[0,"        if ("]],"start1":9407,"start2":9407,"length1":24,"length2":28},{"diffs":[[0,"o = f.z\n        "],[1,"    "],[0,"if (f.x > fxHi) "]],"start1":9450,"start2":9450,"length1":32,"length2":36},{"diffs":[[0," fxHi = f.x\n"],[1,"    "],[0,"        if ("]],"start1":9485,"start2":9485,"length1":24,"length2":28},{"diffs":[[0,"i = f.y\n        "],[1,"    "],[0,"if (f.z > fzHi) "]],"start1":9528,"start2":9528,"length1":32,"length2":36},{"diffs":[[0," = f.z\n\n"],[1,"    "],[0,"        "]],"start1":9568,"start2":9568,"length1":16,"length2":20},{"diffs":[[0,"ement!)\n        "],[1,"    "],[0,"if (g.x < gxLo) "]],"start1":9647,"start2":9647,"length1":32,"length2":36},{"diffs":[[0," gxLo = g.x\n"],[1,"    "],[0,"        if ("]],"start1":9682,"start2":9682,"length1":24,"length2":28},{"diffs":[[0,"o = g.y\n        "],[1,"    "],[0,"if (g.z < gzLo) "]],"start1":9725,"start2":9725,"length1":32,"length2":36},{"diffs":[[0," gzLo = g.z\n"],[1,"    "],[0,"        if ("]],"start1":9760,"start2":9760,"length1":24,"length2":28},{"diffs":[[0,"i = g.x\n        "],[1,"    "],[0,"if (g.y > gyHi) "]],"start1":9803,"start2":9803,"length1":32,"length2":36},{"diffs":[[0,"i = g.y\n        "],[1,"    "],[0,"if (g.z > gzHi) "]],"start1":9842,"start2":9842,"length1":32,"length2":36},{"diffs":[[0," gzHi = g.z\n"],[1,"        }\n"],[0,"    }\n    ba"]],"start1":9877,"start2":9877,"length1":24,"length2":34},{"diffs":[[0,"\n}\n\n"],[-1,"function show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        led.plot(px, py)\n        count++\n    }\n}\n\n"],[0,"\n// "]],"start1":11615,"start2":11615,"length1":150,"length2":8},{"diffs":[[0,"=======\n"],[-1,"let count = 0"],[0,"\n// set "]],"start1":11648,"start2":11648,"length1":29,"length2":16}]}]},{"timestamp":1724954185053,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," thence "],[-1,"compute "],[0,"fromXYZt"]],"start1":5193,"start2":5193,"length1":24,"length2":16}]}]},{"timestamp":1725084874591,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n"],[0,"    "]],"start1":4561,"start2":4561,"length1":144,"length2":8}]}]},{"timestamp":1725085465057,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"avity()\n    "],[-1,"//"],[0,"let dot = fi"]],"start1":6014,"start2":6014,"length1":26,"length2":24},{"diffs":[[0,"ty)\n    "],[-1,"//"],[0,"let cros"]],"start1":6058,"start2":6058,"length1":18,"length2":16},{"diffs":[[0,"ity)"],[-1,"\n    let fieldENG = fromXYZtoENG.appliedToVector(field)\n    let heading = (2*Math.PI + Math.atan2()"],[0,"\n\n  "]],"start1":6100,"start2":6100,"length1":107,"length2":8},{"diffs":[[0,"et f"],[-1,"ieldENG: Vector\nlet heading: Number"],[1,"rom"],[0,"\n// "]],"start1":12135,"start2":12135,"length1":43,"length2":11}]}]},{"timestamp":1725086050142,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ty)\n    "],[1,"let "],[0,"fieldENG"]],"start1":6105,"start2":6105,"length1":16,"length2":20},{"diffs":[[0,"(field)\n    "],[1,"let "],[0,"heading = (2"]],"start1":6156,"start2":6156,"length1":24,"length2":28},{"diffs":[[0,"ing = (2"],[-1," * "],[1,"*"],[0,"Math.PI "]],"start1":6176,"start2":6176,"length1":19,"length2":17},{"diffs":[[0,"an2("],[-1,"fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI"],[1,")"],[0,"\n\n  "]],"start1":6202,"start2":6202,"length1":86,"length2":9},{"diffs":[[0,"alogger.log("],[-1,"\n       "],[0," datalogger."]],"start1":6216,"start2":6216,"length1":32,"length2":24},{"diffs":[[0,", field.x),\n"],[1,"            "],[0,"        data"]],"start1":6253,"start2":6253,"length1":24,"length2":36},{"diffs":[[0,"eld.y),\n        "],[1,"       "],[1,"     "],[0,"datalogger.creat"]],"start1":6313,"start2":6313,"length1":32,"length2":44},{"diffs":[[0,"eld.z),\n        "],[1,"     "],[1,"       "],[0,"datalogger.creat"]],"start1":6369,"start2":6369,"length1":32,"length2":44},{"diffs":[[0,"gravity.x),\n"],[1,"            "],[0,"        data"]],"start1":6423,"start2":6423,"length1":24,"length2":36},{"diffs":[[0,"gravity.y),\n"],[1,"            "],[0,"        data"]],"start1":6481,"start2":6481,"length1":24,"length2":36},{"diffs":[[0,"gravity.z),\n"],[1,"            "],[0,"        data"]],"start1":6539,"start2":6539,"length1":24,"length2":36},{"diffs":[[0,"CV(\""],[-1,"ENG.x\", fieldENG.x),\n"],[1,"dot\", dot),\n            "],[0,"    "]],"start1":6588,"start2":6588,"length1":29,"length2":32},{"diffs":[[0,"CV(\""],[-1,"ENG.y\", fieldENG.y),\n        datalogger.createCV(\"ENG.z\", fieldENG.z),\n"],[1,"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n            "],[0,"    "]],"start1":6641,"start2":6641,"length1":79,"length2":99},{"diffs":[[0,"CV(\""],[-1,"heading\", heading"],[1,"crossz\", cross.z"],[0,"))\n\n"]],"start1":6761,"start2":6761,"length1":25,"length2":24},{"diffs":[[0,"   show("],[-1,"2"],[1,"4"],[0,", 4)\n   "]],"start1":8662,"start2":8662,"length1":17,"length2":17},{"diffs":[[0,"eading: "],[-1,"n"],[1,"N"],[0,"umber\n//"]],"start1":12263,"start2":12263,"length1":17,"length2":17}]}]},{"timestamp":1725086596377,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 1, 1]]\n    "],[1,"let "],[0,"count = 0\n  "]],"start1":7271,"start2":7271,"length1":24,"length2":28},{"diffs":[[0,"  if (g."],[-1,"z"],[1,"x"],[0," > 950) "]],"start1":8550,"start2":8550,"length1":17,"length2":17},{"diffs":[[0,") {\n"],[-1,"        count++\n"],[0,"    "]],"start1":10983,"start2":10983,"length1":24,"length2":8},{"diffs":[[0,"    "],[-1,"//basic.showNumber(count)\n        //pause(200)"],[1,"count++"],[0,"\n   "]],"start1":11040,"start2":11040,"length1":54,"length2":15}]}]},{"timestamp":1725087023258,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ld)\n"],[-1,"    fieldENG = fromXYZtoENG.appliedToVector(field)\n"],[0,"    "]],"start1":6156,"start2":6156,"length1":59,"length2":8}]}]},{"timestamp":1725113471868,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"gravv"],[1,"field"],[0,"ENG "]],"start1":6160,"start2":6160,"length1":13,"length2":13}]}]},{"timestamp":1725113477765,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"og(\n"],[-1,"        datalogger.createCV(\"data\", \"N & DOWN\"),\n"],[0,"    "]],"start1":5485,"start2":5485,"length1":57,"length2":8},{"diffs":[[0,"ion() {\n    "],[1,"let "],[0,"field = corr"]],"start1":5944,"start2":5944,"length1":24,"length2":28},{"diffs":[[0,"Field()\n    "],[1,"let "],[0,"gravity = co"]],"start1":5977,"start2":5977,"length1":24,"length2":28},{"diffs":[[0,"    grav"],[-1,"ity"],[1,"v"],[0,"ENG = fr"]],"start1":6160,"start2":6160,"length1":19,"length2":17},{"diffs":[[0,"oVector("],[-1,"gravity"],[1,"field"],[0,")\n    he"]],"start1":6196,"start2":6196,"length1":23,"length2":21},{"diffs":[[0,"og(\n"],[-1,"        datalogger.createCV(\"data\", \"XYZ vals\"),\n"],[0,"    "]],"start1":6347,"start2":6347,"length1":57,"length2":8},{"diffs":[[0,"y.z)"],[-1,")\n    datalogger.log("],[1,","],[0,"\n   "]],"start1":6615,"start2":6615,"length1":29,"length2":9},{"diffs":[[0,"CV(\""],[-1,"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    datalogger.log("],[1,"ENG.x\", fieldENG.x),\n        datalogger.createCV(\"ENG.y\", fieldENG.y),\n        datalogger.createCV(\"ENG.z\", fieldENG.z),"],[0,"\n   "]],"start1":6646,"start2":6646,"length1":336,"length2":128},{"diffs":[[0,"ading))\n"],[1,"\n"],[0,"})\n\ninpu"]],"start1":6812,"start2":6812,"length1":16,"length2":17},{"diffs":[[0,"ector {\n    let "],[-1,"reading"],[1,"fNew"],[0," = new Vector(0,"]],"start1":10045,"start2":10045,"length1":39,"length2":36},{"diffs":[[0,") {\n        "],[-1,"reading"],[1,"fNew"],[0,".x = 8.16\n  "]],"start1":10106,"start2":10106,"length1":31,"length2":28},{"diffs":[[0,".16\n        "],[-1,"reading"],[1,"fNew"],[0,".y = 7.91\n  "]],"start1":10128,"start2":10128,"length1":31,"length2":28},{"diffs":[[0,".91\n        "],[-1,"reading"],[1,"fNew"],[0,".z = 32.72\n "]],"start1":10150,"start2":10150,"length1":31,"length2":28},{"diffs":[[0," else {\n        "],[-1,"reading"],[1,"fNew"],[0,".x = (input.magn"]],"start1":10182,"start2":10182,"length1":39,"length2":36},{"diffs":[[0,"fxScale\n        "],[-1,"reading"],[1,"fNew"],[0,".y = (input.magn"]],"start1":10242,"start2":10242,"length1":39,"length2":36},{"diffs":[[0,"fyScale\n        "],[-1,"reading"],[1,"fNew"],[0,".z = (input.magn"]],"start1":10302,"start2":10302,"length1":39,"length2":36},{"diffs":[[0,"   }\n    return "],[-1,"reading"],[1,"fNew"],[0,"\n}\n\nfunction cor"]],"start1":10371,"start2":10371,"length1":39,"length2":36},{"diffs":[[0,"    let "],[-1,"reading"],[1,"gNew"],[0," = new V"]],"start1":10433,"start2":10433,"length1":23,"length2":20},{"diffs":[[0,") {\n        "],[-1,"reading"],[1,"gNew"],[0,".x = -23.53\n"]],"start1":10486,"start2":10486,"length1":31,"length2":28},{"diffs":[[0,".53\n        "],[-1,"reading"],[1,"gNew"],[0,".y = 30.43\n "]],"start1":10510,"start2":10510,"length1":31,"length2":28},{"diffs":[[0,".43\n        "],[-1,"reading"],[1,"gNew"],[0,".z = -762.48"]],"start1":10533,"start2":10533,"length1":31,"length2":28},{"diffs":[[0,"        "],[-1,"reading"],[1,"gNew"],[0,".x = (in"]],"start1":10575,"start2":10575,"length1":23,"length2":20},{"diffs":[[0,"        "],[-1,"reading"],[1,"gNew"],[0,".y = (in"]],"start1":10634,"start2":10634,"length1":23,"length2":20},{"diffs":[[0,"        "],[-1,"reading"],[1,"gNew"],[0,".z = (in"]],"start1":10693,"start2":10693,"length1":23,"length2":20},{"diffs":[[0,"urn "],[-1,"reading"],[1,"gNew"],[0,"\n}\n\n"]],"start1":10765,"start2":10765,"length1":15,"length2":12},{"diffs":[[0,"er.log( "],[-1,"\n    "],[0,"datalogg"]],"start1":11572,"start2":11572,"length1":21,"length2":16},{"diffs":[[0,"CV(\""],[-1,"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx"],[1,"fxOff"],[0,"\", f"]],"start1":11597,"start2":11597,"length1":53,"length2":13},{"diffs":[[0,"f\", fxOff),\n"],[1,"            "],[0,"    datalogg"]],"start1":11605,"start2":11605,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"fy"],[1,"Off"],[0,"\", fyOff),\n "]],"start1":11644,"start2":11644,"length1":24,"length2":27},{"diffs":[[0,"f\", fyOff),\n"],[1,"            "],[0,"    datalogg"]],"start1":11658,"start2":11658,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"fz"],[1,"Off"],[0,"\", fzOff),\n "]],"start1":11697,"start2":11697,"length1":24,"length2":27},{"diffs":[[0,"f\", fzOff),\n"],[1,"            "],[0,"    datalogg"]],"start1":11711,"start2":11711,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"gx"],[1,"Off"],[0,"\", gxOff),\n "]],"start1":11750,"start2":11750,"length1":24,"length2":27},{"diffs":[[0,"f\", gxOff),\n"],[1,"            "],[0,"    datalogg"]],"start1":11764,"start2":11764,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"gy"],[1,"Off"],[0,"\", gyOff),\n "]],"start1":11803,"start2":11803,"length1":24,"length2":27},{"diffs":[[0,"f\", gyOff),\n"],[1,"            "],[0,"    datalogg"]],"start1":11817,"start2":11817,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"gz"],[1,"Off"],[0,"\", gzOff))\n\n"]],"start1":11856,"start2":11856,"length1":24,"length2":27},{"diffs":[[0,"ger.log("],[-1,"\n   "],[0," datalog"]],"start1":11891,"start2":11891,"length1":20,"length2":16},{"diffs":[[0,"CV(\""],[-1,"data\", \"SCALE\"),\n    datalogger.createCV(\"fx"],[1,"fxScale"],[0,"\", f"]],"start1":11917,"start2":11917,"length1":52,"length2":15},{"diffs":[[0,"ale\", fxScale),\n"],[1,"            "],[0,"    datalogger.c"]],"start1":11925,"start2":11925,"length1":32,"length2":44},{"diffs":[[0,"createCV(\"fy"],[1,"Scale"],[0,"\", fyScale),"]],"start1":11968,"start2":11968,"length1":24,"length2":29},{"diffs":[[0,"ale\", fyScale),\n"],[1,"            "],[0,"    datalogger.c"]],"start1":11982,"start2":11982,"length1":32,"length2":44},{"diffs":[[0,"createCV(\"fz"],[1,"Scale"],[0,"\", fzScale),"]],"start1":12025,"start2":12025,"length1":24,"length2":29},{"diffs":[[0,"ale\", fzScale),\n"],[1,"            "],[0,"    datalogger.c"]],"start1":12039,"start2":12039,"length1":32,"length2":44},{"diffs":[[0,"createCV(\"gx"],[1,"Scale"],[0,"\", gxScale),"]],"start1":12082,"start2":12082,"length1":24,"length2":29},{"diffs":[[0,"ale\", gxScale),\n"],[1,"            "],[0,"    datalogger.c"]],"start1":12096,"start2":12096,"length1":32,"length2":44},{"diffs":[[0,"createCV(\"gy"],[1,"Scale"],[0,"\", gyScale),"]],"start1":12139,"start2":12139,"length1":24,"length2":29},{"diffs":[[0,", gyScale),\n"],[1,"            "],[0,"    datalogg"]],"start1":12157,"start2":12157,"length1":24,"length2":36},{"diffs":[[0,"createCV(\"gz"],[1,"Scale"],[0,"\", gzScale))"]],"start1":12196,"start2":12196,"length1":24,"length2":29},{"diffs":[[0,"ector(0,"],[-1," "],[0,"0,"],[-1," "],[0,"1))\nlet "]],"start1":12310,"start2":12310,"length1":20,"length2":18},{"diffs":[[0,"ield"],[-1,": Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravity"],[0,"ENG:"]],"start1":12329,"start2":12329,"length1":69,"length2":8}]}]},{"timestamp":1725114075005,"editorVersion":"7.0.35","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"avity()\n"],[1,"    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n\n"],[0,"    data"]],"start1":6055,"start2":6055,"length1":16,"length2":329},{"diffs":[[0,"datalogger.log(\n"],[-1,""],[0,"        datalogg"]],"start1":6380,"start2":6380,"length1":32,"length2":32},{"diffs":[[0,"z))\n"],[-1,"    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n"],[0,"    "]],"start1":6711,"start2":6711,"length1":202,"length2":8},{"diffs":[[0,"))\n\n"],[-1,"    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n"],[0,"    "]],"start1":7069,"start2":7069,"length1":127,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"7.0."],[-1,"35"],[1,"29"],[0,"\",\n "]],"start1":404,"start2":404,"length1":10,"length2":10}]}]},{"timestamp":1725114145342,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ed:\n"],[-1,"        \n"],[0,"    "]],"start1":8487,"start2":8487,"length1":17,"length2":8}]}]},{"timestamp":1726729570348,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ed:\n    "],[1,"    "],[0,"\n       "]],"start1":8487,"start2":8487,"length1":16,"length2":20}]}]},{"timestamp":1726729572233,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"rsed"],[-1,".\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:"],[1,":\n    "],[0,"\n   "]],"start1":8485,"start2":8485,"length1":116,"length2":14},{"diffs":[[0,"    // X"],[-1,":"],[1," is"],[0," -1000 w"]],"start1":8500,"start2":8500,"length1":17,"length2":19},{"diffs":[[0,"    // Y"],[-1,":"],[1," is"],[0," -1000 w"]],"start1":8582,"start2":8582,"length1":17,"length2":19},{"diffs":[[0,"    // Z"],[-1,":"],[1," is"],[0," -1000 w"]],"start1":8678,"start2":8678,"length1":17,"length2":19}]}]},{"timestamp":1726729972527,"editorVersion":"7.0.45","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n}"],[-1," export function collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = []\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + Latency\n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n"],[0,"\n\n\n/"]],"start1":11627,"start2":11627,"length1":2007,"length2":8}]}]},{"timestamp":1726812560138,"editorVersion":"7.0.45","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    }\n} "],[-1,"\n\n"],[0,"export f"]],"start1":11624,"start2":11624,"length1":18,"length2":16}]}]},{"timestamp":1726812567553,"editorVersion":"7.0.45","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n} \n\n"],[1,"export "],[0,"function"]],"start1":11626,"start2":11626,"length1":16,"length2":23}]}]},{"timestamp":1726812590022,"editorVersion":"7.1.4","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n}\n"],[-1,"/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    averagePeriod: number; // time gap between expected readings\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.reset(startTime, averagePeriod, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.averagePeriod\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n\n}\n"],[0,"\n\n\n/"]],"start1":13621,"start2":13621,"length1":2383,"length2":8}]}]},{"timestamp":1727421234916,"editorVersion":"7.1.4","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    }\n}\n"],[-1,"\n\n\n"],[0,"/*   A S"]],"start1":13617,"start2":13617,"length1":19,"length2":16}]}]},{"timestamp":1727421251674,"editorVersion":"7.1.4","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= [\n"],[-1,"        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z),\n"],[0,"    "]],"start1":11938,"start2":11938,"length1":131,"length2":8},{"diffs":[[0,"e(Dimension.X),\n"],[1,""],[0,"        input.ma"]],"start1":11968,"start2":11968,"length1":32,"length2":32},{"diffs":[[0,"amp,"],[-1," AverageGap, Window,"],[0," fre"]],"start1":12165,"start2":12165,"length1":28,"length2":8},{"diffs":[[0,"p + "],[-1,"(Window * AverageGap) "],[1,"Latency"],[0,"\n   "]],"start1":12297,"start2":12297,"length1":30,"length2":15},{"diffs":[[0,"= [\n"],[-1,"            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z),\n"],[0,"    "]],"start1":13088,"start2":13088,"length1":143,"length2":8},{"diffs":[[0,"\n\n\n\n"],[-1,"// ================ CLASSES ================\n\n"],[0,"/*  "]],"start1":13624,"start2":13624,"length1":54,"length2":8},{"diffs":[[0,"===="],[-1," FOREGROUND CODE "],[0,"===="]],"start1":16020,"start2":16020,"length1":25,"length2":8}]}]},{"timestamp":1727421560766,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"smoother.ts\""],[0,"\n   "]],"start1":305,"start2":305,"length1":31,"length2":8}]},{"type":"added","filename":"smoother.ts","value":""}]},{"timestamp":1727445515597,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"smoother.ts","patch":[{"diffs":[[-1,"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"]],"start1":0,"start2":0,"length1":830,"length2":0}]}]},{"timestamp":1727445515607,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n}\n\n\n\n"],[1,"// ================ CLASSES ================\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    averagePeriod: number; // time gap between expected readings\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.reset(startTime, averagePeriod, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.averagePeriod\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n\n}\n"],[0,"\n\n\n// =="]],"start1":13913,"start2":13913,"length1":16,"length2":2437}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ADME.md\""],[1,",\n        \"smoother.ts\""],[0,"\n    ],\n"]],"start1":301,"start2":301,"length1":16,"length2":39}]},{"type":"edited","filename":"smoother.ts","patch":[{"diffs":[[0,"\n/*"],[-1,"   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n        It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n        Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n        The number of readings to be averaged (the window) and expected gap between readings (samplingGap)\n        together set the overall latency associated with the exponential averaging process, \n        and govern the blending of new and old readings.\n*/\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window = 7 // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.samplingGap\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result"],[1,"*\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);"],[0,"\n   "]],"start1":0,"start2":0,"length1":2698,"length2":825}]}]},{"timestamp":1727446160099,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})\n"],[1,"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = []\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z),\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, AverageGap, Window, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * AverageGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z),\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n\n\n\n\n\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing..."]],"start1":0,"start2":0,"length1":33,"length2":15158}]}]},{"timestamp":1727446182482,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = []\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z),\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, AverageGap, Window, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * AverageGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z),\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n\n\n\n// ================ CLASSES ================\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    averagePeriod: number; // time gap between expected readings\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.reset(startTime, averagePeriod, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.averagePeriod\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n\n}\n\n\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing..."],[1,"basic.forever(function () {\n\t\n})\n"]],"start1":0,"start2":0,"length1":17579,"length2":33}]},{"type":"edited","filename":"smoother.ts","patch":[{"diffs":[[0,"*/\n\n"],[-1,"export "],[0,"clas"]],"start1":542,"start2":542,"length1":15,"length2":8},{"diffs":[[0,"    }\n}\n"],[-1,"\n"]],"start1":2695,"start2":2695,"length1":9,"length2":8}]}]},{"timestamp":1727446504962,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"gimbal"],[1," - Copy"],[0,"\",\n    \""]],"start1":13,"start2":13,"length1":16,"length2":23}]}]},{"timestamp":1727448833143,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"eStamp, "],[-1,"2"],[1,"AverageGap"],[0,", Window"]],"start1":12285,"start2":12285,"length1":17,"length2":26}]}]},{"timestamp":1727448954666,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er[][]\n\n"],[1,"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n"],[0,"// set N"]],"start1":547,"start2":547,"length1":16,"length2":4770},{"diffs":[[0,"YZtoENG\n"],[-1,""],[0,"input.on"]],"start1":5350,"start2":5350,"length1":16,"length2":16},{"diffs":[[0,"ownXYZ, new "],[-1,"Threed."],[0,"Vector(0,0,1"]],"start1":5851,"start2":5851,"length1":31,"length2":24},{"diffs":[[0,"new "],[-1,"Threed."],[0,"Vect"]],"start1":7936,"start2":7936,"length1":15,"length2":8},{"diffs":[[0,"mp, "],[-1,"100, 7"],[1,"2, Window"],[0,", fr"]],"start1":12289,"start2":12289,"length1":14,"length2":17}]},{"type":"edited","filename":"smoother.ts","patch":[{"diffs":[[0,"gs.\n*/\n\n"],[1,"export "],[0,"class Sm"]],"start1":538,"start2":538,"length1":16,"length2":23}]},{"type":"removed","filename":"main.blocks","value":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>"},{"type":"added","filename":"threed.ts","value":"namespace ThreeD {\r\n    /* 3-D vector, with methods for normalisation, dot-product and cross-product. \r\n    */\r\n    export class Vector {\r\n        x: number\r\n        y: number\r\n        z: number\r\n\r\n        constructor(dx: number, dy: number, dz: number) {\r\n            this.x = dx\r\n            this.y = dy\r\n            this.z = dz\r\n        }\r\n\r\n        normalised(): Vector {\r\n            let r = this.getMagnitude()\r\n            if (r == 0) {\r\n                return new Vector(0, 0, 0)\r\n            } else {\r\n                return new Vector(this.x / r, this.y / r, this.z / r)\r\n            }\r\n        }\r\n\r\n        dottedWith(v: Vector): number {\r\n            return (this.x * v.x + this.y * v.y + this.z * v.z)\r\n        }\r\n\r\n        crossedWith(v: Vector): Vector {\r\n            let x = this.y * v.z - v.y * this.z\r\n            let y = this.z * v.x - v.z * this.x\r\n            let z = this.x * v.y - v.x * this.y\r\n            return new Vector(x, y, z)\r\n        }\r\n\r\n        // we are sometimes more interested in the square of the magnitude \r\n        getLengthSquared(): number {\r\n            return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\r\n        }\r\n\r\n        getMagnitude(): number {\r\n            return Math.sqrt(this.getLengthSquared())\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * A Quaternion is used here as tool for manipulating rotations between the\r\n    * three 3D frames of reference we are using:\r\n    *\r\n    *       XYZ: the microbit Sensor-Frame\r\n    *\r\n    *       RFD: the buggy Body-Frame (Right, Front, Down)\r\n    *\r\n    *       ENG: the World-Frame in which it is navigating (East, North, Gravity)\r\n    *\r\n    * Initial construction is from an rotation about a given axis.\r\n    * Tools are provided to make it represent an alignment between two vectors,\r\n    * and to apply it to rotate a vector.\r\n    */\r\n    export class Quaternion {\r\n        // the real part\r\n        w: number\r\n        // the three imaginary parts\r\n        i: number\r\n        j: number\r\n        k: number\r\n        // squares of components (precomputed for efficiency)\r\n        ww: number\r\n        ii: number\r\n        jj: number\r\n        kk: number\r\n        // doubled products of components (precomputed for efficiency)\r\n        wi2: number\r\n        wj2: number\r\n        wk2: number\r\n        ij2: number\r\n        jk2: number\r\n        ki2: number\r\n\r\n        // given a rotation-angle and an axis-direction, build a unit quaternion\r\n        constructor(angle: number, axis: Vector) {\r\n            let unitV = axis.normalised()\r\n            this.w = Math.cos(angle / 2)\r\n            let sinHalfAngle = Math.sin(angle / 2)\r\n            this.i = unitV.x * sinHalfAngle\r\n            this.j = unitV.y * sinHalfAngle\r\n            this.k = unitV.z * sinHalfAngle\r\n            this.precompute()\r\n        }\r\n\r\n        // compute the Quaternion needed to align vector (a) onto (b)\r\n        // by rotating about an axis normal to their common plane\r\n        toAlignVectors(a: Vector, b: Vector) {\r\n            this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\r\n            if (this.w > 0.0001) {\r\n                let axis = a.crossedWith(b)\r\n                this.i = axis.x\r\n                this.j = axis.y\r\n                this.k = axis.z\r\n            } else {\r\n                // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\r\n                this.i = -a.z\r\n                this.j = a.y\r\n                this.k = a.x\r\n            }\r\n            this.normalise()\r\n            this.precompute()\r\n\r\n            datalogger.log(datalogger.createCV(\"w\", this.w),\r\n                datalogger.createCV(\"i\", this.i),\r\n                datalogger.createCV(\"j\", this.j),\r\n                datalogger.createCV(\"k\", this.k))\r\n        }\r\n\r\n        // use this Quaternion to generate a rotated Vector\r\n        appliedToVector(v: Vector): Vector {\r\n            let result = new Vector(0, 0, 0)\r\n            result.x\r\n                = v.x * (this.ww + this.ii - this.jj - this.kk)\r\n                + v.y * (this.ij2 - this.wk2)\r\n                + v.z * (this.ki2 + this.wj2)\r\n\r\n            result.y\r\n                = v.y * (this.ww + this.jj - this.kk - this.ii)\r\n                + v.z * (this.jk2 - this.wi2)\r\n                + v.x * (this.ij2 + this.wk2)\r\n\r\n            result.z\r\n                = v.z * (this.ww + this.kk - this.ii - this.jj)\r\n                + v.x * (this.ki2 - this.wj2)\r\n                + v.y * (this.wi2 + this.jk2)\r\n\r\n            return result\r\n        }\r\n\r\n        // for a unit Quaternion, the squares of all its components add up to 1.\r\n        normalise() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\r\n            this.w /= r\r\n            this.i /= r\r\n            this.j /= r\r\n            this.k /= r\r\n        }\r\n\r\n\r\n        // precompute squares and products (some doubled)...\r\n        precompute() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            this.wi2 = this.w * this.i * 2\r\n            this.wj2 = this.w * this.j * 2\r\n            this.wk2 = this.w * this.k * 2\r\n            this.ij2 = this.i * this.j * 2\r\n            this.ki2 = this.i * this.k * 2\r\n            this.jk2 = this.j * this.k * 2\r\n        }\r\n    }\r\n}\r\n"}]},{"timestamp":1727449528293,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"this"],[1,"gimbal"],[0,"\",\n "]],"start1":11,"start2":11,"length1":12,"length2":14},{"diffs":[[0,"\": \""],[-1,"invalid pxt.json file"],[0,"\",\n "]],"start1":40,"start2":40,"length1":29,"length2":8},{"diffs":[[0,"   \""],[-1,"microphone\": \"*\"\n    },\n    \"files\": ["],[1,"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.35\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    "],[0,"],\n "]],"start1":74,"start2":74,"length1":46,"length2":430}]},{"type":"removed","filename":"threed.ts","value":"namespace ThreeD {\r\n    /* 3-D vector, with methods for normalisation, dot-product and cross-product. \r\n    */\r\n    export class Vector {\r\n        x: number\r\n        y: number\r\n        z: number\r\n\r\n        constructor(dx: number, dy: number, dz: number) {\r\n            this.x = dx\r\n            this.y = dy\r\n            this.z = dz\r\n        }\r\n\r\n        normalised(): Vector {\r\n            let r = this.getMagnitude()\r\n            if (r == 0) {\r\n                return new Vector(0, 0, 0)\r\n            } else {\r\n                return new Vector(this.x / r, this.y / r, this.z / r)\r\n            }\r\n        }\r\n\r\n        dottedWith(v: Vector): number {\r\n            return (this.x * v.x + this.y * v.y + this.z * v.z)\r\n        }\r\n\r\n        crossedWith(v: Vector): Vector {\r\n            let x = this.y * v.z - v.y * this.z\r\n            let y = this.z * v.x - v.z * this.x\r\n            let z = this.x * v.y - v.x * this.y\r\n            return new Vector(x, y, z)\r\n        }\r\n\r\n        // we are sometimes more interested in the square of the magnitude \r\n        getLengthSquared(): number {\r\n            return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\r\n        }\r\n\r\n        getMagnitude(): number {\r\n            return Math.sqrt(this.getLengthSquared())\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * A Quaternion is used here as tool for manipulating rotations between the\r\n    * three 3D frames of reference we are using:\r\n    *\r\n    *       XYZ: the microbit Sensor-Frame\r\n    *\r\n    *       RFD: the buggy Body-Frame (Right, Front, Down)\r\n    *\r\n    *       ENG: the World-Frame in which it is navigating (East, North, Gravity)\r\n    *\r\n    * Initial construction is from an rotation about a given axis.\r\n    * Tools are provided to make it represent an alignment between two vectors,\r\n    * and to apply it to rotate a vector.\r\n    */\r\n    export class Quaternion {\r\n        // the real part\r\n        w: number\r\n        // the three imaginary parts\r\n        i: number\r\n        j: number\r\n        k: number\r\n        // squares of components (precomputed for efficiency)\r\n        ww: number\r\n        ii: number\r\n        jj: number\r\n        kk: number\r\n        // doubled products of components (precomputed for efficiency)\r\n        wi2: number\r\n        wj2: number\r\n        wk2: number\r\n        ij2: number\r\n        jk2: number\r\n        ki2: number\r\n\r\n        // given a rotation-angle and an axis-direction, build a unit quaternion\r\n        constructor(angle: number, axis: Vector) {\r\n            let unitV = axis.normalised()\r\n            this.w = Math.cos(angle / 2)\r\n            let sinHalfAngle = Math.sin(angle / 2)\r\n            this.i = unitV.x * sinHalfAngle\r\n            this.j = unitV.y * sinHalfAngle\r\n            this.k = unitV.z * sinHalfAngle\r\n            this.precompute()\r\n        }\r\n\r\n        // compute the Quaternion needed to align vector (a) onto (b)\r\n        // by rotating about an axis normal to their common plane\r\n        toAlignVectors(a: Vector, b: Vector) {\r\n            this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\r\n            if (this.w > 0.0001) {\r\n                let axis = a.crossedWith(b)\r\n                this.i = axis.x\r\n                this.j = axis.y\r\n                this.k = axis.z\r\n            } else {\r\n                // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\r\n                this.i = -a.z\r\n                this.j = a.y\r\n                this.k = a.x\r\n            }\r\n            this.normalise()\r\n            this.precompute()\r\n\r\n            datalogger.log(datalogger.createCV(\"w\", this.w),\r\n                datalogger.createCV(\"i\", this.i),\r\n                datalogger.createCV(\"j\", this.j),\r\n                datalogger.createCV(\"k\", this.k))\r\n        }\r\n\r\n        // use this Quaternion to generate a rotated Vector\r\n        appliedToVector(v: Vector): Vector {\r\n            let result = new Vector(0, 0, 0)\r\n            result.x\r\n                = v.x * (this.ww + this.ii - this.jj - this.kk)\r\n                + v.y * (this.ij2 - this.wk2)\r\n                + v.z * (this.ki2 + this.wj2)\r\n\r\n            result.y\r\n                = v.y * (this.ww + this.jj - this.kk - this.ii)\r\n                + v.z * (this.jk2 - this.wi2)\r\n                + v.x * (this.ij2 + this.wk2)\r\n\r\n            result.z\r\n                = v.z * (this.ww + this.kk - this.ii - this.jj)\r\n                + v.x * (this.ki2 - this.wj2)\r\n                + v.y * (this.wi2 + this.jk2)\r\n\r\n            return result\r\n        }\r\n\r\n        // for a unit Quaternion, the squares of all its components add up to 1.\r\n        normalise() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\r\n            this.w /= r\r\n            this.i /= r\r\n            this.j /= r\r\n            this.k /= r\r\n        }\r\n\r\n\r\n        // precompute squares and products (some doubled)...\r\n        precompute() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            this.wi2 = this.w * this.i * 2\r\n            this.wj2 = this.w * this.j * 2\r\n            this.wk2 = this.w * this.k * 2\r\n            this.ij2 = this.i * this.j * 2\r\n            this.ki2 = this.i * this.k * 2\r\n            this.jk2 = this.j * this.k * 2\r\n        }\r\n    }\r\n}\r\n"},{"type":"added","filename":"threeD.ts","value":"namespace ThreeD {\r\n    /* 3-D vector, with methods for normalisation, dot-product and cross-product. \r\n    */\r\n    export class Vector {\r\n        x: number\r\n        y: number\r\n        z: number\r\n\r\n        constructor(dx: number, dy: number, dz: number) {\r\n            this.x = dx\r\n            this.y = dy\r\n            this.z = dz\r\n        }\r\n\r\n        normalised(): Vector {\r\n            let r = this.getMagnitude()\r\n            if (r == 0) {\r\n                return new Vector(0, 0, 0)\r\n            } else {\r\n                return new Vector(this.x / r, this.y / r, this.z / r)\r\n            }\r\n        }\r\n\r\n        dottedWith(v: Vector): number {\r\n            return (this.x * v.x + this.y * v.y + this.z * v.z)\r\n        }\r\n\r\n        crossedWith(v: Vector): Vector {\r\n            let x = this.y * v.z - v.y * this.z\r\n            let y = this.z * v.x - v.z * this.x\r\n            let z = this.x * v.y - v.x * this.y\r\n            return new Vector(x, y, z)\r\n        }\r\n\r\n        // we are sometimes more interested in the square of the magnitude \r\n        getLengthSquared(): number {\r\n            return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\r\n        }\r\n\r\n        getMagnitude(): number {\r\n            return Math.sqrt(this.getLengthSquared())\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * A Quaternion is used here as tool for manipulating rotations between the\r\n    * three 3D frames of reference we are using:\r\n    *\r\n    *       XYZ: the microbit Sensor-Frame\r\n    *\r\n    *       RFD: the buggy Body-Frame (Right, Front, Down)\r\n    *\r\n    *       ENG: the World-Frame in which it is navigating (East, North, Gravity)\r\n    *\r\n    * Initial construction is from an rotation about a given axis.\r\n    * Tools are provided to make it represent an alignment between two vectors,\r\n    * and to apply it to rotate a vector.\r\n    */\r\n    export class Quaternion {\r\n        // the real part\r\n        w: number\r\n        // the three imaginary parts\r\n        i: number\r\n        j: number\r\n        k: number\r\n        // squares of components (precomputed for efficiency)\r\n        ww: number\r\n        ii: number\r\n        jj: number\r\n        kk: number\r\n        // doubled products of components (precomputed for efficiency)\r\n        wi2: number\r\n        wj2: number\r\n        wk2: number\r\n        ij2: number\r\n        jk2: number\r\n        ki2: number\r\n\r\n        // given a rotation-angle and an axis-direction, build a unit quaternion\r\n        constructor(angle: number, axis: Vector) {\r\n            let unitV = axis.normalised()\r\n            this.w = Math.cos(angle / 2)\r\n            let sinHalfAngle = Math.sin(angle / 2)\r\n            this.i = unitV.x * sinHalfAngle\r\n            this.j = unitV.y * sinHalfAngle\r\n            this.k = unitV.z * sinHalfAngle\r\n            this.precompute()\r\n        }\r\n\r\n        // compute the Quaternion needed to align vector (a) onto (b)\r\n        // by rotating about an axis normal to their common plane\r\n        toAlignVectors(a: Vector, b: Vector) {\r\n            this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\r\n            if (this.w > 0.0001) {\r\n                let axis = a.crossedWith(b)\r\n                this.i = axis.x\r\n                this.j = axis.y\r\n                this.k = axis.z\r\n            } else {\r\n                // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\r\n                this.i = -a.z\r\n                this.j = a.y\r\n                this.k = a.x\r\n            }\r\n            this.normalise()\r\n            this.precompute()\r\n\r\n            datalogger.log(datalogger.createCV(\"w\", this.w),\r\n                datalogger.createCV(\"i\", this.i),\r\n                datalogger.createCV(\"j\", this.j),\r\n                datalogger.createCV(\"k\", this.k))\r\n        }\r\n\r\n        // use this Quaternion to generate a rotated Vector\r\n        appliedToVector(v: Vector): Vector {\r\n            let result = new Vector(0, 0, 0)\r\n            result.x\r\n                = v.x * (this.ww + this.ii - this.jj - this.kk)\r\n                + v.y * (this.ij2 - this.wk2)\r\n                + v.z * (this.ki2 + this.wj2)\r\n\r\n            result.y\r\n                = v.y * (this.ww + this.jj - this.kk - this.ii)\r\n                + v.z * (this.jk2 - this.wi2)\r\n                + v.x * (this.ij2 + this.wk2)\r\n\r\n            result.z\r\n                = v.z * (this.ww + this.kk - this.ii - this.jj)\r\n                + v.x * (this.ki2 - this.wj2)\r\n                + v.y * (this.wi2 + this.jk2)\r\n\r\n            return result\r\n        }\r\n\r\n        // for a unit Quaternion, the squares of all its components add up to 1.\r\n        normalise() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\r\n            this.w /= r\r\n            this.i /= r\r\n            this.j /= r\r\n            this.k /= r\r\n        }\r\n\r\n\r\n        // precompute squares and products (some doubled)...\r\n        precompute() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            this.wi2 = this.w * this.i * 2\r\n            this.wj2 = this.w * this.j * 2\r\n            this.wk2 = this.w * this.k * 2\r\n            this.ij2 = this.i * this.j * 2\r\n            this.ki2 = this.i * this.k * 2\r\n            this.jk2 = this.j * this.k * 2\r\n        }\r\n    }\r\n}\r\n"}]},{"timestamp":1727449898561,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"/ gzMag\n"],[1,"\n"],[0,"}\n\n\nfunc"]],"start1":5686,"start2":5686,"length1":16,"length2":17},{"diffs":[[0,"   }\n}\n\n"],[1,"\n\n// ================ CLASSES ================\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    averagePeriod: number; // time gap between expected readings\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.reset(startTime, averagePeriod, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.averagePeriod\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n\n}\n\n\n\n"],[0,"// ====="]],"start1":9159,"start2":9159,"length1":16,"length2":2442}]},{"type":"edited","filename":"smoother.ts","patch":[{"diffs":[[0,"\n*/\n"],[-1,"namespace Smoother {\n        "],[1,"\n"],[0,"clas"]],"start1":541,"start2":541,"length1":37,"length2":9},{"diffs":[[0,"other {\n"],[-1,"        "],[0,"    dims"]],"start1":555,"start2":555,"length1":24,"length2":16},{"diffs":[[0,"onality\n"],[-1,"        "],[0,"    aver"]],"start1":591,"start2":591,"length1":24,"length2":16},{"diffs":[[0,"verages\n"],[-1,"        "],[0,"    wind"]],"start1":644,"start2":644,"length1":24,"length2":16},{"diffs":[[0,"  window"],[-1,": number;"],[1," = 7"],[0," // numb"]],"start1":654,"start2":654,"length1":25,"length2":20},{"diffs":[[0,"ood average\n"],[-1,"        "],[0,"    sampling"]],"start1":706,"start2":706,"length1":32,"length2":24},{"diffs":[[0,"ed readings\n"],[-1,"        "],[0,"    latency:"]],"start1":769,"start2":769,"length1":32,"length2":24},{"diffs":[[0,"cratch\n\n"],[-1,"        "],[0,"    last"]],"start1":864,"start2":864,"length1":24,"length2":16},{"diffs":[[0,"eadings\n"],[-1,"        "],[0,"    last"]],"start1":918,"start2":918,"length1":24,"length2":16},{"diffs":[[0,"adings\n\n"],[-1,"        "],[0,"    cons"]],"start1":984,"start2":984,"length1":24,"length2":16},{"diffs":[[0,") {\n        "],[-1,"  "],[-1,"      "],[0,"this.reset(s"]],"start1":1087,"start2":1087,"length1":32,"length2":24},{"diffs":[[0,"Values)\n"],[-1,"        "],[0,"    }\n\n"],[-1,"        "],[0,"    // ("]],"start1":1149,"start2":1149,"length1":39,"length2":23},{"diffs":[[0,"moother\n"],[-1,"        "],[0,"    rese"]],"start1":1192,"start2":1192,"length1":24,"length2":16},{"diffs":[[0,"er[]) {\n        "],[1,"this.dims = initialValues.length\n"],[0,"        this.las"]],"start1":1285,"start2":1285,"length1":32,"length2":65},{"diffs":[[0,"artTime\n"],[-1,"        "],[0,"        "]],"start1":1360,"start2":1360,"length1":24,"length2":16},{"diffs":[[0,"dow\n        "],[-1,"  "],[-1,"      "],[0,"this.samplin"]],"start1":1393,"start2":1393,"length1":32,"length2":24},{"diffs":[[0,"Gap\n        "],[-1,"  "],[-1,"      "],[0,"this.latency"]],"start1":1432,"start2":1432,"length1":32,"length2":24},{"diffs":[[0,"Gap\n"],[-1,"                this.dims = initialValues.length\n        "],[0,"    "]],"start1":1476,"start2":1476,"length1":65,"length2":8},{"diffs":[[0,"            "],[-1,"   "],[-1,"     "],[0,"this.average"]],"start1":1532,"start2":1532,"length1":32,"length2":24},{"diffs":[[0,"            "],[-1,"   "],[-1,"     "],[0,"this.lastInp"]],"start1":1584,"start2":1584,"length1":32,"length2":24},{"diffs":[[0,"    "],[-1,"  "],[-1,"      }\n            }\n\n        "],[1,"}\n    }\n\n"],[0,"    "]],"start1":1642,"start2":1642,"length1":41,"length2":17},{"diffs":[[0,"        "],[-1,"       "],[-1," "],[0,"// work "]],"start1":1715,"start2":1715,"length1":24,"length2":16},{"diffs":[[0,"o!)\n        "],[-1,"       "],[-1," "],[0,"let timeFrac"]],"start1":1794,"start2":1794,"length1":32,"length2":24},{"diffs":[[0,"Gap\n        "],[-1,"      "],[-1,"  "],[0,"let keepOld "]],"start1":1872,"start2":1872,"length1":32,"length2":24},{"diffs":[[0,"action)\n"],[-1,"        "],[0,"        "]],"start1":1914,"start2":1914,"length1":24,"length2":16},{"diffs":[[0,"ion\n        "],[-1,"     "],[-1,"   "],[0,"// amplify t"]],"start1":1971,"start2":1971,"length1":32,"length2":24},{"diffs":[[0,"average\n"],[-1,"        "],[0,"        "]],"start1":2049,"start2":2049,"length1":24,"length2":16},{"diffs":[[0,"ld)\n        "],[-1,"    "],[-1,"    "],[0,"let addNew ="]],"start1":2099,"start2":2099,"length1":32,"length2":24},{"diffs":[[0,"erited)\n"],[-1,"        "],[0,"        "]],"start1":2132,"start2":2132,"length1":24,"length2":16},{"diffs":[[0,"        "],[-1,"  "],[-1,"      "],[0,"// apply"]],"start1":2230,"start2":2230,"length1":24,"length2":16},{"diffs":[[0," arrays\n"],[-1,"        "],[0,"        "]],"start1":2291,"start2":2291,"length1":24,"length2":16},{"diffs":[[0,"        "],[-1," "],[-1,"       "],[0,"for (let"]],"start1":2333,"start2":2333,"length1":24,"length2":16},{"diffs":[[0,"ims; i++) {\n"],[-1,"        "],[0,"            "]],"start1":2367,"start2":2367,"length1":32,"length2":24},{"diffs":[[0,"        "],[-1,"        "],[0,"+ boostL"]],"start1":2438,"start2":2438,"length1":24,"length2":16},{"diffs":[[0,"        "],[-1,"       "],[-1," "],[0,"+ addNew"]],"start1":2487,"start2":2487,"length1":24,"length2":16},{"diffs":[[0,"    "],[-1,"        }\n     "],[1,"}\n"],[0,"        "],[-1,"   "],[0,"// u"]],"start1":2521,"start2":2521,"length1":34,"length2":18},{"diffs":[[0," around\n"],[-1,"        "],[0,"        "]],"start1":2566,"start2":2566,"length1":24,"length2":16},{"diffs":[[0,"ult\n        "],[-1,"    "],[-1,"    "],[0,"this.lastTim"]],"start1":2601,"start2":2601,"length1":32,"length2":24},{"diffs":[[0,"amp\n        "],[-1,"    "],[-1,"    "],[0,"this.lastInp"]],"start1":2635,"start2":2635,"length1":32,"length2":24},{"diffs":[[0,"        "],[-1,"   "],[-1,"     "],[0,"return r"]],"start1":2673,"start2":2673,"length1":24,"length2":16},{"diffs":[[0,"ult\n"],[-1,"            }\n        }\n"],[0,"    }\n}"],[1,"\n\n"]],"start1":2691,"start2":2691,"length1":35,"length2":13}]},{"type":"edited","filename":"threeD.ts","patch":[{"diffs":[[0,"s from a"],[1,"n"],[0," rotatio"]],"start1":1672,"start2":1672,"length1":16,"length2":17}]}]},{"timestamp":1727450491407,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    let g = new "],[-1,"Threed."],[0,"Vector(0, 0, 0)\n"]],"start1":3216,"start2":3216,"length1":39,"length2":32},{"diffs":[[0,"tedField(): "],[-1,"Threed."],[0,"Vector {\n   "]],"start1":5713,"start2":5713,"length1":31,"length2":24},{"diffs":[[0,"t reading = new "],[-1,"Threed."],[0,"Vector(0, 0, 0)\n"]],"start1":5740,"start2":5740,"length1":39,"length2":32},{"diffs":[[0,"vity(): "],[-1,"Threed."],[0,"Vector {"]],"start1":6121,"start2":6121,"length1":23,"length2":16},{"diffs":[[0,"ading = new "],[-1,"Threed."],[0,"Vector(0, 0,"]],"start1":6148,"start2":6148,"length1":31,"length2":24},{"diffs":[[0,"t northXYZ: "],[-1,"Threed."],[0,"Vector\nlet d"]],"start1":10174,"start2":10174,"length1":31,"length2":24},{"diffs":[[0,"ownXYZ: "],[-1,"Threed."],[0,"Vector\nl"]],"start1":10198,"start2":10198,"length1":23,"length2":16},{"diffs":[[0,"G = new "],[-1,"Threed."],[0,"Quaterni"]],"start1":10228,"start2":10228,"length1":23,"length2":16},{"diffs":[[0," field: "],[-1,"Threed."],[0,"Vector\nl"]],"start1":10274,"start2":10274,"length1":23,"length2":16},{"diffs":[[0,"ravity: "],[-1,"Threed."],[0,"Vector\nl"]],"start1":10294,"start2":10294,"length1":23,"length2":16},{"diffs":[[0,"eldENG: "],[-1,"Threed."],[0,"Vector\nl"]],"start1":10315,"start2":10315,"length1":23,"length2":16},{"diffs":[[0,"vityENG:"],[-1," Threed."],[0," Vector\n"]],"start1":10337,"start2":10337,"length1":24,"length2":16}]}]},{"timestamp":1727450700224,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"unt = 0\n"],[-1,"\n"],[0,"// set s"]],"start1":9260,"start2":9260,"length1":17,"length2":16}]}]},{"timestamp":1727504175341,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"unt = 0\n"],[-1,"let"],[0,"\n// set "]],"start1":9260,"start2":9260,"length1":19,"length2":16}]}]},{"timestamp":1727504176968,"editorVersion":"7.0.42","changes":[{"type":"removed","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"removed","filename":"main.ts","value":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Threed.Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Threed.Vector(0, 0, 0)\n    let g = new Threed.Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n}\n\n\nfunction correctedField(): Threed.Vector {\n    let reading = new Threed.Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Threed.Vector {\n    let reading = new Threed.Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = []\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z),\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, 100, 7, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * AverageGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z),\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n\n// =============== FOREGROUND CODE =================\nlet count = 0\nlet\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Threed.Vector\nlet downXYZ: Threed.Vector\nlet fromXYZtoENG = new Threed.Quaternion(0, new Vector(0, 0, 1))\nlet field: Threed.Vector\nlet gravity: Threed.Vector\nlet fieldENG: Threed.Vector\nlet gravityENG: Threed. Vector\nlet heading: number\n// await button-pressing..."},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"[],\n"],[-1,"    \"targetVersions\": {\n        \"target\": \"7.0.42\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n"],[0,"    "]],"start1":134,"start2":134,"length1":150,"length2":8}]},{"type":"removed","filename":"smoother.ts","value":"\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n        It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n        Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n        The number of readings to be averaged (the window) and expected gap between readings (samplingGap)\n        together set the overall latency associated with the exponential averaging process, \n        and govern the blending of new and old readings.\n*/\nnamespace Smoother {\n        class Smoother {\n            dims: number; // dimensionality\n            averages: number[] = []; // the rolling averages\n            window: number; // number of samples needed to form a good average\n            samplingGap: number; // time gap between expected readings\n            latency: number // resulting time taken to collect a good moving average from scratch\n\n            lastTime: number; // timestamp of latest readings\n            lastInputs: number[] = []; // copy of latest set of readings\n\n            constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n                this.reset(startTime, window, samplingGap, initialValues)\n            }\n\n            // (re)initialise this Smoother\n            reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n                this.lastTime = startTime\n                this.window = window\n                this.samplingGap = samplingGap\n                this.latency = window * samplingGap\n                this.dims = initialValues.length\n                for (let dim = 0; dim < this.dims; dim++) {\n                    this.averages[dim] = initialValues[dim]\n                    this.lastInputs[dim] = initialValues[dim]\n                }\n            }\n\n            update(timeStamp: number, values: number[]): number[] {\n                // work out appropriate blend, based on time-step (guarding against zero!)\n                let timeFraction = (timeStamp - this.lastTime + 1) / this.samplingGap\n                let keepOld = Math.exp(-timeFraction)\n                let inherited = (1 - keepOld) / timeFraction\n                // amplify the most recent sample's contribution to the inherited average\n                let boostLast = (inherited - keepOld)\n                let addNew = (1 - inherited)\n                // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n                // apply blending to all elements of old and new data arrays\n                let result: number[] = []\n                for (let i = 0; i < this.dims; i++) {\n                    result.push(keepOld * this.averages[i]\n                        + boostLast * this.lastInputs[i]\n                        + addNew * values[i])\n                }\n                // update history for next time around\n                this.averages = result\n                this.lastTime = timeStamp\n                this.lastInputs = values\n\n                return result\n            }\n        }\n    }\n}"},{"type":"removed","filename":"threeD.ts","value":"namespace ThreeD {\r\n    /* 3-D vector, with methods for normalisation, dot-product and cross-product. \r\n    */\r\n    export class Vector {\r\n        x: number\r\n        y: number\r\n        z: number\r\n\r\n        constructor(dx: number, dy: number, dz: number) {\r\n            this.x = dx\r\n            this.y = dy\r\n            this.z = dz\r\n        }\r\n\r\n        normalised(): Vector {\r\n            let r = this.getMagnitude()\r\n            if (r == 0) {\r\n                return new Vector(0, 0, 0)\r\n            } else {\r\n                return new Vector(this.x / r, this.y / r, this.z / r)\r\n            }\r\n        }\r\n\r\n        dottedWith(v: Vector): number {\r\n            return (this.x * v.x + this.y * v.y + this.z * v.z)\r\n        }\r\n\r\n        crossedWith(v: Vector): Vector {\r\n            let x = this.y * v.z - v.y * this.z\r\n            let y = this.z * v.x - v.z * this.x\r\n            let z = this.x * v.y - v.x * this.y\r\n            return new Vector(x, y, z)\r\n        }\r\n\r\n        // we are sometimes more interested in the square of the magnitude \r\n        getLengthSquared(): number {\r\n            return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\r\n        }\r\n\r\n        getMagnitude(): number {\r\n            return Math.sqrt(this.getLengthSquared())\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * A Quaternion is used here as tool for manipulating rotations between the\r\n    * three 3D frames of reference we are using:\r\n    *\r\n    *       XYZ: the microbit Sensor-Frame\r\n    *\r\n    *       RFD: the buggy Body-Frame (Right, Front, Down)\r\n    *\r\n    *       ENG: the World-Frame in which it is navigating (East, North, Gravity)\r\n    *\r\n    * Initial construction is from a rotation about a given axis.\r\n    * Tools are provided to make it represent an alignment between two vectors,\r\n    * and to apply it to rotate a vector.\r\n    */\r\n    export class Quaternion {\r\n        // the real part\r\n        w: number\r\n        // the three imaginary parts\r\n        i: number\r\n        j: number\r\n        k: number\r\n        // squares of components (precomputed for efficiency)\r\n        ww: number\r\n        ii: number\r\n        jj: number\r\n        kk: number\r\n        // doubled products of components (precomputed for efficiency)\r\n        wi2: number\r\n        wj2: number\r\n        wk2: number\r\n        ij2: number\r\n        jk2: number\r\n        ki2: number\r\n\r\n        // given a rotation-angle and an axis-direction, build a unit quaternion\r\n        constructor(angle: number, axis: Vector) {\r\n            let unitV = axis.normalised()\r\n            this.w = Math.cos(angle / 2)\r\n            let sinHalfAngle = Math.sin(angle / 2)\r\n            this.i = unitV.x * sinHalfAngle\r\n            this.j = unitV.y * sinHalfAngle\r\n            this.k = unitV.z * sinHalfAngle\r\n            this.precompute()\r\n        }\r\n\r\n        // compute the Quaternion needed to align vector (a) onto (b)\r\n        // by rotating about an axis normal to their common plane\r\n        toAlignVectors(a: Vector, b: Vector) {\r\n            this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\r\n            if (this.w > 0.0001) {\r\n                let axis = a.crossedWith(b)\r\n                this.i = axis.x\r\n                this.j = axis.y\r\n                this.k = axis.z\r\n            } else {\r\n                // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\r\n                this.i = -a.z\r\n                this.j = a.y\r\n                this.k = a.x\r\n            }\r\n            this.normalise()\r\n            this.precompute()\r\n\r\n            datalogger.log(datalogger.createCV(\"w\", this.w),\r\n                datalogger.createCV(\"i\", this.i),\r\n                datalogger.createCV(\"j\", this.j),\r\n                datalogger.createCV(\"k\", this.k))\r\n        }\r\n\r\n        // use this Quaternion to generate a rotated Vector\r\n        appliedToVector(v: Vector): Vector {\r\n            let result = new Vector(0, 0, 0)\r\n            result.x\r\n                = v.x * (this.ww + this.ii - this.jj - this.kk)\r\n                + v.y * (this.ij2 - this.wk2)\r\n                + v.z * (this.ki2 + this.wj2)\r\n\r\n            result.y\r\n                = v.y * (this.ww + this.jj - this.kk - this.ii)\r\n                + v.z * (this.jk2 - this.wi2)\r\n                + v.x * (this.ij2 + this.wk2)\r\n\r\n            result.z\r\n                = v.z * (this.ww + this.kk - this.ii - this.jj)\r\n                + v.x * (this.ki2 - this.wj2)\r\n                + v.y * (this.wi2 + this.jk2)\r\n\r\n            return result\r\n        }\r\n\r\n        // for a unit Quaternion, the squares of all its components add up to 1.\r\n        normalise() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\r\n            this.w /= r\r\n            this.i /= r\r\n            this.j /= r\r\n            this.k /= r\r\n        }\r\n\r\n\r\n        // precompute squares and products (some doubled)...\r\n        precompute() {\r\n            this.ww = this.w * this.w\r\n            this.ii = this.i * this.i\r\n            this.jj = this.j * this.j\r\n            this.kk = this.k * this.k\r\n            this.wi2 = this.w * this.i * 2\r\n            this.wj2 = this.w * this.j * 2\r\n            this.wk2 = this.w * this.k * 2\r\n            this.ij2 = this.i * this.j * 2\r\n            this.ki2 = this.i * this.k * 2\r\n            this.jk2 = this.j * this.k * 2\r\n        }\r\n    }\r\n}\r\n"}]},{"timestamp":1727504855680,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"gimbal"],[1,"this"],[0,"\",\n "]],"start1":11,"start2":11,"length1":14,"length2":12},{"diffs":[[0,"tion\": \""],[1,"invalid pxt.json file"],[0,"\",\n    \""]],"start1":34,"start2":34,"length1":16,"length2":37},{"diffs":[[0,"   \""],[-1,"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    "],[1,"microphone\": \"*\"\n    },\n    \"files\": ["],[0,"],\n "]],"start1":93,"start2":93,"length1":288,"length2":46},{"diffs":[[0,"tsprj\"\n}"],[1,"\n"]],"start1":304,"start2":304,"length1":8,"length2":9}]},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>"},{"type":"added","filename":"main.ts","value":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = []\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z),\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, AverageGap, Window, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * AverageGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z),\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the triple of averaged [X,Y,Z] values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n\n\n\n// ================ CLASSES ================\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    averagePeriod: number; // time gap between expected readings\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.reset(startTime, averagePeriod, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, averagePeriod: number, initialValues: number[]) {\n        this.dims = initialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.averagePeriod\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n\n}\n\n\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing..."},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]},{"timestamp":1727504978532,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"mbal"],[-1," - Copy"],[0,"\",\n "]],"start1":17,"start2":17,"length1":15,"length2":8},{"diffs":[[0," \"7."],[-1,"1"],[1,"0"],[0,".4"],[1,"2"],[0,"\",\n "]],"start1":402,"start2":402,"length1":11,"length2":12},{"diffs":[[0,"tsprj\"\n}"],[-1,"\n"]],"start1":527,"start2":527,"length1":9,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er[][]\n\n"],[1,"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n"],[0,"// set N"]],"start1":547,"start2":547,"length1":16,"length2":4770},{"diffs":[[0,"}\n\n\n"],[-1,"// =============== FOREGROUND CODE =================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing...\n\n\n"],[0,"\n// "]],"start1":13916,"start2":13916,"length1":1482,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log("],[1,"\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    "],[0,"data"]],"start1":16339,"start2":16339,"length1":2804,"length2":859},{"diffs":[[0,"eateCV(\""],[-1,"w\", this.w),\n        "],[1,"fz\", fzScale),\n"],[0,"    data"]],"start1":17207,"start2":17207,"length1":37,"length2":31},{"diffs":[[0,"eateCV(\""],[-1,"i\", this.i),\n        "],[1,"gx\", gxScale),\n"],[0,"    data"]],"start1":17247,"start2":17247,"length1":37,"length2":31},{"diffs":[[0,"eateCV(\""],[-1,"j\", this.j),\n        "],[1,"gy\", gyScale),\n"],[0,"    data"]],"start1":17287,"start2":17287,"length1":37,"length2":31},{"diffs":[[0,"CV(\""],[-1,"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}"],[1,"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing..."]],"start1":17331,"start2":17331,"length1":1514,"length2":248}]}]},{"timestamp":1727505447643,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ing\n"],[-1,"let window = 7\nlet sampleGap = 100\nlet tooManySamples = 200\n\n"],[0,"\n\n//"]],"start1":45,"start2":45,"length1":69,"length2":8},{"diffs":[[0,"mp, "],[-1,"sampl"],[1,"Averag"],[0,"eGap, "],[-1,"w"],[1,"W"],[0,"indo"]],"start1":7535,"start2":7535,"length1":20,"length2":21},{"diffs":[[0,"tamp + ("],[-1,"w"],[1,"W"],[0,"indow * "],[-1,"sampl"],[1,"Averag"],[0,"eGap) \n "]],"start1":7683,"start2":7683,"length1":30,"length2":31},{"diffs":[[0,"ength < "],[-1,"t"],[1,"T"],[0,"ooManySa"]],"start1":7852,"start2":7852,"length1":17,"length2":17},{"diffs":[[0,"meWas + "],[-1,"s"],[1,"S"],[0,"ampleGap"]],"start1":8329,"start2":8329,"length1":17,"length2":17},{"diffs":[[0,"\n    */\n"],[-1,"\n"],[0,"class Sm"]],"start1":11152,"start2":11152,"length1":17,"length2":16},{"diffs":[[0,"    "],[-1,"window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n"],[1,"averagePeriod: number; // time gap between expected readings"],[0,"\n   "]],"start1":11266,"start2":11266,"length1":228,"length2":68},{"diffs":[[0,"er, "],[-1,"window: number, samplingGap"],[1,"averagePeriod"],[0,": nu"]],"start1":11482,"start2":11482,"length1":35,"length2":21},{"diffs":[[0,"me, "],[-1,"window, samplingGap"],[1,"averagePeriod"],[0,", in"]],"start1":11562,"start2":11562,"length1":27,"length2":21},{"diffs":[[0,"er, "],[-1,"window: number, samplingGap"],[1,"averagePeriod"],[0,": nu"]],"start1":11664,"start2":11664,"length1":35,"length2":21},{"diffs":[[0,"his."],[-1,"lastTime = startTime\n        this.window"],[1,"dims"],[0," = "],[-1,"w"],[0,"in"],[-1,"dow\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length"],[1,"itialValues.length\n        this.lastTime = startTime\n        this.averagePeriod = averagePeriod"],[0,"\n   "]],"start1":11727,"start2":11727,"length1":181,"length2":112},{"diffs":[[0,"his."],[-1,"samplingGap"],[1,"averagePeriod"],[0,"\n   "]],"start1":12216,"start2":12216,"length1":19,"length2":21},{"diffs":[[0,"t\n    }\n"],[-1,"}"],[0,"\n"],[1,"}"],[0,"\n\n/* 3-D"]],"start1":13051,"start2":13051,"length1":18,"length2":18}]}]},{"timestamp":1727506039266,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"gimbal"],[1," - Copy"],[0,"\",\n    \""]],"start1":13,"start2":13,"length1":16,"length2":23}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"\n// =============  GLOBALS ===============\n\n"],[0,"let "]],"start1":0,"start2":0,"length1":48,"length2":4},{"diffs":[[0,"200\n"],[-1,"let scanTimes: number[] = []\nlet scanData: number[][] = []\n"],[0,"\n\n\n/"]],"start1":105,"start2":105,"length1":67,"length2":8},{"diffs":[[0," number\n"],[-1,"\n"],[0,"// gravi"]],"start1":334,"start2":334,"length1":17,"length2":16},{"diffs":[[0," number\n"],[-1,"\n"],[0,"// calib"]],"start1":568,"start2":568,"length1":17,"length2":16},{"diffs":[[0,"[]\n\n"],[-1,"// ================ CLASSES ================\n\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.samplingGap\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// ============== INPUT HANDLERS ===============\n\n"],[0,"// s"]],"start1":612,"start2":612,"length1":7210,"length2":8},{"diffs":[[0,"})\n\n"],[-1,"// ============== FUNCTIONS ===============\n\n"],[0,"// s"]],"start1":2729,"start2":2729,"length1":53,"length2":8},{"diffs":[[0,"ing...\n\n"],[1,"\n\n// ================ CLASSES ================\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.samplingGap\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push(keepOld * this.averages[i]\n                + boostLast * this.lastInputs[i]\n                + addNew * values[i])\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}"]],"start1":10690,"start2":10690,"length1":8,"length2":7159}]}]},{"timestamp":1727506582488,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," sample "],[-1,"the "],[0,"field an"]],"start1":10087,"start2":10087,"length1":20,"length2":16}]}]},{"timestamp":1727522585567,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"creen()\n"],[1,"    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n"],[0,"})\n\n// ="]],"start1":9914,"start2":9914,"length1":16,"length2":130}]}]},{"timestamp":1727522901178,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"===\n"],[-1,"input.onButtonPressed(Button.A, function() {\n    scanData = []\n    scanTimes = []\n    basic.showString(\"S"],[1,"\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN"],[0,"\")"],[1,","],[0,"\n    "],[-1,"pause(1000)\n    basic.clearScreen()\n    collectSamples(3000)\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()"],[1,"    datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    "],[0,"\n})\n"]],"start1":7918,"start2":7918,"length1":254,"length2":585},{"diffs":[[0,"ion() {\n"],[1,"    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n"],[0,"})\n\ninpu"]],"start1":8607,"start2":8607,"length1":16,"length2":1157},{"diffs":[[0,"}\n\n\n"],[-1,"function correct() {\n    // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction process() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\nfunction dumpScan() {\n    for (let i = 0; i < scanTimes.length; i++) {\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", scanData[0][i]),\n        datalogger.createCV(\"fy\", scanData[1][i]),\n        datalogger.createCV(\"fz\", scanData[2][i]),\n        datalogger.createCV(\"gx\", scanData[3][i]),\n        datalogger.createCV(\"gy\", scanData[0][i]),\n        datalogger.createCV(\"gz\", scanData[0][i])\n}\n"],[0,"// ="]],"start1":16463,"start2":16463,"length1":2176,"length2":8}]}]},{"timestamp":1727523501157,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    basic.showString(\"D\")\n    pause(1000)\n    basic.clearScreen()\n    dumpScan()\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButt"],[1,"})\n\ninput.onLogoEvent(TouchButtonEvent.L"],[0,"on"],[1,"g"],[0,"Pressed"],[-1,"(Button.AB"],[0,", fu"]],"start1":8280,"start2":8280,"length1":198,"length2":58},{"diffs":[[0,"d[2]"],[-1,", updated[3], updated[4], updated[5]"],[0,"])\n "]],"start1":14899,"start2":14899,"length1":44,"length2":8},{"diffs":[[0,"gth; i++) {\n"],[-1,"    "],[0,"    datalogg"]],"start1":16775,"start2":16775,"length1":28,"length2":24},{"diffs":[[0,"er.log(\n    "],[1,"    datalogger.createCV(\"data\", \"ENG vals\"),\n"],[0,"        data"]],"start1":16799,"start2":16799,"length1":24,"length2":69},{"diffs":[[0,"ata["],[-1,"i][0"],[1,"0][i"],[0,"]),\n"]],"start1":16895,"start2":16895,"length1":12,"length2":12},{"diffs":[[0,"0][i]),\n        "],[-1,"    "],[0,"datalogger.creat"]],"start1":16899,"start2":16899,"length1":36,"length2":32},{"diffs":[[0,"ata["],[-1,"i][1"],[1,"1][i"],[0,"]),\n"]],"start1":16946,"start2":16946,"length1":12,"length2":12},{"diffs":[[0,"1][i]),\n        "],[-1,"    "],[0,"datalogger.creat"]],"start1":16950,"start2":16950,"length1":36,"length2":32},{"diffs":[[0,"ata["],[-1,"i][2"],[1,"2][i"],[0,"]),\n"]],"start1":16997,"start2":16997,"length1":12,"length2":12},{"diffs":[[0,"2][i]),\n        "],[-1,"    "],[0,"datalogger.creat"]],"start1":17001,"start2":17001,"length1":36,"length2":32},{"diffs":[[0,"ata["],[-1,"i][3"],[1,"3][i"],[0,"]),\n"],[-1,"    "],[0,"    "]],"start1":17048,"start2":17048,"length1":20,"length2":16},{"diffs":[[0,"ata["],[-1,"i][4"],[1,"0][i"],[0,"]),\n"],[-1,"    "],[0,"    "]],"start1":17099,"start2":17099,"length1":20,"length2":16},{"diffs":[[0,"ata["],[-1,"i][5"],[1,"0][i"],[0,"])\n"],[-1,"        )\n    }\n"],[0,"}\n"],[-1,"\n"],[0,"// ="]],"start1":17150,"start2":17150,"length1":34,"length2":17},{"diffs":[[0,"nt = 0\n/"],[-1,"*"],[1,"/"],[0," set sca"]],"start1":17223,"start2":17223,"length1":17,"length2":17}]}]},{"timestamp":1727524096887,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"earScreen()\n})\n\n"],[1,"// test dot-products and cross-products between field and gravity\n"],[0,"input.onButtonPr"]],"start1":8157,"start2":8157,"length1":32,"length2":98}]}]},{"timestamp":1727524103209,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"Samples("],[-1,"6"],[1,"3"],[0,"000)\n   "]],"start1":8081,"start2":8081,"length1":17,"length2":17}]}]},{"timestamp":1727540973019,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ing\nlet "],[-1,"W"],[1,"w"],[0,"indow = "]],"start1":89,"start2":89,"length1":17,"length2":17},{"diffs":[[0,"pleGap, "],[-1,"W"],[1,"w"],[0,"indow, f"]],"start1":13447,"start2":13447,"length1":17,"length2":17},{"diffs":[[0,"tamp + ("],[-1,"W"],[1,"w"],[0,"indow * "]],"start1":13587,"start2":13587,"length1":17,"length2":17}]}]},{"timestamp":1727541010734,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"======\n\n"],[-1,"cons"],[1,"let simulating = isSimulating() // for debugging\nle"],[0,"t Window"]],"start1":36,"start2":36,"length1":20,"length2":67},{"diffs":[[0,"= 7\n"],[-1,"const S"],[1,"let s"],[0,"ampl"]],"start1":104,"start2":104,"length1":15,"length2":13},{"diffs":[[0,"p = "],[-1,"20\nconst T"],[1,"100\nlet t"],[0,"ooMa"]],"start1":120,"start2":120,"length1":18,"length2":17},{"diffs":[[0,"s = "],[-1,"5"],[1,"2"],[0,"00\n"],[-1,"let simulating = isSimulating() // for debugging\n"],[0,"let "]],"start1":145,"start2":145,"length1":61,"length2":12},{"diffs":[[0,"eStamp, "],[-1,"S"],[1,"s"],[0,"ampleGap"]],"start1":13436,"start2":13436,"length1":17,"length2":17},{"diffs":[[0,"indow * "],[-1,"S"],[1,"s"],[0,"ampleGap"]],"start1":13596,"start2":13596,"length1":17,"length2":17},{"diffs":[[0,"ength < "],[-1,"T"],[1,"t"],[0,"ooManySa"]],"start1":13755,"start2":13755,"length1":17,"length2":17},{"diffs":[[0,"meWas + "],[-1,"S"],[1,"s"],[0,"ampleGap"]],"start1":14232,"start2":14232,"length1":17,"length2":17}]}]},{"timestamp":1727541125943,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"amp,"],[-1," Window,"],[0," Sam"]],"start1":13444,"start2":13444,"length1":16,"length2":8},{"diffs":[[0,"mpleGap,"],[1," Window,"],[0," fresh)\n"]],"start1":13451,"start2":13451,"length1":16,"length2":24}]}]},{"timestamp":1727541851189,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," / this."],[-1,"la"],[1,"samplingGap"],[0,"\n       "]],"start1":2562,"start2":2562,"length1":18,"length2":27}]}]},{"timestamp":1727542664753,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," this.la"],[-1,"t"],[0,"\n       "]],"start1":2564,"start2":2564,"length1":17,"length2":16}]}]},{"timestamp":1727542666833,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"this.lat"],[-1,"ency"],[0,"\n       "]],"start1":2565,"start2":2565,"length1":20,"length2":16},{"diffs":[[0,"the "],[-1,"sextet"],[1,"triple"],[0," of "]],"start1":14857,"start2":14857,"length1":14,"length2":14},{"diffs":[[0,"veraged "],[-1,"sensor"],[1,"[X,Y,Z]"],[0," values "]],"start1":14872,"start2":14872,"length1":22,"length2":23}]}]},{"timestamp":1727543097656,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lt.push("],[-1,"("],[0,"keepOld "]],"start1":3097,"start2":3097,"length1":17,"length2":16}]}]},{"timestamp":1727544657900,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".averages[i]"],[-1,")"],[0,"\n           "]],"start1":3120,"start2":3120,"length1":25,"length2":24}]}]},{"timestamp":1727544660870,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"      + "],[-1,"("],[0,"boostLas"]],"start1":3144,"start2":3144,"length1":17,"length2":16},{"diffs":[[0,"astInputs[i]"],[-1,")"],[0,"\n           "]],"start1":3170,"start2":3170,"length1":25,"length2":24},{"diffs":[[0,"      + "],[-1,"("],[0,"addNew *"]],"start1":3193,"start2":3193,"length1":17,"length2":16},{"diffs":[[0,"lues[i])"],[-1,")"],[0,"\n       "]],"start1":3212,"start2":3212,"length1":17,"length2":16},{"diffs":[[0,"= []"],[-1," // [fx,fy,fz,gx,gy,gz] = Sampled magnetic field (f) and acceleration (g)"],[0,"\n   "]],"start1":12898,"start2":12898,"length1":81,"length2":8},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.X"]],"start1":13098,"start2":13098,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Y"]],"start1":13139,"start2":13139,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Z"]],"start1":13180,"start2":13180,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.X"]],"start1":13221,"start2":13221,"length1":36,"length2":37},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.Y"]],"start1":13263,"start2":13263,"length1":36,"length2":37},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.Z"]],"start1":13305,"start2":13305,"length1":36,"length2":37},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.X"]],"start1":14408,"start2":14408,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Y"]],"start1":14453,"start2":14453,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Z"]],"start1":14498,"start2":14498,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.X"]],"start1":14543,"start2":14543,"length1":36,"length2":37},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.Y"]],"start1":14589,"start2":14589,"length1":36,"length2":37},{"diffs":[[0,"      input."],[-1,"acceleration"],[1,"magneticForce"],[0,"(Dimension.Z"]],"start1":14635,"start2":14635,"length1":36,"length2":37}]}]},{"timestamp":1727544972071,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"}/** Function to analyse the scan-readings and derive the magnetometer scaling factors\n     * and the scan spin-axis in the XYZ sensor frame.\n     * \n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first \n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings and so derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     * \n     * NOTE: There is no guarantee that the spin-axis is truly vertical: the buggy may be operating \n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish their relationship, we need to call SetNorth() with the buggy at rest,\n    */\nfunction analyseScan() {\n    /* given the set of six [X,Y,Z] measurements:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n\n    ...and knowing that: \n            X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n    \n    ...we can (after some maths!) derive the calibration factors:\n            yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n            zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n    */\n\n    // First, collect the plane-crossings in each direction. \n    // Simultaneously, collect half-periods of rotation, which we will average.\n    let nCrossXY = 0\n    let nCrossYZ = 0\n    let nCrossZX = 0\n    let xStart = -1\n    let yStart = -1\n    let zStart = -1\n    let xFinish = 0\n    let yFinish = 0\n    let zFinish = 0\n    let x = scan[0].field.x\n    let y = scan[0].field.y\n    let z = scan[0].field.z\n    let xWas: number\n    let yWas: number\n    let zWas: number\n    // flags to inhibit clocking multiple jittery crossings \n    let needXY = true\n    let needYZ = true\n    let needZX = true\n    // we mostly use the squares of the zero-crossing components\n    let MM = 0\n    let NN = 0\n    let PP = 0\n    let QQ = 0\n    let RR = 0\n    let SS = 0\n    for (let i = 0; i < nSamples; i++) {\n        xWas = x\n        yWas = y\n        zWas = z\n        x = scan[i].field.x\n        y = scan[i].field.y\n        z = scan[i].field.z\n\n        // avoid any exact zeroes (they complicate comparisons!)\n        if (x == 0) x = xWas\n        if (y == 0) y = yWas\n        if (z == 0) z = zWas\n\n        // look for the first transition of each half-cycle\n        // (jitter or near-axis alignment may cause fluctuations)\n        if ((z * zWas < 0) && needXY) {\n            MM += x ** 2\n            NN += y ** 2\n            nCrossXY++\n            zFinish = scan[i].time\n            if (zStart < 0) zStart = zFinish\n            needXY = false\n            // got this axis-crossing, so now allow others\n            needYZ = true\n            needZX = true\n        }\n        if ((x * xWas < 0) && needYZ) {\n            PP += y ** 2\n            QQ += z ** 2\n            nCrossYZ++\n            xFinish = scan[i].time\n            if (xStart < 0) xStart = xFinish\n            needYZ = false\n            needXY = true\n            needZX = true\n        }\n        if ((y * yWas < 0) && needZX) {\n            RR += x ** 2\n            SS += z ** 2\n            nCrossZX++\n            yFinish = scan[i].time\n            if (yStart < 0) yStart = yFinish\n            needZX = false\n            needXY = true\n            needYZ = true\n        }\n    }\n    // average the crossing vectors\n    MM /= nCrossXY\n    NN /= nCrossXY\n    PP /= nCrossYZ\n    QQ /= nCrossYZ\n    RR /= nCrossZX\n    SS /= nCrossZX\n    // derive the average \"flip\" times (each making half a rotation)\n    let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n    let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n    let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n    // average and double them to get best period measure\n    scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n    // assemble the relative scaling factors\n    let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n    yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n    zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n    /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n    */\n    let M = Math.sqrt(MM)\n    let N = Math.sqrt(NN) * yScale\n    let P = Math.sqrt(PP) * yScale\n    let Q = Math.sqrt(QQ) * zScale\n    let R = Math.sqrt(RR)\n    let S = Math.sqrt(MM) * zScale\n\n    // since the crossings form a co-planar triangle in the Spin-Circle, we can take the \n    // cross-product of two edges to derive the orthogonal rotation-axis\n    let I = (Q * N) - (N * S) + (S * P)\n    let J = (R * Q) - (Q * M) + (M * S)\n    let K = (N * R) - (R * P) + (P * M)\n\n    down = new Vector(I, J, K)\n    down = down.normalised()\n\n    let check = 0 // debug point...\n}\n\n"],[0,"}\n\n/"]],"start1":17341,"start2":17341,"length1":5139,"length2":8}]}]},{"timestamp":1727625436002,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"point...\n}\n\n"],[1,"}\n\n"],[0,"// ========="]],"start1":22464,"start2":22464,"length1":24,"length2":27}]}]},{"timestamp":1727625444641,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n    }\n}"],[-1,"\n\n\n"],[0,"/** Func"]],"start1":17338,"start2":17338,"length1":19,"length2":16}]}]},{"timestamp":1727625469713,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"\nexport class Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n\nexport class Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n\n\n"],[0,"// ="]],"start1":7876,"start2":7876,"length1":593,"length2":8}]}]},{"timestamp":1727627686769,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n}\n\n\n"],[1,"export "],[0,"class Sa"]],"start1":7873,"start2":7873,"length1":16,"length2":23}]}]},{"timestamp":1727627691678,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"bugging\n"],[-1,"//"],[0,"let scan"]],"start1":150,"start2":150,"length1":18,"length2":16},{"diffs":[[0,"[] = []\n"],[-1,"//"],[0,"let scan"]],"start1":179,"start2":179,"length1":18,"length2":16},{"diffs":[[0," []\n"],[-1,"let scan: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\nlet nSamples: number\n\n"],[0,"\n\n\n/"]],"start1":213,"start2":213,"length1":115,"length2":8},{"diffs":[[0,"   }\n}\n\n"],[1,"export "],[0,"class Re"]],"start1":8088,"start2":8088,"length1":16,"length2":23},{"diffs":[[0,"    scan"],[1,"Data = []\n    scanTimes"],[0," = []\n  "]],"start1":8552,"start2":8552,"length1":16,"length2":39},{"diffs":[[0,"    let "],[-1,"updated"],[1,"fresh"],[0,": number"]],"start1":13456,"start2":13456,"length1":23,"length2":21},{"diffs":[[0,"= []"],[-1,"\n    let newSample: Sample // Sampled magnetic field and pose\n    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]"],[1," // [fx,fy,fz,gx,gy,gz] = Sampled magnetic field (f) and acceleration (g)"],[0,"\n   "]],"start1":13480,"start2":13480,"length1":223,"length2":81},{"diffs":[[0,"let "],[-1,"pose: N"],[1,"updated: n"],[0,"umbe"]],"start1":13562,"start2":13562,"length1":15,"length2":18},{"diffs":[[0," = ["],[-1,"\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z)]\n        "],[1,"]"],[0,"\n\n  "]],"start1":13583,"start2":13583,"length1":140,"length2":9},{"diffs":[[0,"   f"],[-1,"ield  ="],[1,"resh = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)"],[0,",\n  "]],"start1":13738,"start2":13738,"length1":15,"length2":141},{"diffs":[[0,"thed"],[-1,"Field = new Smoother(timeStamp, Window, SampleGap, field)\n    let smoothedPos"],[1,"Sampl"],[0,"e = "]],"start1":14065,"start2":14065,"length1":85,"length2":13},{"diffs":[[0,"ap, "],[-1,"pose"],[1,"fresh"],[0,")\n\n"],[-1,"\n"],[0,"    "]],"start1":14117,"start2":14117,"length1":16,"length2":16},{"diffs":[[0,"        "],[-1,"newField"],[1,"fresh"],[0," = [\n   "]],"start1":15039,"start2":15039,"length1":24,"length2":21},{"diffs":[[0,"mp, "],[-1,"newField"],[1,"fresh"],[0,")\n\n "]],"start1":15377,"start2":15377,"length1":16,"length2":13}]}]},{"timestamp":1727628290694,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,")]\n        \n"],[1,"\n"],[0,"    basic.pa"]],"start1":13930,"start2":13930,"length1":24,"length2":25},{"diffs":[[0,"        "],[-1,"let field: number[]"],[1,"newField"],[0," = [\n   "]],"start1":15338,"start2":15338,"length1":35,"length2":24},{"diffs":[[0,"n.Z)"],[-1,"]\n        let pose: Number[] = ["],[1,","],[0,"\n   "]],"start1":15491,"start2":15491,"length1":40,"length2":9},{"diffs":[[0,"mension.Z)]\n"],[-1,"\n"],[0,"        upda"]],"start1":15620,"start2":15620,"length1":25,"length2":24},{"diffs":[[0,"            "],[-1,"//"],[0,"scanData.pus"]],"start1":15878,"start2":15878,"length1":26,"length2":24},{"diffs":[[0,"        "],[-1,"//"],[0,"scanTime"]],"start1":15982,"start2":15982,"length1":18,"length2":16},{"diffs":[[0,"t   "],[-1,"\n            scan.push(newSample)"],[0,"    "]],"start1":16031,"start2":16031,"length1":41,"length2":8}]}]},{"timestamp":1727628921917,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gs\n\n        "],[1,"let "],[0,"field: numbe"]],"start1":15333,"start2":15333,"length1":24,"length2":28}]}]},{"timestamp":1727628977319,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gnetic field"],[1," and pose"],[0,"\n"],[-1,""],[0,"    let fiel"]],"start1":13607,"start2":13607,"length1":25,"length2":34},{"diffs":[[0,"Z)]\n"],[-1,"    /*\n"],[0,"    "]],"start1":13779,"start2":13779,"length1":15,"length2":8},{"diffs":[[0,"mension.Z)]\n"],[1,"        "],[0,"\n    basic.*"]],"start1":13921,"start2":13921,"length1":24,"length2":32},{"diffs":[[0,"  basic."],[-1,"*/"],[0,"pause(20"]],"start1":13944,"start2":13944,"length1":18,"length2":16},{"diffs":[[0,"    let "],[-1,"fieldSmoother"],[1,"smoothedField"],[0," = new S"]],"start1":14279,"start2":14279,"length1":29,"length2":29},{"diffs":[[0,"    let "],[-1,"poseS"],[1,"s"],[0,"moothe"],[-1,"r"],[1,"dPose"],[0," = new S"]],"start1":14353,"start2":14353,"length1":28,"length2":28},{"diffs":[[0,"    "],[-1,"smoothField = fieldSmoother.update(timeNow, field)\n\n       "],[1,"let"],[0," pos"]],"start1":15507,"start2":15507,"length1":67,"length2":11},{"diffs":[[0,"Z)]\n"],[1,"\n"],[0,"        "],[-1,"smoothPose = poseSmoother.update(timeNow,pose"],[1,"updated = smoothedSample.update(timeStamp, newField"],[0,")\n\n "]],"start1":15665,"start2":15665,"length1":61,"length2":68},{"diffs":[[0,"t   "],[-1,"]\n            newSample.time = timeNow\n            newSample.field = []"],[0,"\n   "]],"start1":16073,"start2":16073,"length1":79,"length2":8},{"diffs":[[0,"           \n"],[1,""],[0,"        }\n\n "]],"start1":16110,"start2":16110,"length1":24,"length2":24},{"diffs":[[0," \n        }\n"],[-1,"\n"],[0,"    }\n}\n\n\nfu"]],"start1":16120,"start2":16120,"length1":25,"length2":24}]}]},{"timestamp":1727629639020,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n\n    basic."],[1,"*/"],[0,"pause(200) /"]],"start1":13930,"start2":13930,"length1":24,"length2":26}]}]},{"timestamp":1727629639456,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"timeNow: number\n"],[1,"    let updated: number[] = []\n"],[0,"    let newSampl"]],"start1":13521,"start2":13521,"length1":32,"length2":63},{"diffs":[[0,"eld\n"],[-1,"\n    scan = [] // start with empty arrays"],[1,"    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n    /*\n    let pose: Number[] = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z)]\n"],[0,"\n   "]],"start1":13616,"start2":13616,"length1":49,"length2":319},{"diffs":[[0,"e()\n    "],[-1,"let "],[0,"field"],[-1,": number[] = ["],[1,"  =,"],[0,"\n       "]],"start1":14075,"start2":14075,"length1":39,"length2":25},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.X"]],"start1":14095,"start2":14095,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Y"]],"start1":14136,"start2":14136,"length1":37,"length2":36},{"diffs":[[0,"      input."],[-1,"magneticForce"],[1,"acceleration"],[0,"(Dimension.Z"]],"start1":14177,"start2":14177,"length1":37,"length2":36},{"diffs":[[0,"let "],[-1,"smooth: number[]"],[1,"poseSmoother = new Smoother(timeStamp, Window, SampleGap, pose)\n"],[0,"\n\n  "]],"start1":14347,"start2":14347,"length1":24,"length2":72},{"diffs":[[0,"&& (scan"],[1,"Times"],[0,".length "]],"start1":14686,"start2":14686,"length1":16,"length2":21},{"diffs":[[0,"   field"],[1,": number[]"],[0," = [\n   "]],"start1":15332,"start2":15332,"length1":16,"length2":26},{"diffs":[[0,"  smooth"],[1,"Field"],[0," = field"]],"start1":15499,"start2":15499,"length1":16,"length2":21},{"diffs":[[0,"field)\n\n"],[1,"        pose: Number[] = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z)]\n        smoothPose = poseSmoother.update(timeNow,pose)\n\n"],[0,"        "]],"start1":15545,"start2":15545,"length1":16,"length2":234},{"diffs":[[0,"d = "],[-1,"new Vector(smooth[0], smooth[1], smooth[2])"],[1,"[]"],[0,"\n   "]],"start1":16181,"start2":16181,"length1":51,"length2":10},{"diffs":[[0,"ng))\n}\n\n"],[-1,"\n/*\n"],[0,"function"]],"start1":17966,"start2":17966,"length1":20,"length2":16},{"diffs":[[0,"    }\n}\n"],[-1,"*/\n"],[0,"\n\n/** Fu"]],"start1":18408,"start2":18408,"length1":19,"length2":16}]}]},{"timestamp":1727629952059,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g))\n}\n\n\n"],[1,"/*"],[0,"\nfunctio"]],"start1":17438,"start2":17438,"length1":16,"length2":18}]}]},{"timestamp":1727693829464,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  )\n    }\n}\n"],[1,"*/"],[0,"\n\n\n/** Funct"]],"start1":17877,"start2":17877,"length1":24,"length2":26}]}]},{"timestamp":1727693833144,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"/ store the "],[1,"sextet of "],[0,"averaged fie"]],"start1":15322,"start2":15322,"length1":24,"length2":34},{"diffs":[[0,"veraged "],[-1,"field"],[1,"sensor"],[0," values "]],"start1":15345,"start2":15345,"length1":21,"length2":22},{"diffs":[[0,"deep copy!)\n"],[1,"            //scanData.push([updated[0], updated[1], updated[2], updated[3], updated[4], updated[5]])\n            //scanTimes.push(timeStamp)  // timestamp it   ]\n            newSample.time = timeNow\n"],[0,"            "]],"start1":15373,"start2":15373,"length1":24,"length2":224},{"diffs":[[0,"2])\n"],[-1,"            newSample.time = timeNow  // timestamp it  \n"],[0,"    "]],"start1":15655,"start2":15655,"length1":64,"length2":8},{"diffs":[[0,"           \n"],[-1,""],[0,"        }\n  "]],"start1":15691,"start2":15691,"length1":24,"length2":24},{"diffs":[[0," \n        }\n"],[1,"\n"],[0,"    }\n}\n\n\nfu"]],"start1":15701,"start2":15701,"length1":24,"length2":25},{"diffs":[[0," 0; i < scan"],[1,"Times"],[0,".length; i++"]],"start1":17485,"start2":17485,"length1":24,"length2":29},{"diffs":[[0,".length; i++) {\n"],[-1,""],[0,"        datalogg"]],"start1":17502,"start2":17502,"length1":32,"length2":32},{"diffs":[[0,"V(\"fx\", scan"],[-1,"[i].field.x"],[1,"Data[i][0]"],[0,"),\n         "]],"start1":17572,"start2":17572,"length1":35,"length2":34},{"diffs":[[0,"y\", scan"],[-1,"[i].field.x"],[1,"Data[i][1]),\n            datalogger.createCV(\"fz\", scanData[i][2]),\n            datalogger.createCV(\"gx\", scanData[i][3]"],[0,"),\n     "]],"start1":17631,"start2":17631,"length1":27,"length2":136},{"diffs":[[0,"CV(\""],[-1,"fz"],[1,"gy"],[0,"\", scan"],[-1,"[i].field.x)"],[1,"Data[i][4]),\n            datalogger.createCV(\"gz\", scanData[i][5])\n        "],[0,")\n  "]],"start1":17791,"start2":17791,"length1":29,"length2":92}]}]},{"timestamp":1727694261141,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n\n\n"],[-1,"export function scanClockwise2(ms: number): number {\n}\n\n\n"],[0,"func"]],"start1":15564,"start2":15564,"length1":65,"length2":8}]}]},{"timestamp":1727695716845,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n}\n\n\n"],[-1,"    "],[0,"export f"]],"start1":15560,"start2":15560,"length1":20,"length2":16},{"diffs":[[0,"umber {\n"],[-1,"    "],[0,"}\n\n\nfunc"]],"start1":15613,"start2":15613,"length1":20,"length2":16}]}]},{"timestamp":1727695719832,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s = 500\n"],[-1,"\n\n"],[0,"let simu"]],"start1":101,"start2":101,"length1":18,"length2":16},{"diffs":[[0,"r\n\n\n"],[-1,"let strength = 0 // the average magnetic field-strength observed by the magnetometer\nlet scanPeriod = -1 // average scanning rotation time\n\n// amplitudes and central offsets of sinusoidal scan-readings in each dimension\nlet swing: Vector\nlet offset: Vector\nlet xOff: number\nlet yOff: number\nlet zOff: number\n// sensitivity adjustment factors that will match Y & Z readings to X readings\nlet yScale: number\nlet zScale: number\n\n// Sensor Measurements\nlet down: Vector // buggy's Down axis (fixed, dependent on mounting)\nlet magnet: Vector // current magnetic field\nlet gravityXYZ: Vector // starting orientation of the buggy\nl//et northXYZ: Vector // starting field of the buggy\nlet startXYZ: Reading // starting field and pose of the buggy (deemed north and upright)\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy's [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // combination of the above two rotations\n\n"],[0,"\n\n//"]],"start1":325,"start2":325,"length1":1059,"length2":8},{"diffs":[[0,"}\n\n\n"],[-1,"function scanClockwise2(ms: number): number {\n    strength = -1\n    scanPeriod = -1\n\n    // unless data has already been pre-loaded into scan[]...\n    if (!debugMode) collectSamples(ms)  // ...take repeated magnetometer readings\n\n    nSamples = scan.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanTime = scan[nSamples - 1].time = scan[0].time\n    if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // The first pass finds the ranges for each axis \n    let xlo = 9999999\n    let ylo = 9999999\n    let zlo = 9999999\n    let xhi = -9999999\n    let yhi = -9999999\n    let zhi = -9999999\n    for (let i = 0; i < nSamples; i++) {\n        xhi = Math.max(xhi, scan[i].field.x)\n        yhi = Math.max(yhi, scan[i].field.x)\n        zhi = Math.max(zhi, scan[i].field.y)\n        xlo = Math.min(xlo, scan[i].field.y)\n        ylo = Math.min(ylo, scan[i].field.z)\n        zlo = Math.min(zlo, scan[i].field.z)\n    }\n\n    // get RMS field-strength\n    xField = (xhi - xlo) / 2\n    yField = (yhi - ylo) / 2\n    zField = (zhi - zlo) / 2\n    strength = Math.sqrt((xField * xField) + (yField * yField) + (zField * zField))\n\n    // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n    // The means of the extremes give a good approximation to the central offsets.\n    xOff = (xhi + xlo) / 2\n    yOff = (yhi + ylo) / 2\n    zOff = (zhi + zlo) / 2\n\n    // 2nd pass re-centres all the scanData samples, eliminating \"hard-iron\" environmental magnetic effects.\n    for (let i = 0; i < nSamples; i++) {\n        scan[i].field.x -= xOff\n        scan[i].field.y -= yOff\n        scan[i].field.z -= zOff\n    }\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < nSamples; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n    */\n\n    return 0\n}\n\n"],[1,"    export function scanClockwise2(ms: number): number {\n    }"],[0,"\n\n\nf"]],"start1":15564,"start2":15564,"length1":2432,"length2":70},{"diffs":[[0,") {\n    "],[-1,"magnet"],[1,"field"],[0," = corre"]],"start1":16206,"start2":16206,"length1":22,"length2":21},{"diffs":[[0,"V(\"fx\", "],[-1,"magnet"],[1,"field"],[0,".x),\n   "]],"start1":16367,"start2":16367,"length1":22,"length2":21},{"diffs":[[0,"V(\"fy\", "],[-1,"magnet"],[1,"field"],[0,".y),\n   "]],"start1":16411,"start2":16411,"length1":22,"length2":21},{"diffs":[[0,"V(\"fz\", "],[-1,"magnet"],[1,"field"],[0,".z),\n   "]],"start1":16455,"start2":16455,"length1":22,"length2":21},{"diffs":[[0,"oVector("],[-1,"magnet"],[1,"field"],[0,")\n    gr"]],"start1":16734,"start2":16734,"length1":22,"length2":21}]}]},{"timestamp":1727696316138,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nst "],[-1,"EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n"],[1,"TooManySamples = 500"],[0,"\n\n\nl"]],"start1":84,"start2":84,"length1":353,"length2":28},{"diffs":[[0,"e buggy\n"],[1,"l"],[0,"//"],[-1,"l"],[0,"et north"]],"start1":946,"start2":946,"length1":19,"length2":19},{"diffs":[[0,"    "],[-1,"let result = scanClockwise(6000)\n    if (result != 0) {\n        basic.showNumber(result)\n    } else {\n    "],[1,"collectSamples(6000)\n"],[0,"    "]],"start1":9789,"start2":9789,"length1":114,"length2":29},{"diffs":[[0,"es.Yes)\n"],[-1,"    }\n"],[0,"    paus"]],"start1":9840,"start2":9840,"length1":22,"length2":16},{"diffs":[[0,"e(1000)\n"],[-1,"\n"],[0,"    basi"]],"start1":9856,"start2":9856,"length1":17,"length2":16},{"diffs":[[0,"lockwise"],[1,"2"],[0,"(ms: num"]],"start1":16635,"start2":16635,"length1":16,"length2":17},{"diffs":[[0,"]...\n   "],[-1," //"],[0," if (!de"]],"start1":16763,"start2":16763,"length1":19,"length2":16},{"diffs":[[0,"ugMode) "],[-1,"\n    "],[0,"collectS"]],"start1":16780,"start2":16780,"length1":21,"length2":16},{"diffs":[[0,"gth\n    "],[-1,"swing.x"],[1,"xField"],[0," = (xhi "]],"start1":17856,"start2":17856,"length1":23,"length2":22},{"diffs":[[0,"/ 2\n    "],[-1,"swing.y"],[1,"yField"],[0," = (yhi "]],"start1":17885,"start2":17885,"length1":23,"length2":22},{"diffs":[[0,"/ 2\n    "],[-1,"swing.z"],[1,"zField"],[0," = (zhi "]],"start1":17914,"start2":17914,"length1":23,"length2":22},{"diffs":[[0,"rt(("],[-1,"swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x"],[1,"xField * xField) + (yField * yField) + (zField * zField"],[0,"))\n\n"]],"start1":17969,"start2":17969,"length1":69,"length2":63}]}]},{"timestamp":1727696899714,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"er\": \"*\""],[1,",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\""],[0,"\n    },\n"]],"start1":156,"start2":156,"length1":16,"length2":77}]}]},{"timestamp":1727696966141,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"======\n\n"],[1,"/"],[0,"/ sample"]],"start1":10701,"start2":10701,"length1":16,"length2":17}]}]},{"timestamp":1727704467648,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"=====\n\n/"],[-1,"*"],[0," sample "]],"start1":10702,"start2":10702,"length1":17,"length2":16}]}]},{"timestamp":1727704468647,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"zMag\n\n}\n"],[-1,"*/\n"],[0,"\n\nfuncti"]],"start1":13716,"start2":13716,"length1":19,"length2":16},{"diffs":[[0,"ge.\n"],[-1,"    // counts of zero-crossings detected in this scan\n"],[0,"    "]],"start1":23099,"start2":23099,"length1":62,"length2":8},{"diffs":[[0,"= 0\n"],[-1,"    // time-stamp of first\n"],[0,"    "]],"start1":23162,"start2":23162,"length1":35,"length2":8},{"diffs":[[0,"   // we"],[-1,"'ll"],[0," mostly "]],"start1":23561,"start2":23561,"length1":19,"length2":16},{"diffs":[[0,"ycle"],[-1," where the signs differ"],[0,"\n   "]],"start1":24100,"start2":24100,"length1":31,"length2":8},{"diffs":[[0,"y cause "],[-1,"repeated "],[0,"fluctuat"]],"start1":24149,"start2":24149,"length1":25,"length2":16},{"diffs":[[0,"ions"],[-1," which we ignore)\n"],[1,")"],[0,"\n   "]],"start1":24165,"start2":24165,"length1":26,"length2":9},{"diffs":[[0,"Y) {"],[-1," // z flips when crossing the XY plane"],[0,"\n   "]],"start1":24206,"start2":24206,"length1":46,"length2":8},{"diffs":[[0,"nish"],[-1," // start the clock..."],[0,"\n   "]],"start1":24359,"start2":24359,"length1":30,"length2":8},{"diffs":[[0," so now "],[-1,"only "],[0,"allow ot"]],"start1":24429,"start2":24429,"length1":21,"length2":16},{"diffs":[[0,"hers"],[-1," to be detected"],[0,"\n   "]],"start1":24445,"start2":24445,"length1":23,"length2":8}]}]},{"timestamp":1727705067087,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"rements\nlet down"],[-1,"XYZ"],[0,": Vector // bugg"]],"start1":1097,"start2":1097,"length1":35,"length2":32},{"diffs":[[0,"     // "],[-1,"L"],[1,"l"],[0,"ook for "]],"start1":24135,"start2":24135,"length1":17,"length2":17},{"diffs":[[0,"ycle"],[-1," (i.e."],[0," whe"]],"start1":24187,"start2":24187,"length1":14,"length2":8},{"diffs":[[0,"sign"],[-1," flips)"],[1,"s differ"],[0,"\n   "]],"start1":24202,"start2":24202,"length1":15,"length2":16},{"diffs":[[0,"tuations"],[-1,","],[0," which w"]],"start1":24280,"start2":24280,"length1":17,"length2":16},{"diffs":[[0," // "],[-1,"sign of z value"],[1,"z"],[0," fli"]],"start1":24346,"start2":24346,"length1":23,"length2":9},{"diffs":[[0,"Z) {"],[-1," // sign of x value flips when crossing the YZ plane"],[0,"\n   "]],"start1":24763,"start2":24763,"length1":60,"length2":8},{"diffs":[[0,"X) {"],[-1," // sign of y value flips when crossing the ZX plane"],[0,"\n   "]],"start1":25045,"start2":25045,"length1":60,"length2":8},{"diffs":[[0,"the "],[-1,"squared "],[0,"cros"]],"start1":25313,"start2":25313,"length1":16,"length2":8},{"diffs":[[0,"rossing "],[-1,"point"],[1,"vector"],[0,"s\n    MM"]],"start1":25318,"start2":25318,"length1":21,"length2":22},{"diffs":[[0,"CrossXY\n"],[-1,"\n"],[0,"    PP /"]],"start1":25364,"start2":25364,"length1":17,"length2":16},{"diffs":[[0,"CrossYZ\n"],[-1,"\n"],[0,"    RR /"]],"start1":25402,"start2":25402,"length1":17,"length2":16},{"diffs":[[0,"CrossZX\n"],[-1,"\n"],[0,"    // d"]],"start1":25440,"start2":25440,"length1":17,"length2":16},{"diffs":[[0,"age "],[-1,"the three half-periods, then"],[1,"and"],[0," dou"]],"start1":25685,"start2":25685,"length1":36,"length2":11},{"diffs":[[0,"get "],[-1,"our "],[0,"best "],[1,"period "],[0,"measure"],[-1," for full period"],[0,"\n   "]],"start1":25708,"start2":25708,"length1":40,"length2":27},{"diffs":[[0,"\n    // "],[-1,"construct"],[1,"assemble"],[0," the rel"]],"start1":25779,"start2":25779,"length1":25,"length2":24},{"diffs":[[0,"lane\n    */\n"],[-1,"\n"],[0,"    let M = "]],"start1":26235,"start2":26235,"length1":25,"length2":24},{"diffs":[[0,"the "],[-1,"three "],[0,"crossing"],[-1,"-point"],[0,"s fo"]],"start1":26453,"start2":26453,"length1":28,"length2":16},{"diffs":[[0,"riangle "],[-1,"lying "],[0,"in the S"]],"start1":26485,"start2":26485,"length1":22,"length2":16},{"diffs":[[0,"duct of "],[-1,"any "],[0,"two edge"]],"start1":26546,"start2":26546,"length1":20,"length2":16},{"diffs":[[0,"    down"],[-1,"XYZ"],[0," = new V"]],"start1":26724,"start2":26724,"length1":19,"length2":16},{"diffs":[[0,"down"],[-1,"XYZ"],[0," = down"],[-1,"XYZ"],[0,".nor"]],"start1":26759,"start2":26759,"length1":21,"length2":15}]}]},{"timestamp":1727705665889,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t magnet"],[-1,"XYZ"],[0,": Vector"]],"start1":1179,"start2":1179,"length1":19,"length2":16},{"diffs":[[0,"c field\n"],[1,""],[0,"let grav"]],"start1":1214,"start2":1214,"length1":16,"length2":16},{"diffs":[[0,"ght)"],[-1,"\nlet northXYZ: Vector"],[0,"\n\n//"]],"start1":1420,"start2":1420,"length1":29,"length2":8},{"diffs":[[0," // "],[-1,"sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number"],[1,"combination of the above two rotations\n"],[0,"\n\n\n/"]],"start1":1666,"start2":1666,"length1":168,"length2":47},{"diffs":[[0,"))\n\n    "],[1,"f"],[0,"ro"],[-1,"tate"],[1,"m"],[0,"XYZtoENG"]],"start1":19971,"start2":19971,"length1":22,"length2":20},{"diffs":[[0,"  magnet"],[-1,"XYZ"],[0," = corre"]],"start1":20066,"start2":20066,"length1":19,"length2":16},{"diffs":[[0,", magnet"],[-1,"XYZ"],[0,".x),\n   "]],"start1":20228,"start2":20228,"length1":19,"length2":16},{"diffs":[[0,", magnet"],[-1,"XYZ"],[0,".y),\n   "]],"start1":20273,"start2":20273,"length1":19,"length2":16},{"diffs":[[0,", magnet"],[-1,"XYZ"],[0,".z),\n   "]],"start1":20318,"start2":20318,"length1":19,"length2":16},{"diffs":[[0," fieldENG = "],[1,"f"],[0,"ro"],[-1,"tate"],[1,"m"],[0,"XYZtoENG.app"]],"start1":20559,"start2":20559,"length1":30,"length2":28},{"diffs":[[0,"r(magnet"],[-1,"XYZ"],[0,")\n    gr"]],"start1":20598,"start2":20598,"length1":19,"length2":16},{"diffs":[[0,"tyENG = "],[1,"f"],[0,"ro"],[-1,"tate"],[1,"m"],[0,"XYZtoENG"]],"start1":20617,"start2":20617,"length1":22,"length2":20},{"diffs":[[0,"y)\n*\n*/\n"],[1,"let northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n"],[0,"// await"]],"start1":28267,"start2":28267,"length1":16,"length2":217}]}]},{"timestamp":1727706041743,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"function characteriseSensors() {\n    let myName = control.deviceName()\n    if (myName == \"zapop\"){\n        1042.89, 1007.23, 992.73, -70.92, 44.597, 6.804, 1.051, 1.015\n    }\n    if (myName == \"gateg\") {\n\n    }\n    if (myName == \"gigav\") {\n\n    }\n    if (myName == \"zavov\") {\n\n    }\n    zazop, 1042.89, 1007.23, 992.73, -70.92, 44.597, 6.804, 1.051, 1.015\n    gateg, 1017.578, 996.736, 1026.315, -25.411, -3.251, -1.300, 0.992, 0.971\n    gigav, 1057.89, 1023.98, 1074.06, -85.33, 7.22, -18.94, 0.98, 0.95\n    zavov, 1049.285, 1059.746, 986.272, -74.082, 8.455, -7.617, 1.064, 1.074\n}\n\n"],[0,"// ="]],"start1":27194,"start2":27194,"length1":593,"length2":8}]}]},{"timestamp":1727706566052,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"/ field "],[-1,"re-"],[0,"scaling "]],"start1":2003,"start2":2003,"length1":19,"length2":16},{"diffs":[[0,"rs\nlet f"],[-1,"y"],[1,"x"],[0,"Scale: n"]],"start1":2024,"start2":2024,"length1":17,"length2":17},{"diffs":[[0,"mber"],[-1," // = fyMag / fxMag\nlet fzScale: number // = fzMag / fxMag\n\n// gravity (or pose) sensor"],[1,"\nlet fyScale: number\nlet fzScale: number\n\n// gravity"],[0," off"]],"start1":2042,"start2":2042,"length1":95,"length2":60},{"diffs":[[0,"ity "],[-1,"re-"],[0,"scal"],[-1,"ing"],[1,"e"],[0," fac"]],"start1":2244,"start2":2244,"length1":18,"length2":13},{"diffs":[[0,"rs\nlet g"],[-1,"y"],[1,"x"],[0,"Scale: n"]],"start1":2259,"start2":2259,"length1":17,"length2":17},{"diffs":[[0,"mber"],[-1," // = gyMag / gxMag"],[1,"\nlet gyScale: number"],[0,"\nlet"]],"start1":2277,"start2":2277,"length1":27,"length2":28},{"diffs":[[0,"mber"],[-1," // = gzMag / gxMag"],[0,"\n\n//"]],"start1":2317,"start2":2317,"length1":27,"length2":8}]}]},{"timestamp":1727707041017,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"rise"],[-1,"Accelerometer"],[1,"Sensors"],[0,"() {"]],"start1":27276,"start2":27276,"length1":21,"length2":15},{"diffs":[[0,"    "],[-1,"gxMag = 1042.89\n        gyMag = 1007.23\n        gzMag =  992.73\n        gxOff = -70.92\n        gyOff = 44.597\n        gzOff = 6.804      "],[1,"1042.89, 1007.23, 992.73, -70.92, 44.597, 6.804, 1.051, 1.015"],[0,"\n   "]],"start1":27362,"start2":27362,"length1":145,"length2":69},{"diffs":[[0,") {\n"],[1,"\n"],[0,"    "],[1,"}\n"],[0,"    "],[-1,"gxMag = 1017.578"],[1,"if (myName == \"gigav\") {\n"],[0,"\n    "],[1,"}\n"],[0,"    "],[-1,"gyMag = 996.736"],[1,"if (myName == \"zavov\") {\n"],[0,"\n    "],[1,"}\n"],[0,"    "],[-1,"gzMag = 1026.315\n        gxOff = -25.411\n        gyOff = -3.251\n        gzOff = -1.300\n    }\n    if (myName == \"gigav\") {\n        gxMag = 1057.89\n        gyMag = 1023.98\n        gzMag = 1074.06\n        gxOff = -85.33\n        gyOff = 7.22\n        gzOff = -18.94\n    }\n    if (myName == \"zavov\") {\n        gxMag = 1049.285\n        gyMag = 1059.746\n        gzMag = 986.272\n        gxOff = -74.082\n        gyOff = 44.597\n        gzOff = 6.804\n"],[1,"zazop, 1042.89, 1007.23, 992.73, -70.92, 44.597, 6.804, 1.051, 1.015\n    gateg, 1017.578, 996.736, 1026.315, -25.411, -3.251, -1.300, 0.992, 0.971\n    gigav, 1057.89, 1023.98, 1074.06, -85.33, 7.22, -18.94, 0.98, 0.95\n    zavov, "],[0,"1049"]],"start1":27459,"start2":27459,"length1":504,"length2":320},{"diffs":[[0," -7.617,"],[-1,"\n    }\n"],[1," 1.064, 1.074\n}"],[0,"\n\n// ==="]],"start1":27819,"start2":27819,"length1":23,"length2":31}]}]},{"timestamp":1727707631146,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ggy\n"],[-1,"let northXYZ: Vector\n"],[0,"let "]],"start1":1335,"start2":1335,"length1":29,"length2":8},{"diffs":[[0,"upright)"],[1,"\nlet northXYZ: Vector"],[0,"\n\n// re-"]],"start1":1419,"start2":1419,"length1":16,"length2":37},{"diffs":[[0,"// buggy"],[1,"'s"],[0," [Right,"]],"start1":1593,"start2":1593,"length1":16,"length2":18},{"diffs":[[0,"======\n\n"],[1,"\n"],[0,"/*"],[1,"  "],[0," A Smoot"]],"start1":2462,"start2":2462,"length1":18,"length2":21},{"diffs":[[0,"es.\n    "],[1," "],[0,"It is us"]],"start1":2566,"start2":2566,"length1":16,"length2":17},{"diffs":[[0,"ometer.\n"],[1," "],[0,"    Timi"]],"start1":2651,"start2":2651,"length1":16,"length2":17},{"diffs":[[0,"hs.\n"],[1," "],[0,"    The "],[-1,"number of"],[1,"expected gap between"],[0," rea"]],"start1":2745,"start2":2745,"length1":25,"length2":37},{"diffs":[[0,"ngs "],[-1,"to be "],[1,"("],[0,"average"],[-1,"d (window) and expected gap between readings (samplingGap)\n    together set"],[1,"Period) governs the blend of new and old readings \n     and therefore"],[0," the"]],"start1":2784,"start2":2784,"length1":96,"length2":85},{"diffs":[[0,"cess"],[-1,"\n    and govern the blending of new and old readings"],[0,".\n  "]],"start1":2931,"start2":2931,"length1":60,"length2":8},{"diffs":[[0,"ed readings\n"],[-1,""],[0,"    latency:"]],"start1":3173,"start2":3173,"length1":24,"length2":24},{"diffs":[[0,"scratch\n"],[1,"\n"],[0,"    last"]],"start1":3267,"start2":3267,"length1":16,"length2":17},{"diffs":[[0,"are "],[-1,"aligned, or "],[0,"~180"]],"start1":7673,"start2":7673,"length1":20,"length2":8},{"diffs":[[0,"f = "],[-1,"8.455"],[1,"44.597"],[0,"\n   "]],"start1":28008,"start2":28008,"length1":13,"length2":14},{"diffs":[[0,"ff ="],[1," 6.804\n1049.285, 1059.746, 986.272, -74.082, 8.455,"],[0," -7.617"],[1,","],[0,"\n   "]],"start1":28030,"start2":28030,"length1":15,"length2":67}]}]},{"timestamp":1727708206566,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer"],[1,"\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n"],[0,"\ncla"]],"start1":9629,"start2":9629,"length1":122,"length2":223},{"diffs":[[0,"\n}\n\n"],[-1,"// a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n"],[0,"\n\n//"]],"start1":10198,"start2":10198,"length1":318,"length2":8},{"diffs":[[0,"(0) - fxOff)"],[1," * fxScale"],[0,"\n        rea"]],"start1":14218,"start2":14218,"length1":24,"length2":34},{"diffs":[[0,"- gxOff)"],[1," * gxScale"],[0,"\n       "]],"start1":14630,"start2":14630,"length1":16,"length2":26},{"diffs":[[0,"xis "],[-1,"(measured "],[0,"in t"]],"start1":21878,"start2":21878,"length1":18,"length2":8},{"diffs":[[0,"or frame"],[-1,")"],[0,".\n     *"]],"start1":21897,"start2":21897,"length1":17,"length2":16},{"diffs":[[0,"7\n    }\n"],[-1,"}"],[0,"\n\n// ==="]],"start1":28094,"start2":28094,"length1":17,"length2":16}]}]},{"timestamp":1727708797226,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ngs "],[-1,"before using them t"],[1,"and s"],[0,"o de"]],"start1":22438,"start2":22438,"length1":27,"length2":13},{"diffs":[[0,"blish th"],[-1,"is"],[1,"eir"],[0," relatio"]],"start1":22800,"start2":22800,"length1":18,"length2":19},{"diffs":[[0," we "],[-1,"will need (later)"],[1,"need"],[0," to "]],"start1":22825,"start2":22825,"length1":25,"length2":12},{"diffs":[[0,"tors"],[-1," (relative to x)"],[0,":\n  "]],"start1":23293,"start2":23293,"length1":24,"length2":8},{"diffs":[[0,"/= nCrossXY\n"],[1,"\n"],[0,"    PP /= nC"]],"start1":25976,"start2":25976,"length1":24,"length2":25},{"diffs":[[0,"/= nCrossYZ\n"],[1,"\n"],[0,"    RR /= nC"]],"start1":26015,"start2":26015,"length1":24,"length2":25},{"diffs":[[0,"\n    */\n"],[1,"\n"],[0,"    let "]],"start1":26897,"start2":26897,"length1":16,"length2":17},{"diffs":[[0,"n-Circle"],[-1," plane"],[0,", we can"]],"start1":27180,"start2":27180,"length1":22,"length2":16}]}]},{"timestamp":1727709071474,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"se(1000)"],[-1,"\n    "],[0,"\n\n    ba"]],"start1":10744,"start2":10744,"length1":21,"length2":16}]}]},{"timestamp":1727763323100,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"    basic.showString(\"S\")\n        pause(1000)\n        basic.clearScreen()\n    "],[0,"}\n  "]],"start1":10731,"start2":10731,"length1":86,"length2":8},{"diffs":[[0,"e(1000)\n"],[1,"    "],[0,"\n\n    ba"]],"start1":10745,"start2":10745,"length1":16,"length2":20}]}]},{"timestamp":1727763342795,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"pause(1000)\n        basic.showString(\"A\")\n        pause(1000)\n        analyseScan()\n        basic.showIcon(IconNames.Yes"],[1,"basic.showString(\"S\""],[0,")\n  "]],"start1":10735,"start2":10735,"length1":128,"length2":28},{"diffs":[[0,"creen()\n"],[-1,""],[0,"    }\n"],[1,"    pause(1000)\n\n\n    basic.clearScreen()\n"],[0,"})\n\ninpu"]],"start1":10801,"start2":10801,"length1":22,"length2":64}]}]},{"timestamp":1727763454728,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"pScan()\n"],[-1,"    \n"],[0,"    basi"]],"start1":11037,"start2":11037,"length1":21,"length2":16}]}]},{"timestamp":1727764130780,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n()\n    "],[-1,"dum"],[0,"\n    bas"]],"start1":11041,"start2":11041,"length1":19,"length2":16}]}]},{"timestamp":1727764132825,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    pause(1000)\n"],[-1,"\n"],[0,"        basic.sh"]],"start1":10735,"start2":10735,"length1":33,"length2":32},{"diffs":[[0,"String(\""],[-1,"D"],[1,"A"],[0,"\")\n     "]],"start1":10769,"start2":10769,"length1":17,"length2":17},{"diffs":[[0,"    "],[-1,"dumpScan()\n        basic.showIcon(IconNames.Yes)\n        pause(1000)\n\n        basic.showString(\"A\")\n        analyseScan()\n        dumpAnalysis"],[1,"pause(1000)\n        analyseScan"],[0,"()\n "]],"start1":10785,"start2":10785,"length1":150,"length2":39},{"diffs":[[0,"tion"],[-1," "],[0,"() {\n"],[-1,"    if (ready) {\n        heading = takeBearing()\n        basic.showNumber(heading)\n    } else {\n        \n    }\n"],[0,"    "]],"start1":10955,"start2":10955,"length1":125,"length2":13},{"diffs":[[0,"String(\""],[-1,"N"],[1,"D"],[0,"\")\n    p"]],"start1":10978,"start2":10978,"length1":17,"length2":17},{"diffs":[[0,"earScreen()\n"],[1,"    dumpScan()\n    dum\n"],[0,"    basic.sh"]],"start1":11018,"start2":11018,"length1":24,"length2":47},{"diffs":[[0,"xis)\n   "],[-1," //"],[0," analyse"]],"start1":19826,"start2":19826,"length1":19,"length2":16}]}]},{"timestamp":1727764729544,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"[]\n\n"],[-1,"let ready = false // ready for action!\n\n"],[0,"// ="]],"start1":2418,"start2":2418,"length1":48,"length2":8},{"diffs":[[0,") {\n"],[-1,"    ready = false\n"],[0,"    "]],"start1":10503,"start2":10503,"length1":26,"length2":8},{"diffs":[[0," else {\n        "],[1,"\n    }\n    "],[0,"basic.showString"]],"start1":11165,"start2":11165,"length1":32,"length2":43},{"diffs":[[0,"    "],[-1,"    setNorth()\n    "],[1,"pause(1000)\n    basic.clearScreen()\n    basic.showIcon(IconNames.Yes)\n"],[0,"    "]],"start1":11214,"start2":11214,"length1":27,"length2":78},{"diffs":[[0,"    pause(1000)\n"],[-1,"    "],[0,"    basic.clearS"]],"start1":11288,"start2":11288,"length1":36,"length2":32},{"diffs":[[0,"n()\n"],[-1,"        ready = true\n    }\n"],[0,"})\n\n"]],"start1":11324,"start2":11324,"length1":35,"length2":8},{"diffs":[[0,"  }\n}\n\n\n"],[1,"\n"],[0,"/** Func"]],"start1":22295,"start2":22295,"length1":16,"length2":17},{"diffs":[[0,"\n}\n\n"],[-1,"function dumpAnalysis() {\n    datalogger.log(\n        datalogger.createCV(\"yScale\", yScale),\n        datalogger.createCV(\"zScale\", zScale),\n        datalogger.createCV(\"downX\", downXYZ.x),\n        datalogger.createCV(\"downY\", downXYZ.y),\n        datalogger.createCV(\"downZ\", downXYZ.z))\n}\n\nfunction setNorth() {\n    // take single reading as \n\n}\n\nfunction takeBearing(): number {\n    return 333\n}\n\n"],[0,"func"]],"start1":27904,"start2":27904,"length1":406,"length2":8}]}]},{"timestamp":1727765329253,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"\n        datalogger.log(\n            datalogger.createCV(\"yScale\", yScale),\n            datalogger.createCV(\"zScale\", zScale),\n            datalogger.createCV(\"downX\", downXYZ.x),\n            datalogger.createCV(\"downY\", downXYZ.y),\n            datalogger.createCV(\"downZ\", downXYZ.z))\n"],[1,"dumpAnalysis()"],[0,"\n   "]],"start1":10974,"start2":10974,"length1":294,"length2":22},{"diffs":[[0,"correct() {\n"],[1,"    // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n"],[0,"}\n\nfunction "]],"start1":20322,"start2":20322,"length1":24,"length2":558},{"diffs":[[0,") {\n"],[-1,"}\n\nfunction setNorth() { // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z"],[1,"    datalogger.log(\n        datalogger.createCV(\"yScale\", yScale),\n        datalogger.createCV(\"zScale\", zScale"],[0,"),\n "]],"start1":27956,"start2":27956,"length1":354,"length2":119},{"diffs":[[0,"ogger.createCV(\""],[-1,"gx"],[1,"downX"],[0,"\", downXYZ.x),\n "]],"start1":28087,"start2":28087,"length1":34,"length2":37},{"diffs":[[0,"ogger.createCV(\""],[-1,"gy"],[1,"downY"],[0,"\", downXYZ.y),\n "]],"start1":28136,"start2":28136,"length1":34,"length2":37},{"diffs":[[0,"CV(\""],[-1,"gz\", downXYZ.z))\n\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction takeBearing(): number {\n    // take single reading as magnetXYZ"],[1,"downZ\", downXYZ.z))\n}\n\nfunction setNorth() {\n    // take single reading as \n\n}\n\nfunction takeBearing(): number {"],[0,"\n   "]],"start1":28197,"start2":28197,"length1":168,"length2":120}]}]},{"timestamp":1727765549330,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"alyseScan()\n"],[1,"        "],[0,"\n        dat"]],"start1":10958,"start2":10958,"length1":24,"length2":32},{"diffs":[[0,"point...\n}\n\n"],[1,"function dumpAnalysis() {\n}\n"],[0,"\nfunction se"]],"start1":27660,"start2":27660,"length1":24,"length2":52}]}]},{"timestamp":1727766909936,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"point...\n}\n\n"],[1,"\n"],[0,"function set"]],"start1":27652,"start2":27652,"length1":24,"length2":25}]}]},{"timestamp":1727766911233,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gnetXYZ\n"],[-1,"    \n"],[0,"    retu"]],"start1":28284,"start2":28284,"length1":21,"length2":16}]}]},{"timestamp":1727774120799,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"XYZ\n    "],[-1,"for "],[0,"\n    ret"]],"start1":28288,"start2":28288,"length1":20,"length2":16}]}]},{"timestamp":1727774146143,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," // "],[-1,"current accelerometer pose\n\nlet northMagnetXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\n"],[1,"starting orientation of the buggy\n//"],[0,"let "]],"start1":1247,"start2":1247,"length1":128,"length2":44},{"diffs":[[0,"et north"],[-1,"Gravity"],[0,"XYZ: Vec"]],"start1":1288,"start2":1288,"length1":23,"length2":16},{"diffs":[[0,"ing "],[-1,"accelerometer pose of the buggy (while upright and stationary)"],[1,"field of the buggy\nlet northXYZ: Vector"],[0,"\nlet"]],"start1":1316,"start2":1316,"length1":70,"length2":47},{"diffs":[[0," frame\n\n"],[1,"let field: Vector\nlet gravity: Vector\n"],[0,"let fiel"]],"start1":1743,"start2":1743,"length1":16,"length2":54},{"diffs":[[0," gravity"],[-1,"XYZ"],[0," = corre"]],"start1":20658,"start2":20658,"length1":19,"length2":16},{"diffs":[[0,"rectedGravity()\n"],[1,""],[0,"    datalogger.l"]],"start1":20672,"start2":20672,"length1":32,"length2":32},{"diffs":[[0," gravity"],[-1,"XYZ"],[0,".x),\n   "]],"start1":20934,"start2":20934,"length1":19,"length2":16},{"diffs":[[0," gravity"],[-1,"XYZ"],[0,".y),\n   "]],"start1":20980,"start2":20980,"length1":19,"length2":16},{"diffs":[[0," gravity"],[-1,"XYZ"],[0,".z))\n   "]],"start1":21026,"start2":21026,"length1":19,"length2":16},{"diffs":[[0,"netXYZ)\n"],[1,""],[0,"    grav"]],"start1":21175,"start2":21175,"length1":16,"length2":16},{"diffs":[[0,"(gravity"],[-1,"XYZ"],[0,")\n\n    d"]],"start1":21230,"start2":21230,"length1":19,"length2":16},{"diffs":[[0,"    "],[-1,"magnetXYZ = new Vector(0,0,0)\n    gravityXYZ = new Vector(0,0,0)\n    for (let i = 0; i < 10; i++) {\n        magnetXYZ.x += input.magneticForce(Dimension.X)\n        magnetXYZ.y += input.magneticForce(Dimension.Y)\n        magnetXYZ.z += input.magneticForce(Dimension.Z)\n        gravityXYZ.x += input.acceleration(Dimension.X)\n        gravityXYZ.y += input.acceleration(Dimension.Y)\n        gravityXYZ.z += input.acceleration(Dimension.Z)\n    }\n"],[1,"for "],[0,"\n   "]],"start1":28292,"start2":28292,"length1":450,"length2":12}]}]},{"timestamp":1727774731100,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"rements\n"],[1,"let downXYZ: Vector // buggy's Down axis (fixed, dependent on mounting)\n"],[0,"let magn"]],"start1":1097,"start2":1097,"length1":16,"length2":88},{"diffs":[[0,"ose\n"],[1,"\n"],[0,"let "],[-1,"startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n"],[1,"northMagnetXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")"],[0,"\nlet"]],"start1":1274,"start2":1274,"length1":108,"length2":100},{"diffs":[[0,"et north"],[1,"Gravity"],[0,"XYZ: Vec"]],"start1":1372,"start2":1372,"length1":16,"length2":23},{"diffs":[[0,"// starting "],[-1,"magnetic field"],[1,"accelerometer pose"],[0," of the bugg"]],"start1":1399,"start2":1399,"length1":38,"length2":42},{"diffs":[[0,"ile "],[-1,"pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting"],[1,"upright and stationary)\nlet startXYZ: Reading // starting field and pose of the buggy (deemed north and upright"],[0,")\n\n/"]],"start1":1446,"start2":1446,"length1":133,"length2":119},{"diffs":[[0,"me\n\nlet "],[-1,"magnet"],[1,"field"],[0,"ENG: Vec"]],"start1":1861,"start2":1861,"length1":22,"length2":21},{"diffs":[[0,"ty)\n    "],[-1,"magnet"],[1,"field"],[0,"ENG = ro"]],"start1":21210,"start2":21210,"length1":22,"length2":21},{"diffs":[[0,"V(\"fx\", "],[-1,"magnet"],[1,"field"],[0,"ENG.x),\n"]],"start1":21427,"start2":21427,"length1":22,"length2":21},{"diffs":[[0,"V(\"fy\", "],[-1,"magnet"],[1,"field"],[0,"ENG.y),\n"]],"start1":21474,"start2":21474,"length1":22,"length2":21},{"diffs":[[0,"V(\"fz\", "],[-1,"magnet"],[1,"field"],[0,"ENG.z),\n"]],"start1":21521,"start2":21521,"length1":22,"length2":21},{"diffs":[[0,"an2("],[-1,"magnet"],[1,"field"],[0,"ENG.y, "],[-1,"magnet"],[1,"field"],[0,"ENG."]],"start1":21726,"start2":21726,"length1":27,"length2":25},{"diffs":[[0," 0; i < "],[-1,"Window"],[1,"10"],[0,"; i++) {"]],"start1":28468,"start2":28468,"length1":22,"length2":18},{"diffs":[[0,"  }\n"],[-1,"    magnetXYZ.x /= Window\n    magnetXYZ.y /= Window\n    magnetXYZ.z /= Window\n    gravityXYZ.x /= Window\n    gravityXYZ.y /= Window\n    gravityXYZ.z /= Window"],[1,"\n    return 333"],[0,"\n}\n\n"]],"start1":28825,"start2":28825,"length1":166,"length2":23}]}]},{"timestamp":1727775063425,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"creen()\n"],[-1,"    \n"],[0,"    let "]],"start1":10653,"start2":10653,"length1":21,"length2":16}]}]},{"timestamp":1727776347360,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n()\n    "],[-1,"i"],[0,"\n    let"]],"start1":10657,"start2":10657,"length1":17,"length2":16}]}]},{"timestamp":1727776349020,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    let result: number\n"],[0,"    "]],"start1":10559,"start2":10559,"length1":31,"length2":8},{"diffs":[[0,"ady = false\n"],[1,""],[0,"    scan = ["]],"start1":10569,"start2":10569,"length1":24,"length2":24},{"diffs":[[0,"   i"],[-1,"f (isSimulating) {\n        simulateScan()\n        result = 0\n    } else {\n       "],[1,"\n    let"],[0," res"]],"start1":10662,"start2":10662,"length1":89,"length2":16},{"diffs":[[0,"e(6000)\n"],[-1,"    }\n"],[0,"    if ("]],"start1":10696,"start2":10696,"length1":22,"length2":16},{"diffs":[[0,"= 8.455\n"],[1,""],[0,"        "]],"start1":29698,"start2":29698,"length1":16,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < heading.scanTimes.length; i++) {\n        let xyz = []\n        xyz.push(xData[i])\n        xyz.push(yData[i])\n        xyz.push(zData[i])\n        heading.scanData.push(xyz)\n    }\n    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let xyz = []\n        xyz.push(xTest[n])\n        xyz.push(yTest[n])\n        xyz.push(zTest[n])\n        heading.testData.push(xyz)\n    }\n}\n\n"],[0,"// ="]],"start1":29734,"start2":29734,"length1":22938,"length2":8}]}]},{"timestamp":1727776939358,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ng\n\n"],[-1,"enum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\n\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // for debugging"],[1,"\n\nlet simulating = isSimulating() // for debugging\n//let scanTimes: number[] = []\n//let scanData: number[][] = []"],[0,"\nlet"]],"start1":430,"start2":430,"length1":161,"length2":121},{"diffs":[[0,"er\n\n"],[-1,"let test: Reading[] = [] // array of test readings\n"],[0,"\nlet"]],"start1":651,"start2":651,"length1":59,"length2":8},{"diffs":[[0,"    "],[-1,"switch (nextTask) {\n        case Tasks.PerformScan:\n        "],[1,"ready = false\n"],[0,"    "]],"start1":10586,"start2":10586,"length1":68,"length2":22},{"diffs":[[0,"an = []\n"],[-1,"        "],[0,"    basi"]],"start1":10610,"start2":10610,"length1":24,"length2":16},{"diffs":[[0,"ng(\"S\")\n"],[-1,"        "],[0,"    paus"]],"start1":10636,"start2":10636,"length1":24,"length2":16},{"diffs":[[0,"pause(1000)\n"],[-1,"        "],[0,"    basic.cl"]],"start1":10648,"start2":10648,"length1":32,"length2":24},{"diffs":[[0,"earScreen()\n"],[-1,"        "],[0,"    if (isSi"]],"start1":10672,"start2":10672,"length1":32,"length2":24},{"diffs":[[0,") {\n"],[-1,"                result = scanClockwise(6000)\n        "],[0,"    "]],"start1":10704,"start2":10704,"length1":61,"length2":8},{"diffs":[[0,"n()\n        "],[-1,"       "],[-1," "],[0,"result = 0\n "]],"start1":10727,"start2":10727,"length1":32,"length2":24},{"diffs":[[0,"ult = 0\n"],[-1,"        "],[0,"    } el"]],"start1":10742,"start2":10742,"length1":24,"length2":16},{"diffs":[[0,"e {\n        "],[-1,"  "],[-1,"      "],[0,"result = sca"]],"start1":10759,"start2":10759,"length1":32,"length2":24},{"diffs":[[0,"    "],[-1,"        }\n\n            nextTask = Tasks.SetNorth\n            break\n        case Tasks.SetNorth:\n            break\n        case Tasks.TakeBearing:\n            break\n\n    }\n    \n"],[1,"}"],[0,"\n   "]],"start1":10800,"start2":10800,"length1":184,"length2":9},{"diffs":[[0,"n()\n"],[-1,"    nextTask = Tasks.PerformScan\n"],[0,"})\n\n"]],"start1":11890,"start2":11890,"length1":41,"length2":8},{"diffs":[[0," 0; i < "],[-1,"t"],[1,"heading.scanT"],[0,"imes.len"]],"start1":52357,"start2":52357,"length1":17,"length2":29},{"diffs":[[0,"let "],[-1,"sample = new Sample(times[i], xData[i], yData[i], zData[i])\n        scan.push(sample"],[1,"xyz = []\n        xyz.push(xData[i])\n        xyz.push(yData[i])\n        xyz.push(zData[i])\n        heading.scanData.push(xyz"],[0,")\n  "]],"start1":52406,"start2":52406,"length1":92,"length2":131}]}]},{"timestamp":1727777534627,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    doNextTask()\n})\n\nfunction doNextTask() {\n"],[0,"    "]],"start1":10650,"start2":10650,"length1":53,"length2":8},{"diffs":[[0,") {\n"],[-1,"                result = simulateScan(1000)\n            } else {\n"],[0,"    "]],"start1":10873,"start2":10873,"length1":73,"length2":8},{"diffs":[[0,"    "],[-1,"}\n"],[0,"    "],[-1,"        if (result != 0) {\n                basic.showNumber("],[1,"simulateScan()\n                "],[0,"result"],[-1,")"],[1," = 0"],[0,"\n   "]],"start1":10930,"start2":10930,"length1":81,"length2":53},{"diffs":[[0,"    "],[-1,"basic.showString(\"A\")\n                analyseScan()\n\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n    "],[1,"result = scanClockwise(6000)\n            }\n\n"],[0,"    "]],"start1":11013,"start2":11013,"length1":139,"length2":52},{"diffs":[[0,"etNorth\n"],[-1,"            }\n"],[0,"        "]],"start1":11091,"start2":11091,"length1":30,"length2":16},{"diffs":[[0,"          break\n"],[-1,"\n"],[0,"        case Tas"]],"start1":11101,"start2":11101,"length1":33,"length2":32},{"diffs":[[0,"th:\n"],[-1,"            basic.showString(\"N\")\n            setNorth()\n            pause(1000)\n            basic.clearScreen()\n            ready = true\n"],[0,"    "]],"start1":11142,"start2":11142,"length1":146,"length2":8},{"diffs":[[0,"          break\n"],[-1,"\n"],[0,"        case Tas"]],"start1":11148,"start2":11148,"length1":33,"length2":32},{"diffs":[[0,"ng:\n"],[-1,"            heading = takeBearing()\n            basic.showNumber(heading)\n"],[0,"    "]],"start1":11192,"start2":11192,"length1":82,"length2":8},{"diffs":[[0,"reak\n\n    }\n"],[-1,"\n"],[0,"    \n\n      "]],"start1":11209,"start2":11209,"length1":25,"length2":24},{"diffs":[[0,"    "],[-1,"    if (!simulating) {\n            dumpScanData()"],[1,"if (result != 0) {\n        basic.showNumber(result)\n    } else {\n        basic.showIcon(IconNames.Yes)\n        pause(1000)\n"],[0,"\n   "]],"start1":11227,"start2":11227,"length1":57,"length2":131},{"diffs":[[0,"ng(\"D\")\n"],[1,"        dumpScan()\n"],[0,"        "]],"start1":11377,"start2":11377,"length1":16,"length2":35},{"diffs":[[0,"   pause(1000)\n\n"],[1,"        basic.showString(\"A\")\n        analyseScan()\n\n"],[0,"        datalogg"]],"start1":11447,"start2":11447,"length1":32,"length2":85},{"diffs":[[0,"\n    }\n}"],[-1,"\n"],[1,")"],[0,"\n\ninput."]],"start1":11887,"start2":11887,"length1":17,"length2":17},{"diffs":[[0,"    "],[-1,"dumpTestData()"],[1,"if (ready) {\n        heading = takeBearing()\n        basic.showNumber(heading)\n    } else {\n        basic.showString(\"N\")\n        setNorth()\n        pause(1000)\n        basic.clearScreen()\n        ready = true\n    }"],[0,"\n})\n"]],"start1":11944,"start2":11944,"length1":22,"length2":223},{"diffs":[[0,"\n}\n\n"],[-1,"// either we're simulating, or we're shut in a magnetic shielding box!\n"],[0,"func"]],"start1":16201,"start2":16201,"length1":79,"length2":8}]}]},{"timestamp":1727778130421,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n()\n"],[-1,"                if (!simulating) {\n                    basic.showString(\"D\")\n                    dumpScanData()\n                }"],[0,"\n"],[1,""],[0,"    "]],"start1":11203,"start2":11203,"length1":138,"length2":9},{"diffs":[[0,"break\n\n    }"],[1,"\n\n    \n\n        if (!simulating) {\n            dumpScanData()\n        basic.showString(\"D\")\n        basic.showIcon(IconNames.Yes)\n        pause(1000)\n\n        datalogger.log(\n            datalogger.createCV(\"yScale\", yScale),\n            datalogger.createCV(\"zScale\", zScale),\n            datalogger.createCV(\"downX\", downXYZ.x),\n            datalogger.createCV(\"downY\", downXYZ.y),\n            datalogger.createCV(\"downZ\", downXYZ.z))\n\n        basic.showIcon(IconNames.Yes)\n        pause(1000)\n        basic.clearScreen()\n    }"],[0,"\n}\n\n\ninput.o"]],"start1":11661,"start2":11661,"length1":24,"length2":552},{"diffs":[[0,"return 0\n}\n\n"],[1,"\n\n\nfunction correct() {\n}\n\n"],[0,"function pro"]],"start1":21318,"start2":21318,"length1":24,"length2":51},{"diffs":[[0,"dumpScan"],[-1,"Data"],[0,"() {\n   "]],"start1":22578,"start2":22578,"length1":20,"length2":16},{"diffs":[[0,", scan[i].field."],[-1,"y"],[1,"x"],[0,"),\n            d"]],"start1":22751,"start2":22751,"length1":33,"length2":33},{"diffs":[[0,"eld."],[-1,"z))\n    }\n    datalogger.log(\n        datalogger.createCV(\"yScale\", yScale),\n        datalogger.createCV(\"zScale\", zScale),\n        datalogger.createCV(\"downX\", downXYZ.x),\n        datalogger.createCV(\"downY\", downXYZ.y),\n        datalogger.createCV(\"downZ\", downXYZ.z))\n\n}\n\nfunction dumpTestData() {\n    for (let i = 0; i < test.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", test[i].field.x),\n            datalogger.createCV(\"fy\", test[i].field.y),\n            datalogger.createCV(\"fz\", test[i].field.z),\n            datalogger.createCV(\"gx\", test[i].pose.x),\n            datalogger.createCV(\"gy\", test[i].pose.y),\n            datalogger.createCV(\"gz\", test[i].pose.z))\n\n}"],[1,"x))\n    }\n}\n"],[0,"\n\n/*"]],"start1":22819,"start2":22819,"length1":712,"length2":20}]}]},{"timestamp":1727778553471,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n})\n"],[-1,"input.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n})\n\n// ============== FUNCTIONS ===============\n\n\n"],[0,"\nfun"]],"start1":10670,"start2":10670,"length1":307,"length2":8},{"diffs":[[0,"   }\n}\n\n"],[1,"\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n})\n\n// ============== FUNCTIONS ===============\n\n"],[0,"/* sampl"]],"start1":11798,"start2":11798,"length1":16,"length2":315},{"diffs":[[0,"dow\n"],[-1,"    return 333\n"],[0,"}\n\nf"]],"start1":29944,"start2":29944,"length1":23,"length2":8},{"diffs":[[0,"   }"],[-1,"\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]"],[0,"\n\n  "]],"start1":53181,"start2":53181,"length1":344,"length2":8},{"diffs":[[0,"let "],[-1,"reading = new Reading(xTest[n], yTest[n],zTest[n],gxTest[n],gyTest[n],gzTest[n])\n"],[1,"xyz = []\n        xyz.push(xTest[n])\n        xyz.push(yTest[n])\n        xyz.push(zTest[n])\n        heading.testData.push(xyz)"],[0,"\n   "]],"start1":53483,"start2":53483,"length1":89,"length2":132},{"diffs":[[0,"ing...\n\n"],[-1,"}"]],"start1":54885,"start2":54885,"length1":9,"length2":8}]}]},{"timestamp":1727779148259,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"can("],[-1,"\""],[0,"1000"],[-1,"\""],[0,")\n  "]],"start1":11255,"start2":11255,"length1":14,"length2":12},{"diffs":[[0,"se.z))\n\n"],[-1,"    }\n}\n"],[1,"}"],[0,"\n\n/** Fu"]],"start1":23096,"start2":23096,"length1":24,"length2":17},{"diffs":[[0,"17\n    }\n}\n\n"],[1,"\n"],[0,"function sim"]],"start1":30745,"start2":30745,"length1":24,"length2":25},{"diffs":[[0,"Test[n],"],[-1," "],[0,"zTest[n]"]],"start1":53871,"start2":53871,"length1":17,"length2":16},{"diffs":[[0,"Test[n],"],[-1," "],[0,"gxTest[n"]],"start1":53880,"start2":53880,"length1":17,"length2":16},{"diffs":[[0,"Test[n],"],[-1," "],[0,"gyTest[n"]],"start1":53890,"start2":53890,"length1":17,"length2":16},{"diffs":[[0,"Test[n],"],[-1," "],[0,"gzTest[n"]],"start1":53900,"start2":53900,"length1":17,"length2":16},{"diffs":[[0,"n])\n"],[1,"\n"],[0,"    }"],[-1,"\n    return 0"],[0,"\n}\n\n"]],"start1":53915,"start2":53915,"length1":26,"length2":14},{"diffs":[[0,"ing...\n\n"],[1,"}"]],"start1":55193,"start2":55193,"length1":8,"length2":9}]}]},{"timestamp":1727779332534,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"teScan(\""],[-1,"T07260757_dash7"],[1,"100"],[0,"0\")\n    "]],"start1":11252,"start2":11252,"length1":31,"length2":19}]}]},{"timestamp":1727794777143,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   }\n}\n\n"],[1,"\n\n"],[0,"/**\n* A "]],"start1":6367,"start2":6367,"length1":16,"length2":18}]}]},{"timestamp":1727796779332,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= Tasks."],[1,"PerformScan"],[0,"\n})\n\n// "]],"start1":10901,"start2":10901,"length1":16,"length2":27}]}]},{"timestamp":1727796798187,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," Vector\n"],[-1,"\n"],[0,"let xOff"]],"start1":996,"start2":996,"length1":17,"length2":16},{"diffs":[[0,"= Tasks."],[-1,"TakeBearing"],[0,"\n})\n\n// "]],"start1":10901,"start2":10901,"length1":27,"length2":16},{"diffs":[[0,"\"S\")"],[-1," // scan"],[0,"\n   "]],"start1":11115,"start2":11115,"length1":16,"length2":8},{"diffs":[[0,"ing(\"A\")"],[-1," // analyse"],[0,"\n       "]],"start1":11468,"start2":11468,"length1":27,"length2":16},{"diffs":[[0,"\"D\")"],[-1," // dump raw scan data"],[0,"\n   "]],"start1":11579,"start2":11579,"length1":30,"length2":8},{"diffs":[[0,"  }\n"],[-1,"\n                basic.showString(\"C\") // correct\n                correctScan()\n                pause(1000)\n\n"],[0,"    "]],"start1":11633,"start2":11633,"length1":117,"length2":8},{"diffs":[[0,"    "],[-1,"// The means of the extremes give a good approximation to the central offsets.\n    offset.x = (xhi + xlo) / 2\n    offset.y = (yhi + ylo) / 2\n    offset.z = (zhi + zlo) / 2\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\nfunction correctScan() {"],[1,"strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n    // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n    // The means of the extremes give a good approximation to the central offsets.\n    xOff = (xhi + xlo) / 2\n    yOff = (yhi + ylo) / 2\n    zOff = (zhi + zlo) / 2"],[0,"\n\n  "]],"start1":19825,"start2":19825,"length1":510,"length2":477},{"diffs":[[0,"og(\n"],[-1,"            datalogger.createCV(\"data\", \"raw scan\"),\n"],[0,"    "]],"start1":22234,"start2":22234,"length1":61,"length2":8},{"diffs":[[0,"d.z))\n    }\n"],[-1,"\n"],[0,"    datalogg"]],"start1":22400,"start2":22400,"length1":25,"length2":24},{"diffs":[[0,"    "],[-1,"datalogger.log(\n        datalogger.createCV(\"data\", \"raw test\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ\n    "],[1,"return 333"],[0,"\n}\n\n"]],"start1":29956,"start2":29956,"length1":352,"length2":18}]}]},{"timestamp":1727797359433,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0))\n}\n\n"],[-1,"//"],[0,"function"]],"start1":16328,"start2":16328,"length1":18,"length2":16}]}]},{"timestamp":1727801797306,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0))\n}\n\n"],[1,"/"],[0,"/functio"]],"start1":16328,"start2":16328,"length1":16,"length2":17}]}]},{"timestamp":1727801800537,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"    basic.showString(\"D\") // dump the smoothed raw scan data\n                dumpScanData()\n            }\n"],[1,"}"],[0,"\n   "]],"start1":11360,"start2":11360,"length1":114,"length2":9},{"diffs":[[0,"e {\n"],[-1,"                // analyse and re-centre the data\n"],[0,"    "]],"start1":11455,"start2":11455,"length1":58,"length2":8},{"diffs":[[0,"ing(\"A\")"],[1," // analyse"],[0,"\n       "]],"start1":11488,"start2":11488,"length1":16,"length2":27},{"diffs":[[0,"    "],[-1,"}\n"],[0,"    "],[-1,"            // apply scaling corrections to scan data?"],[1,"basic.showString(\"D\") // dump raw scan data\n                    dumpScanData()\n                }\n"],[0,"\n   "]],"start1":11585,"start2":11585,"length1":68,"length2":109},{"diffs":[[0,"0))\n}\n\n/"],[-1,"* "],[0,"function"]],"start1":16329,"start2":16329,"length1":18,"length2":16},{"diffs":[[0,": number) {\n"],[1,""],[0,"    if (lit["]],"start1":16365,"start2":16365,"length1":24,"length2":24},{"diffs":[[0,"    }\n} "],[-1,"*/"],[0,"\n\nfuncti"]],"start1":16525,"start2":16525,"length1":18,"length2":16},{"diffs":[[0," field\n\n"],[-1,""],[0,"    scan"]],"start1":16666,"start2":16666,"length1":16,"length2":16},{"diffs":[[0,"mpty arrays\n"],[1,"    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n"],[0,"    // get i"]],"start1":16703,"start2":16703,"length1":24,"length2":104},{"diffs":[[0,"let scan"],[-1,"Duration"],[1,"Time"],[0," = scan["]],"start1":19091,"start2":19091,"length1":24,"length2":20},{"diffs":[[0,"scan"],[-1,"Duration"],[1,"Time"],[0," < E"]],"start1":19184,"start2":19184,"length1":16,"length2":12},{"diffs":[[0,"nds the "],[-1,"value "],[0,"ranges f"]],"start1":19385,"start2":19385,"length1":22,"length2":16},{"diffs":[[0,"is \n"],[-1,"    // Usually NOT the full field-strength in any dimension)\n"],[0,"    "]],"start1":19411,"start2":19411,"length1":69,"length2":8}]}]},{"timestamp":1727802396123,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"        "],[-1,"recentre"],[1,"correct"],[0,"Scan()\n "]],"start1":11851,"start2":11851,"length1":24,"length2":23},{"diffs":[[0,"xis "],[-1,"(u"],[1,"\n    // U"],[0,"sual"]],"start1":19451,"start2":19451,"length1":10,"length2":17},{"diffs":[[0,"\n    // "],[-1,"derive"],[1,"get"],[0," RMS fie"]],"start1":19969,"start2":19969,"length1":22,"length2":19},{"diffs":[[0,"ngth"],[-1," from the ranges detected in each axis"],[0,"\n   "]],"start1":19995,"start2":19995,"length1":46,"length2":8},{"diffs":[[0,"    "],[-1,"strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n    // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes"],[1,"// The means of the extremes give a good approximation to the central offsets."],[0,"\n   "]],"start1":20090,"start2":20090,"length1":187,"length2":86},{"diffs":[[0,"lding?)\n"],[1,"    strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n"],[0,"    if ("]],"start1":20382,"start2":20382,"length1":16,"length2":106},{"diffs":[[0,"ion "],[-1,"recentre"],[1,"correct"],[0,"Scan"]],"start1":20577,"start2":20577,"length1":16,"length2":15},{"diffs":[[0,") {\n"],[1,"\n"],[0,"    // "],[-1,"first"],[1,"2nd pass"],[0," re-"]],"start1":20593,"start2":20593,"length1":20,"length2":24},{"diffs":[[0,"e-centre"],[1,"s"],[0," all the"]],"start1":20615,"start2":20615,"length1":16,"length2":17},{"diffs":[[0,"ld.x -= "],[-1,"offset.x"],[1,"xOff"],[0,"\n       "]],"start1":20767,"start2":20767,"length1":24,"length2":20},{"diffs":[[0,"ld.y -= "],[-1,"offset.y"],[1,"yOff"],[0,"\n       "]],"start1":20799,"start2":20799,"length1":24,"length2":20},{"diffs":[[0," -= "],[-1,"offset.z"],[1,"zOff"],[0,"\n    }"],[-1,"\n}"],[0,"\n\n  "]],"start1":20835,"start2":20835,"length1":24,"length2":18}]}]},{"timestamp":1727802882671,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ing\n"],[-1,"\nlet test: Reading[] = [] // array of test readings\n\nlet strength = 0 // the a"],[1,"let scan: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\nlet nSamples: number\n\nlet test: Reading[] = [] // array of test readings\n\nlet strength = 0 // the average magnetic field-strength observed by the magnetometer\nlet scanPeriod = -1 // average scanning rotation time\n\n// amplitudes and central offsets of sinusoidal scan-readings in each dimension\nlet swing: Vector\nlet offset: Vector\n\nlet xOff: number\nlet yOff: number\nlet zOff: number\n// sensitivity adjustment factors that will match Y & Z readings to X readings\nlet yScale: number\nlet zScale: number\n"],[0,"\n// "]],"start1":584,"start2":584,"length1":86,"length2":593},{"diffs":[[0,"}\n\n\n"],[-1,"class Scan {\n    samples: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\n    nSamples: number\n    swing: Vector   // amplitudes  in each dimension\n    offset: Vector  // central offsets from origin in each dimension\n\n\n}\n\n\n"],[0,"// ="]],"start1":10555,"start2":10555,"length1":258,"length2":8},{"diffs":[[0,"           s"],[-1,"amples"],[1,"can"],[0," = []\n      "]],"start1":11077,"start2":11077,"length1":30,"length2":27},{"diffs":[[0,"d\n\n    s"],[-1,"amples"],[1,"can"],[0," = [] //"]],"start1":16779,"start2":16779,"length1":22,"length2":19},{"diffs":[[0,"   && (s"],[-1,"amples"],[1,"can"],[0,".length "]],"start1":17463,"start2":17463,"length1":22,"length2":19},{"diffs":[[0,"           s"],[-1,"amples"],[1,"can"],[0,".push(newSam"]],"start1":18617,"start2":18617,"length1":30,"length2":27},{"diffs":[[0,"ples = s"],[-1,"amples"],[1,"can"],[0,".length\n"]],"start1":18925,"start2":18925,"length1":22,"length2":19},{"diffs":[[0,"tion = s"],[-1,"amples"],[1,"can"],[0,"[nSample"]],"start1":19131,"start2":19131,"length1":22,"length2":19},{"diffs":[[0," 1].time = s"],[-1,"amples"],[1,"can"],[0,"[0].time\n   "]],"start1":19153,"start2":19153,"length1":30,"length2":27},{"diffs":[[0," }\n\n"],[-1,"    strength = scopeScan()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n   \n}\n\n\nfunction scopeScan() {\n"],[0,"    "]],"start1":19297,"start2":19297,"length1":280,"length2":8},{"diffs":[[0,"h.max(xhi, s"],[-1,"amples"],[1,"can"],[0,"[i].field.x)"]],"start1":19704,"start2":19704,"length1":30,"length2":27},{"diffs":[[0,"h.max(yhi, s"],[-1,"amples"],[1,"can"],[0,"[i].field.x)"]],"start1":19749,"start2":19749,"length1":30,"length2":27},{"diffs":[[0,"x(zhi, s"],[-1,"amples"],[1,"can"],[0,"[i].fiel"]],"start1":19798,"start2":19798,"length1":22,"length2":19},{"diffs":[[0,"h.min(xlo, s"],[-1,"amples"],[1,"can"],[0,"[i].field.y)"]],"start1":19839,"start2":19839,"length1":30,"length2":27},{"diffs":[[0,"h.min(ylo, s"],[-1,"amples"],[1,"can"],[0,"[i].field.z)"]],"start1":19884,"start2":19884,"length1":30,"length2":27},{"diffs":[[0,"n(zlo, s"],[-1,"amples"],[1,"can"],[0,"[i].fiel"]],"start1":19933,"start2":19933,"length1":22,"length2":19},{"diffs":[[0,"zlo) / 2"],[1,"\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }"],[0,"\n}\n\nfunc"]],"start1":20393,"start2":20393,"length1":16,"length2":229},{"diffs":[[0,"i++) {\n        s"],[-1,"amples"],[1,"can"],[0,"[i].field.x -= o"]],"start1":20783,"start2":20783,"length1":38,"length2":35},{"diffs":[[0,"fset.x\n        s"],[-1,"amples"],[1,"can"],[0,"[i].field.y -= o"]],"start1":20819,"start2":20819,"length1":38,"length2":35},{"diffs":[[0,"       s"],[-1,"amples"],[1,"can"],[0,"[i].fiel"]],"start1":20863,"start2":20863,"length1":22,"length2":19},{"diffs":[[0,"0; i < s"],[-1,"amples"],[1,"can"],[0,".length;"]],"start1":22541,"start2":22541,"length1":22,"length2":19},{"diffs":[[0,"teCV(\"fx\", s"],[-1,"amples"],[1,"can"],[0,"[i].field.x)"]],"start1":22672,"start2":22672,"length1":30,"length2":27},{"diffs":[[0,"teCV(\"fy\", s"],[-1,"amples"],[1,"can"],[0,"[i].field.y)"]],"start1":22728,"start2":22728,"length1":30,"length2":27},{"diffs":[[0,"(\"fz\", s"],[-1,"amples"],[1,"can"],[0,"[i].fiel"]],"start1":22788,"start2":22788,"length1":22,"length2":19},{"diffs":[[0,"   let x = s"],[-1,"amples"],[1,"can"],[0,"[0].field.x\n"]],"start1":25466,"start2":25466,"length1":30,"length2":27},{"diffs":[[0,"   let y = s"],[-1,"amples"],[1,"can"],[0,"[0].field.y\n"]],"start1":25494,"start2":25494,"length1":30,"length2":27},{"diffs":[[0,"et z = s"],[-1,"amples"],[1,"can"],[0,"[0].fiel"]],"start1":25526,"start2":25526,"length1":22,"length2":19},{"diffs":[[0,"       x = s"],[-1,"amples"],[1,"can"],[0,"[i].field.x\n"]],"start1":25990,"start2":25990,"length1":30,"length2":27},{"diffs":[[0,"       y = s"],[-1,"amples"],[1,"can"],[0,"[i].field.y\n"]],"start1":26018,"start2":26018,"length1":30,"length2":27},{"diffs":[[0,"       z = s"],[-1,"amples"],[1,"can"],[0,"[i].field.z\n"]],"start1":26046,"start2":26046,"length1":30,"length2":27},{"diffs":[[0,"     zFinish = s"],[-1,"amples"],[1,"can"],[0,"[i].time\n       "]],"start1":26580,"start2":26580,"length1":38,"length2":35},{"diffs":[[0,"     xFinish = s"],[-1,"amples"],[1,"can"],[0,"[i].time\n       "]],"start1":27015,"start2":27015,"length1":38,"length2":35},{"diffs":[[0,"nish = s"],[-1,"amples"],[1,"can"],[0,"[i].time"]],"start1":27357,"start2":27357,"length1":22,"length2":19},{"diffs":[[0,"       s"],[-1,"amples"],[1,"can"],[0,".push(sa"]],"start1":54461,"start2":54461,"length1":22,"length2":19}]}]},{"timestamp":1727803436609,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ion\n"],[-1,"    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n    }\n\n    acquire(ms: number) {\n        let timeWas: number\n        let timeNow: number\n        let newSample: Sample // Sampled magnetic field\n\n        this.samples = [] // start with empty arrays\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n       \n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                newSample.field = new Vector(smooth[0], smooth[1], smooth[2])\n                newSample.time = timeNow  // timestamp it  \n                samples.push(newSample)\n            }\n        }\n\n    }"],[0,"\n\n}\n"]],"start1":10292,"start2":10292,"length1":2280,"length2":8},{"diffs":[[0,"rmScan:\n"],[1,"            samples = []\n"],[0,"        "]],"start1":10811,"start2":10811,"length1":16,"length2":41},{"diffs":[[0,"mber) {\n"],[1,"    let timeWas: number\n    let timeNow: number\n    let newSample: Sample // Sampled magnetic field\n\n    samples = [] // start with empty arrays\n    // get initial reading\n    let timeStamp = input.runningTime()\n    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n    let smooth: number[]\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * SampleGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (samples.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        field = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        smooth = fieldSmoother.update(timeNow, field)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the averaged field values (as a deep copy!)\n            newSample.field = new Vector(smooth[0], smooth[1], smooth[2])\n            newSample.time = timeNow  // timestamp it  \n            samples.push(newSample)           \n        }\n    }\n"],[0,"}\n\n\nfunc"]],"start1":16419,"start2":16419,"length1":16,"length2":2020}]}]},{"timestamp":1727803981371,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    // Scan Methods.....\n\n"],[0,"    "]],"start1":10422,"start2":10422,"length1":34,"length2":8},{"diffs":[[0,"netic field\n"],[1,"\n"],[0,"        this"]],"start1":10552,"start2":10552,"length1":24,"length2":25},{"diffs":[[0,"rt with "],[-1,"an "],[0,"empty ar"]],"start1":10597,"start2":10597,"length1":19,"length2":16},{"diffs":[[0,"ty array"],[-1,"\n"],[1,"s"],[0,"\n       "]],"start1":10608,"start2":10608,"length1":17,"length2":17},{"diffs":[[0,"on.Z)]\n\n"],[1,"       \n"],[0,"        "]],"start1":10856,"start2":10856,"length1":16,"length2":24},{"diffs":[[0,"mooth = "],[-1,"this."],[0,"fieldSmo"]],"start1":12129,"start2":12129,"length1":21,"length2":16},{"diffs":[[0,"            "],[-1,"this."],[0,"samples.push"]],"start1":12502,"start2":12502,"length1":29,"length2":24},{"diffs":[[0,"   }"],[-1," \n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the offsets needed to correctly re-centre biased readings\n    \n    scopeScan() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < nSamples; i++) {\n            xhi = Math.max(xhi, samples[i].field.x)\n            yhi = Math.max(yhi, samples[i].field.x)\n            zhi = Math.max(zhi, samples[i].field.y)\n            xlo = Math.min(xlo, samples[i].field.y)\n            ylo = Math.min(ylo, samples[i].field.z)\n            zlo = Math.min(zlo, samples[i].field.z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        this.swing.x = (xhi - xlo) / 2\n        this.swing.y = (yhi - ylo) / 2\n        this.swing.z = (zhi - zlo) / 2\n        this.strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        this.offset.x = (xhi + xlo) / 2\n        this.offset.y = (yhi + ylo) / 2\n        this.offset.z = (zhi + zlo) / 2\n    }\n\n    recentreScan() {\n    // re-centre all the scanData samples, eliminating \"hard-iron\" environmental magnetic effects.\n    for (let i = 0; i < nSamples; i++) {\n        this.samples[i].field.x -= this.offset.x\n        this.samples[i].field.y -= this.offset.y\n        this.samples[i].field.z -= this.offset.z\n    }\n\n\n}\n"],[0,"\n\n}\n"]],"start1":12564,"start2":12564,"length1":1679,"length2":8},{"diffs":[[0,"unction "],[1,"scopeScan() {\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // The first pass finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    let xlo = 9999999\n    let ylo = 9999999\n    let zlo = 9999999\n    let xhi = -9999999\n    let yhi = -9999999\n    let zhi = -9999999\n    for (let i = 0; i < nSamples; i++) {\n        xhi = Math.max(xhi, samples[i].field.x)\n        yhi = Math.max(yhi, samples[i].field.x)\n        zhi = Math.max(zhi, samples[i].field.y)\n        xlo = Math.min(xlo, samples[i].field.y)\n        ylo = Math.min(ylo, samples[i].field.z)\n        zlo = Math.min(zlo, samples[i].field.z)\n    }\n\n    // derive RMS field-strength from the ranges detected in each axis\n    swing.x = (xhi - xlo) / 2\n    swing.y = (yhi - ylo) / 2\n    swing.z = (zhi - zlo) / 2\n    strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n    // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n    offset.x = (xhi + xlo) / 2\n    offset.y = (yhi + ylo) / 2\n    offset.z = (zhi + zlo) / 2\n}\n\nfunction recentreScan() {\n    // first re-centre all the scanData samples, eliminating \"hard-iron\" environmental magnetic effects.\n    for (let i = 0; i < nSamples; i++) {\n        samples[i].field.x -= offset.x\n        samples[i].field.y -= offset.y\n        samples[i].field.z -= offset.z\n    }\n}\n"],[0,"\n    // "]],"start1":19558,"start2":19558,"length1":16,"length2":1449},{"diffs":[[0,"frame).\n"],[-1,"\n"],[1,"     *"],[0," \n     *"]],"start1":23772,"start2":23772,"length1":17,"length2":22},{"diffs":[[0,"uly "],[-1,"\""],[0,"vertical"],[-1,"\""],[0,": th"]],"start1":24326,"start2":24326,"length1":18,"length2":16}]}]},{"timestamp":1727804579122,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"an\n\n"],[-1,"let scan: Scan = new Scan()\n"],[0,"let "]],"start1":535,"start2":535,"length1":36,"length2":8},{"diffs":[[0,"   scope"],[1,"Scan"],[0,"() {\n"],[-1,""],[0,"        "]],"start1":12891,"start2":12891,"length1":21,"length2":25},{"diffs":[[0,"recentre"],[1,"Scan"],[0,"() {\n   "]],"start1":13955,"start2":13955,"length1":16,"length2":20},{"diffs":[[0,"})\n\n"],[-1,"\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest,\n    */\n"],[0,"// ="]],"start1":14638,"start2":14638,"length1":809,"length2":8},{"diffs":[[0,"scan"],[-1,".acquir"],[1,"Clockwis"],[0,"e(6000)\n"],[-1,"\n"],[0,"    "]],"start1":15026,"start2":15026,"length1":24,"length2":24},{"diffs":[[0,"    "],[-1,"scan."],[0,"dump"],[1,"Scan"],[0,"Data"]],"start1":15131,"start2":15131,"length1":17,"length2":16},{"diffs":[[0,"    "],[-1,"scan.scope()\n                scan."],[0,"analyse"],[1,"Scan"],[0,"()\n "]],"start1":15358,"start2":15358,"length1":49,"length2":19},{"diffs":[[0,"    "],[-1,"scan."],[0,"recentre"],[1,"Scan"],[0,"()\n "]],"start1":15549,"start2":15549,"length1":21,"length2":20},{"diffs":[[0,"    }\n} */\n\n"],[1,"function collectSamples(ms: number) {\n}\n\n"],[0,"\nfunction sc"]],"start1":20325,"start2":20325,"length1":24,"length2":65},{"diffs":[[0,"ugMode) "],[1,"\n    collectSamples(ms)  // ...take repeated magnetometer readings"],[0,"\n\n    nS"]],"start1":20540,"start2":20540,"length1":16,"length2":82},{"diffs":[[0," }\n\n   \n}\n\n\n"],[1,"function \n"],[0,"    // asses"]],"start1":21246,"start2":21246,"length1":24,"length2":34},{"diffs":[[0,"  }\n    */\n\n"],[1,"    return 0\n}\n"],[0,"\nfunction pr"]],"start1":21619,"start2":21619,"length1":24,"length2":39},{"diffs":[[0,").\n\n"],[1," \n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first \n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     * \n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating \n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest,\n    "],[0,"*/"],[-1,"  "],[0,"\nfun"]],"start1":24045,"start2":24045,"length1":12,"length2":806}]}]},{"timestamp":1727805016934,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   }\n}\n\n"],[1,"/"],[0,"/ a Samp"]],"start1":9760,"start2":9760,"length1":16,"length2":17}]}]},{"timestamp":1727850434708,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n}\n\n/"],[-1,"*"],[0," a Sampl"]],"start1":9761,"start2":9761,"length1":17,"length2":16}]}]},{"timestamp":1727850437317,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n    }\n}"],[-1,"*/"],[0,"\n\n\nclass"]],"start1":10069,"start2":10069,"length1":18,"length2":16},{"diffs":[[0,"amples: "],[-1,"Vector"],[1,"Sample"],[0,"[] // se"]],"start1":10098,"start2":10098,"length1":22,"length2":22},{"diffs":[[0,"ence of "],[1,"time-stamped "],[0,"magnetom"]],"start1":10122,"start2":10122,"length1":16,"length2":29},{"diffs":[[0,"ngs\n"],[-1,"    times: number[] // matching sequence of time-stamps for fields[]\n"],[0,"    "]],"start1":10177,"start2":10177,"length1":77,"length2":8},{"diffs":[[0," []\n"],[-1,"        this.times = []\n"],[0,"    "]],"start1":10443,"start2":10443,"length1":32,"length2":8},{"diffs":[[0,"timeNow: number\n"],[1,"        let newSample: Sample // Sampled magnetic field\n"],[0,"        this.sam"]],"start1":10546,"start2":10546,"length1":32,"length2":88},{"diffs":[[0,"rt with "],[1,"an "],[0,"empty ar"]],"start1":10650,"start2":10650,"length1":16,"length2":19},{"diffs":[[0,"rray"],[-1,"\n        this.times = []"],[0,"\n\n  "]],"start1":10668,"start2":10668,"length1":32,"length2":8},{"diffs":[[0,"    "],[-1,"this.samples.push("],[1,"newSample.field = "],[0,"new "]],"start1":12425,"start2":12425,"length1":26,"length2":26},{"diffs":[[0,"ooth[2])"],[-1,")"],[0,"\n       "]],"start1":12482,"start2":12482,"length1":17,"length2":16},{"diffs":[[0,"    "],[-1,"this.times.push("],[1,"newSample.time = "],[0,"timeNow"],[-1,")"],[0,"  //"]],"start1":12503,"start2":12503,"length1":32,"length2":32},{"diffs":[[0,"mp it  \n"],[1,"                this.samples.push(newSample)\n"],[0,"        "]],"start1":12543,"start2":12543,"length1":16,"length2":61},{"diffs":[[0,"      }\n"],[1,"\n"],[0,"    }"],[-1,"\n\n"],[1," "],[0,"\n    // "]],"start1":12612,"start2":12612,"length1":23,"length2":23},{"diffs":[[0," }\n\n"],[-1,"        /** Method to analyse the scan-readings and derive the magnetometer scaling factors\n             * and the scan spin-axis (measured in the XYZ sensor frame).\n        \n        */\n        analyse() {\n            /* given the set of six [X,Y,Z] measurements:\n                    [M, N, -] when crossing the XY plane\n                    [-, P, Q] when crossing the YZ plane\n                    [R, -, S] when crossing the ZX plane\n        \n            ...and knowing that: \n                    X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n            \n            ...we can (after some maths!) derive the calibration factors (relative to x):\n                    yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                    zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n            */\n\n            // First, collect the plane-crossings in each direction. \n            // Simultaneously, collect half-periods of rotation, which we will average.\n            // counts of zero-crossings detected in this scan\n            let nCrossXY = 0\n            let nCrossYZ = 0\n            let nCrossZX = 0\n            // time-stamp of first\n            let xStart = -1\n            let yStart = -1\n            let zStart = -1\n            let xFinish = 0\n            let yFinish = 0\n            let zFinish = 0\n            let x = samples[0].field.x\n            let y = samples[0].field.y\n            let z = samples[0].field.z\n            let xWas: number\n            let yWas: number\n            let zWas: number\n            // flags to inhibit clocking multiple jittery crossings \n            let needXY = true\n            let needYZ = true\n            let needZX = true\n            // we'll mostly use the squares of the zero-crossing components\n            let MM = 0\n            let NN = 0\n            let PP = 0\n            let QQ = 0\n            let RR = 0\n            let SS = 0\n            for (let i = 0; i < nSamples; i++) {\n                xWas = x\n                yWas = y\n                zWas = z\n                x = samples[i].field.x\n                y = samples[i].field.y\n                z = samples[i].field.z\n\n                // avoid any exact zeroes (they complicate comparisons!)\n                if (x == 0) x = xWas\n                if (y == 0) y = yWas\n                if (z == 0) z = zWas\n\n                // Look for the first transition of each half-cycle (i.e. where the sign flips)\n                // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n                if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                    MM += x ** 2\n                    NN += y ** 2\n                    nCrossXY++\n                    zFinish = samples[i].time\n                    if (zStart < 0) zStart = zFinish // start the clock...\n                    needXY = false\n                    // got this axis-crossing, so now only allow others to be detected\n                    needYZ = true\n                    needZX = true\n                }\n                if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                    PP += y ** 2\n                    QQ += z ** 2\n                    nCrossYZ++\n                    xFinish = samples[i].time\n                    if (xStart < 0) xStart = xFinish\n                    needYZ = false\n                    needXY = true\n                    needZX = true\n                }\n                if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                    RR += x ** 2\n                    SS += z ** 2\n                    nCrossZX++\n                    yFinish = samples[i].time\n                    if (yStart < 0) yStart = yFinish\n                    needZX = false\n                    needXY = true\n                    needYZ = true\n                }\n            }\n            // average the squared crossing points\n            MM /= nCrossXY\n            NN /= nCrossXY\n            PP /= nCrossYZ\n            QQ /= nCrossYZ\n            RR /= nCrossZX\n            SS /= nCrossZX\n\n            // derive the average \"flip\" times (each making half a rotation)\n            let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n            let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n            let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n            // average the three half-periods, then double them to get our best measure for full period\n            scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n            // construct the relative scaling factors\n            let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n            this.yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n            this.zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n            /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n                    [M, N, -] when crossing the XY plane\n                    [-, P, Q] when crossing the YZ plane\n                    [R, -, S] when crossing the ZX plane\n            */\n            let M = Math.sqrt(MM)\n            let N = Math.sqrt(NN) * yScale\n            let P = Math.sqrt(PP) * yScale\n            let Q = Math.sqrt(QQ) * zScale\n            let R = Math.sqrt(RR)\n            let S = Math.sqrt(MM) * zScale\n\n            // since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n            // cross-product of any two edges to derive the orthogonal rotation-axis\n            let I = (Q * N) - (N * S) + (S * P)\n            let J = (R * Q) - (Q * M) + (M * S)\n            let K = (N * R) - (R * P) + (P * M)\n\n            downXYZ = new Vector(I, J, K)\n            downXYZ = downXYZ.normalised()\n            let check = 0 // debug point...\n        }\n    }"],[1,"\n}\n\n"],[0,"\n}\n\n"]],"start1":14282,"start2":14282,"length1":5870,"length2":12},{"diffs":[[0,"  }\n}\n\n\n"],[1,"/** Function to analyse the scan-readings and derive the magnetometer scaling factors\n     * and the scan spin-axis (measured in the XYZ sensor frame).\n\n*/  \nfunction analyseScan() {\n    /* given the set of six [X,Y,Z] measurements:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n\n    ...and knowing that: \n            X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n    \n    ...we can (after some maths!) derive the calibration factors (relative to x):\n            yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n            zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n    */\n\n    // First, collect the plane-crossings in each direction. \n    // Simultaneously, collect half-periods of rotation, which we will average.\n    // counts of zero-crossings detected in this scan\n    let nCrossXY = 0\n    let nCrossYZ = 0\n    let nCrossZX = 0\n    // time-stamp of first\n    let xStart = -1\n    let yStart = -1\n    let zStart = -1\n    let xFinish = 0\n    let yFinish = 0\n    let zFinish = 0\n    let x = samples[0].field.x\n    let y = samples[0].field.y\n    let z = samples[0].field.z\n    let xWas: number\n    let yWas: number\n    let zWas: number\n    // flags to inhibit clocking multiple jittery crossings \n    let needXY = true\n    let needYZ = true\n    let needZX = true\n    // we'll mostly use the squares of the zero-crossing components\n    let MM = 0\n    let NN = 0\n    let PP = 0\n    let QQ = 0\n    let RR = 0\n    let SS = 0\n    for (let i = 0; i < nSamples; i++) {\n        xWas = x\n        yWas = y\n        zWas = z\n        x = samples[i].field.x\n        y = samples[i].field.y\n        z = samples[i].field.z\n\n        // avoid any exact zeroes (they complicate comparisons!)\n        if (x == 0) x = xWas\n        if (y == 0) y = yWas\n        if (z == 0) z = zWas\n\n        // Look for the first transition of each half-cycle (i.e. where the sign flips)\n        // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n        if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n            MM += x ** 2\n            NN += y ** 2\n            nCrossXY++\n            zFinish = samples[i].time\n            if (zStart < 0) zStart = zFinish // start the clock...\n            needXY = false\n            // got this axis-crossing, so now only allow others to be detected\n            needYZ = true\n            needZX = true\n        }\n        if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n            PP += y ** 2\n            QQ += z ** 2\n            nCrossYZ++\n            xFinish = samples[i].time\n            if (xStart < 0) xStart = xFinish\n            needYZ = false\n            needXY = true\n            needZX = true\n        }\n        if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n            RR += x ** 2\n            SS += z ** 2\n            nCrossZX++\n            yFinish = samples[i].time\n            if (yStart < 0) yStart = yFinish\n            needZX = false\n            needXY = true\n            needYZ = true\n        }\n    }\n    // average the squared crossing points\n    MM /= nCrossXY\n    NN /= nCrossXY\n    PP /= nCrossYZ\n    QQ /= nCrossYZ\n    RR /= nCrossZX\n    SS /= nCrossZX\n\n    // derive the average \"flip\" times (each making half a rotation)\n    let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n    let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n    let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n    // average the three half-periods, then double them to get our best measure for full period\n    scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n    // construct the relative scaling factors\n    let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n    yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n    zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n    /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n    */\n    let M = Math.sqrt(MM)\n    let N = Math.sqrt(NN) * yScale\n    let P = Math.sqrt(PP) * yScale\n    let Q = Math.sqrt(QQ) * zScale\n    let R = Math.sqrt(RR)\n    let S = Math.sqrt(MM) * zScale\n\n    // since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n    // cross-product of any two edges to derive the orthogonal rotation-axis\n    let I = (Q * N) - (N * S) + (S * P)\n    let J = (R * Q) - (Q * M) + (M * S)\n    let K = (N * R) - (R * P) + (P * M)\n\n    downXYZ = new Vector(I, J, K)\n    downXYZ = downXYZ.normalised()\n\n    let check = 0 // debug point...\n}\n\n"],[0,"function"]],"start1":24609,"start2":24609,"length1":16,"length2":4850}]}]},{"timestamp":1727851035584,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"*/\n\n"],[-1,"class Correction {\n    offset: Vector\n    constructor ()\n}\n\n"],[0,"\ncla"]],"start1":10077,"start2":10077,"length1":68,"length2":8},{"diffs":[[0,"ber\n"],[-1,"    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n\n"],[0,"    "]],"start1":10256,"start2":10256,"length1":86,"length2":8},{"diffs":[[0,"litudes "],[1," "],[0,"in each "]],"start1":10286,"start2":10286,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"yScale: number // multiplier to match Y readings with X\n    zScale: number // multiplier to match Z readings with X\n    period: number // derived spin-rotation period in ms\n"],[1,"fieldSmoother: Smoother // uses a Smoother to maintain a rolling average"],[0,"\n   "]],"start1":10382,"start2":10382,"length1":181,"length2":80},{"diffs":[[0,"// S"],[-1,"CAN METHODS\n\n\n    // Perform a scan for specified time"],[1,"can Methods.....\n"],[0,"\n   "]],"start1":10540,"start2":10540,"length1":62,"length2":25},{"diffs":[[0,"sed "],[-1,"future "],[0,"read"]],"start1":12903,"start2":12903,"length1":15,"length2":8},{"diffs":[[0,"ed readings\n"],[1,"    \n"],[0,"    scope() "]],"start1":12904,"start2":12904,"length1":24,"length2":29},{"diffs":[[0,"all the scan"],[1,"Data"],[0," samples, el"]],"start1":14012,"start2":14012,"length1":24,"length2":28}]}]},{"timestamp":1727851618936,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n ms"],[-1,"\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)"],[0,"\n\n  "]],"start1":10691,"start2":10691,"length1":96,"length2":8},{"diffs":[[0,"\n    }\n\n"],[-1,"\n"],[1,"  "],[0,"    "],[-1,"//"],[1,"  /**"],[0," Method "]],"start1":14554,"start2":14554,"length1":23,"length2":27},{"diffs":[[0,"ors\n    "],[-1,"//"],[1,"         *"],[0," and the"]],"start1":14650,"start2":14650,"length1":18,"length2":26},{"diffs":[[0,"frame).\n"],[1,"        \n        */\n    "],[0,"    anal"]],"start1":14720,"start2":14720,"length1":16,"length2":40},{"diffs":[[0,"analyse() {\n"],[1,"    "],[0,"        /* g"]],"start1":14756,"start2":14756,"length1":24,"length2":28},{"diffs":[[0,"                "],[1,"  "],[1,"  "],[0,"[M, N, -] when c"]],"start1":14826,"start2":14826,"length1":32,"length2":36},{"diffs":[[0,"ng the XY plane\n"],[1,"    "],[0,"                "]],"start1":14867,"start2":14867,"length1":32,"length2":36},{"diffs":[[0,"ng the YZ plane\n"],[1,"    "],[0,"                "]],"start1":14924,"start2":14924,"length1":32,"length2":36},{"diffs":[[0,"X plane\n    "],[-1,"\n"],[1,"    \n    "],[0,"        ...a"]],"start1":14989,"start2":14989,"length1":25,"length2":33},{"diffs":[[0," that: \n"],[1,"    "],[0,"        "]],"start1":15032,"start2":15032,"length1":16,"length2":20},{"diffs":[[0,"rength)\n        "],[-1,"\n"],[1,"    \n    "],[0,"        ...we ca"]],"start1":15135,"start2":15135,"length1":33,"length2":41},{"diffs":[[0,"            "],[1,"    "],[0,"yScale = sqr"]],"start1":15250,"start2":15250,"length1":24,"length2":28},{"diffs":[[0,"- SSPP - NNQQ))\n"],[1,"    "],[0,"                "]],"start1":15309,"start2":15309,"length1":32,"length2":36},{"diffs":[[0,"        "],[1,"  "],[1,"  "],[0,"*/\n\n"],[1,"    "],[0,"        "]],"start1":15404,"start2":15404,"length1":20,"length2":28},{"diffs":[[0,"ction. \n"],[1,"    "],[0,"        "]],"start1":15482,"start2":15482,"length1":16,"length2":20},{"diffs":[[0,"ge.\n        "],[1,"    "],[0,"// counts of"]],"start1":15574,"start2":15574,"length1":24,"length2":28},{"diffs":[[0,"is scan\n        "],[1,"    "],[0,"let nCrossXY = 0"]],"start1":15632,"start2":15632,"length1":32,"length2":36},{"diffs":[[0,"sXY = 0\n        "],[1,"  "],[1,"  "],[0,"let nCrossYZ = 0"]],"start1":15661,"start2":15661,"length1":32,"length2":36},{"diffs":[[0,"sYZ = 0\n        "],[1,"   "],[1," "],[0,"let nCrossZX = 0"]],"start1":15690,"start2":15690,"length1":32,"length2":36},{"diffs":[[0,"CrossZX = 0\n"],[1,"    "],[0,"        // t"]],"start1":15715,"start2":15715,"length1":24,"length2":28},{"diffs":[[0,"rst\n        "],[1,"    "],[0,"let xStart ="]],"start1":15758,"start2":15758,"length1":24,"length2":28},{"diffs":[[0," -1\n        "],[1," "],[1,"   "],[0,"let yStart ="]],"start1":15786,"start2":15786,"length1":24,"length2":28},{"diffs":[[0," -1\n        "],[1,"  "],[1,"  "],[0,"let zStart ="]],"start1":15814,"start2":15814,"length1":24,"length2":28},{"diffs":[[0," -1\n        "],[1,"   "],[1," "],[0,"let xFinish "]],"start1":15842,"start2":15842,"length1":24,"length2":28},{"diffs":[[0,"let xFinish = 0\n"],[1,"    "],[0,"        let yFin"]],"start1":15858,"start2":15858,"length1":32,"length2":36},{"diffs":[[0,"= 0\n        "],[1,"    "],[0,"let zFinish "]],"start1":15898,"start2":15898,"length1":24,"length2":28},{"diffs":[[0,"let zFinish = 0\n"],[1,"    "],[0,"        let x = "]],"start1":15914,"start2":15914,"length1":32,"length2":36},{"diffs":[[0,"field.x\n        "],[1,"  "],[1,"  "],[0,"let y = samples["]],"start1":15961,"start2":15961,"length1":32,"length2":36},{"diffs":[[0,"field.y\n        "],[1,"   "],[1," "],[0,"let z = samples["]],"start1":16000,"start2":16000,"length1":32,"length2":36},{"diffs":[[0,"d.z\n        "],[1,"   "],[1," "],[0,"let xWas: nu"]],"start1":16043,"start2":16043,"length1":24,"length2":28},{"diffs":[[0,"et xWas: number\n"],[1,"    "],[0,"        let yWas"]],"start1":16060,"start2":16060,"length1":32,"length2":36},{"diffs":[[0,"ber\n        "],[1,"    "],[0,"let zWas: nu"]],"start1":16101,"start2":16101,"length1":24,"length2":28},{"diffs":[[0,"ber\n        "],[1," "],[1,"   "],[0,"// flags to "]],"start1":16130,"start2":16130,"length1":24,"length2":28},{"diffs":[[0,"ssings \n        "],[1,"    "],[0,"let needXY = tru"]],"start1":16195,"start2":16195,"length1":32,"length2":36},{"diffs":[[0," = true\n        "],[1,"   "],[1," "],[0,"let needYZ = tru"]],"start1":16225,"start2":16225,"length1":32,"length2":36},{"diffs":[[0,"t needYZ = true\n"],[1,"    "],[0,"        let need"]],"start1":16247,"start2":16247,"length1":32,"length2":36},{"diffs":[[0,"t needZX = true\n"],[1,"    "],[0,"        // we'll"]],"start1":16277,"start2":16277,"length1":32,"length2":36},{"diffs":[[0,"nts\n        "],[1," "],[1,"   "],[0,"let MM = 0\n "]],"start1":16365,"start2":16365,"length1":24,"length2":28},{"diffs":[[0,"= 0\n        "],[1,"  "],[1,"  "],[0,"let NN = 0\n "]],"start1":16388,"start2":16388,"length1":24,"length2":28},{"diffs":[[0,"= 0\n        "],[1,"   "],[1," "],[0,"let PP = 0\n "]],"start1":16411,"start2":16411,"length1":24,"length2":28},{"diffs":[[0," let PP = 0\n"],[1,"    "],[0,"        let "]],"start1":16426,"start2":16426,"length1":24,"length2":28},{"diffs":[[0,"= 0\n        "],[1,"    "],[0,"let RR = 0\n "]],"start1":16457,"start2":16457,"length1":24,"length2":28},{"diffs":[[0,"= 0\n        "],[1," "],[1,"   "],[0,"let SS = 0\n "]],"start1":16480,"start2":16480,"length1":24,"length2":28},{"diffs":[[0," let SS = 0\n"],[1,"    "],[0,"        for "]],"start1":16495,"start2":16495,"length1":24,"length2":28},{"diffs":[[0,"        "],[1,"   "],[1," "],[0,"xWas = x"]],"start1":16560,"start2":16560,"length1":16,"length2":20},{"diffs":[[0,"Was = x\n"],[1,"    "],[0,"        "]],"start1":16573,"start2":16573,"length1":16,"length2":20},{"diffs":[[0,"        "],[1,"    "],[0,"zWas = z"]],"start1":16610,"start2":16610,"length1":16,"length2":20},{"diffs":[[0,"        "],[1," "],[1,"   "],[0,"x = samp"]],"start1":16635,"start2":16635,"length1":16,"length2":20},{"diffs":[[0,"ples[i].field.x\n"],[1,"    "],[0,"            y = "]],"start1":16654,"start2":16654,"length1":32,"length2":36},{"diffs":[[0,"        "],[1,"  "],[1,"  "],[0,"z = samp"]],"start1":16713,"start2":16713,"length1":16,"length2":20},{"diffs":[[0,"i].field.z\n\n"],[1,"    "],[0,"            "]],"start1":16737,"start2":16737,"length1":24,"length2":28},{"diffs":[[0,"isons!)\n"],[1,"    "],[0,"        "]],"start1":16814,"start2":16814,"length1":16,"length2":20},{"diffs":[[0,"            "],[1,"    "],[0,"if (y == 0) "]],"start1":16859,"start2":16859,"length1":24,"length2":28},{"diffs":[[0,"0) y = yWas\n"],[1,"    "],[0,"            "]],"start1":16884,"start2":16884,"length1":24,"length2":28},{"diffs":[[0,"        "],[1,"  "],[1,"  "],[0,"// Look "]],"start1":16938,"start2":16938,"length1":16,"length2":20},{"diffs":[[0," flips)\n"],[1,"    "],[0,"        "]],"start1":17022,"start2":17022,"length1":16,"length2":20},{"diffs":[[0,"gnore)\n\n"],[1,"    "],[0,"        "]],"start1":17123,"start2":17123,"length1":16,"length2":20},{"diffs":[[0,"        "],[1,"    "],[0,"MM += x "]],"start1":17239,"start2":17239,"length1":16,"length2":20},{"diffs":[[0,"   MM += x ** 2\n"],[1,"    "],[0,"                "]],"start1":17248,"start2":17248,"length1":32,"length2":36},{"diffs":[[0,"            "],[1,"  "],[1,"  "],[0,"nCrossXY++\n "]],"start1":17301,"start2":17301,"length1":24,"length2":28},{"diffs":[[0,"ossXY++\n"],[1,"    "],[0,"        "]],"start1":17320,"start2":17320,"length1":16,"length2":20},{"diffs":[[0,"samples[i].time\n"],[1,"    "],[0,"                "]],"start1":17358,"start2":17358,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"needXY = false\n "]],"start1":17449,"start2":17449,"length1":32,"length2":36},{"diffs":[[0," needXY = false\n"],[1,"    "],[0,"                "]],"start1":17468,"start2":17468,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"  "],[1,"  "],[0,"needYZ = true\n  "]],"start1":17571,"start2":17571,"length1":32,"length2":36},{"diffs":[[0,"  needYZ = true\n"],[1,"    "],[0,"                "]],"start1":17589,"start2":17589,"length1":32,"length2":36},{"diffs":[[0,"rue\n            "],[-1,"}\n"],[1,"    }\n    "],[0,"            if ("]],"start1":17635,"start2":17635,"length1":34,"length2":42},{"diffs":[[0,"        "],[1,"    "],[0,"PP += y "]],"start1":17765,"start2":17765,"length1":16,"length2":20},{"diffs":[[0,"        "],[1," "],[1,"   "],[0,"QQ += z "]],"start1":17798,"start2":17798,"length1":16,"length2":20},{"diffs":[[0,"            "],[1,"    "],[0,"nCrossYZ++\n "]],"start1":17827,"start2":17827,"length1":24,"length2":28},{"diffs":[[0,"        "],[1,"   "],[1," "],[0,"xFinish "]],"start1":17862,"start2":17862,"length1":16,"length2":20},{"diffs":[[0,"samples[i].time\n"],[1,"    "],[0,"                "]],"start1":17884,"start2":17884,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"needYZ = false\n "]],"start1":17953,"start2":17953,"length1":32,"length2":36},{"diffs":[[0,"                "],[1," "],[1,"   "],[0,"needXY = true\n  "]],"start1":17988,"start2":17988,"length1":32,"length2":36},{"diffs":[[0,"  needXY = true\n"],[1,"    "],[0,"                "]],"start1":18006,"start2":18006,"length1":32,"length2":36},{"diffs":[[0,"rue\n            "],[-1,"}\n"],[1,"    }\n    "],[0,"            if ("]],"start1":18052,"start2":18052,"length1":34,"length2":42},{"diffs":[[0,"        "],[1,"    "],[0,"RR += x "]],"start1":18182,"start2":18182,"length1":16,"length2":20},{"diffs":[[0,"        "],[1," "],[1,"   "],[0,"SS += z "]],"start1":18215,"start2":18215,"length1":16,"length2":20},{"diffs":[[0,"            "],[1,"    "],[0,"nCrossZX++\n "]],"start1":18244,"start2":18244,"length1":24,"length2":28},{"diffs":[[0,"        "],[1,"   "],[1," "],[0,"yFinish "]],"start1":18279,"start2":18279,"length1":16,"length2":20},{"diffs":[[0,"samples[i].time\n"],[1,"    "],[0,"                "]],"start1":18301,"start2":18301,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"needZX = false\n "]],"start1":18370,"start2":18370,"length1":32,"length2":36},{"diffs":[[0,"                "],[1," "],[1,"   "],[0,"needXY = true\n  "]],"start1":18405,"start2":18405,"length1":32,"length2":36},{"diffs":[[0,"  needXY = true\n"],[1,"    "],[0,"                "]],"start1":18423,"start2":18423,"length1":32,"length2":36},{"diffs":[[0,"rue\n            "],[1,"   "],[1," "],[0,"}\n"],[1,"    "],[0,"        }\n      "]],"start1":18469,"start2":18469,"length1":34,"length2":42},{"diffs":[[0,"}\n            }\n"],[1,"    "],[0,"        // avera"]],"start1":18489,"start2":18489,"length1":32,"length2":36},{"diffs":[[0,"        "],[1,"    "],[0,"MM /= nC"]],"start1":18556,"start2":18556,"length1":16,"length2":20},{"diffs":[[0,"        "],[1," "],[1,"   "],[0,"NN /= nC"]],"start1":18583,"start2":18583,"length1":16,"length2":20},{"diffs":[[0,"        "],[1,"  "],[1,"  "],[0,"PP /= nC"]],"start1":18610,"start2":18610,"length1":16,"length2":20},{"diffs":[[0,"        "],[1,"   "],[1," "],[0,"QQ /= nC"]],"start1":18637,"start2":18637,"length1":16,"length2":20},{"diffs":[[0," QQ /= nCrossYZ\n"],[1,"    "],[0,"        RR /= nC"]],"start1":18648,"start2":18648,"length1":32,"length2":36},{"diffs":[[0,"        "],[1,"    "],[0,"SS /= nC"]],"start1":18691,"start2":18691,"length1":16,"length2":20},{"diffs":[[0,"rossZX\n\n"],[1,"    "],[0,"        "]],"start1":18711,"start2":18711,"length1":16,"length2":20},{"diffs":[[0,"on)\n        "],[1,"  "],[1,"  "],[0,"let xFlip = "]],"start1":18792,"start2":18792,"length1":24,"length2":28},{"diffs":[[0," 1)\n        "],[1,"   "],[1," "],[0,"let yFlip = "]],"start1":18852,"start2":18852,"length1":24,"length2":28},{"diffs":[[0,"rossZX - 1)\n"],[1,"    "],[0,"        let "]],"start1":18904,"start2":18904,"length1":24,"length2":28},{"diffs":[[0,"Y - 1)\n\n        "],[1,"    "],[0,"// average the t"]],"start1":18969,"start2":18969,"length1":32,"length2":36},{"diffs":[[0,"iod\n        "],[1,"    "],[0,"scanPeriod ="]],"start1":19077,"start2":19077,"length1":24,"length2":28},{"diffs":[[0,".5\n\n        "],[1,"  "],[1,"  "],[0,"// construct"]],"start1":19133,"start2":19133,"length1":24,"length2":28},{"diffs":[[0,"scaling factors\n"],[1,"    "],[0,"        let bott"]],"start1":19175,"start2":19175,"length1":32,"length2":36},{"diffs":[[0,"N * QQ)\n"],[1,"    "],[0,"        "]],"start1":19242,"start2":19242,"length1":16,"length2":20},{"diffs":[[0,"om)\n        "],[1,"    "],[0,"this.zScale "]],"start1":19326,"start2":19326,"length1":24,"length2":28},{"diffs":[[0,"ottom)\n\n"],[1,"    "],[0,"        "]],"start1":19403,"start2":19403,"length1":16,"length2":20},{"diffs":[[0,"                "],[1,"  "],[1,"  "],[0,"[M, N, -] when c"]],"start1":19501,"start2":19501,"length1":32,"length2":36},{"diffs":[[0,"ng the XY plane\n"],[1,"    "],[0,"                "]],"start1":19542,"start2":19542,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"   "],[1," "],[0,"[R, -, S] when c"]],"start1":19615,"start2":19615,"length1":32,"length2":36},{"diffs":[[0,"X plane\n        "],[-1,"*/\n"],[1,"    */\n    "],[0,"        let M = "]],"start1":19664,"start2":19664,"length1":35,"length2":43},{"diffs":[[0,"MM)\n        "],[1," "],[1,"   "],[0,"let N = Math"]],"start1":19717,"start2":19717,"length1":24,"length2":28},{"diffs":[[0,"ale\n        "],[1,"  "],[1,"  "],[0,"let P = Math"]],"start1":19760,"start2":19760,"length1":24,"length2":28},{"diffs":[[0,"ale\n        "],[1,"   "],[1," "],[0,"let Q = Math"]],"start1":19803,"start2":19803,"length1":24,"length2":28},{"diffs":[[0,"Q) * zScale\n"],[1,"    "],[0,"        let "]],"start1":19838,"start2":19838,"length1":24,"length2":28},{"diffs":[[0,"RR)\n        "],[1,"    "],[0,"let S = Math"]],"start1":19880,"start2":19880,"length1":24,"length2":28},{"diffs":[[0,"le\n\n        "],[1," "],[1,"   "],[0,"// since the"]],"start1":19924,"start2":19924,"length1":24,"length2":28},{"diffs":[[0,"he \n        "],[1,"    "],[0,"// cross-pro"]],"start1":20046,"start2":20046,"length1":24,"length2":28},{"diffs":[[0,"xis\n        "],[1,"   "],[1," "],[0,"let I = (Q *"]],"start1":20131,"start2":20131,"length1":24,"length2":28},{"diffs":[[0,"(S * P)\n"],[1,"    "],[0,"        "]],"start1":20175,"start2":20175,"length1":16,"length2":20},{"diffs":[[0," S)\n        "],[1,"    "],[0,"let K = (N *"]],"start1":20227,"start2":20227,"length1":24,"length2":28},{"diffs":[[0,"P * M)\n\n        "],[-1,"this."],[1,"    "],[0,"downXYZ = new Ve"]],"start1":20272,"start2":20272,"length1":37,"length2":36},{"diffs":[[0,"        "],[1,"  "],[-1,"this."],[1,"  "],[0,"downXYZ "]],"start1":20322,"start2":20322,"length1":21,"length2":20},{"diffs":[[0,"wnXYZ = "],[-1,"this."],[0,"downXYZ."]],"start1":20336,"start2":20336,"length1":21,"length2":16},{"diffs":[[0,"lised()\n"],[-1,"\n\n"],[1,"    "],[0,"        "]],"start1":20357,"start2":20357,"length1":18,"length2":20},{"diffs":[[0,"    "],[-1,"}\n\n    // dump this scan (and its analysis) to the datalogger\n    dump() {\n        for (let i = 0; i < this.nSamples; i++) {\n            datalogger.log(\n                datalogger.createCV(\"data\", \"raw scan\"),\n                datalogger.createCV(\"fx\", this.samples[i].x),\n                datalogger.createCV(\"fy\", this.samples[i].y),\n                datalogger.createCV(\"fz\", this.samples[i].z))\n        }\n\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.yScale),\n            datalogger.createCV(\"zScale\", this.zScale),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n"],[1,"    }"],[0,"\n   "]],"start1":20409,"start2":20409,"length1":725,"length2":13},{"diffs":[[0,"ding))\n}\n\n\n\n"],[1,"function dumpScanData() {\n    for (let i = 0; i < samples.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"raw scan\"),\n            datalogger.createCV(\"fx\", samples[i].field.x),\n            datalogger.createCV(\"fy\", samples[i].field.y),\n            datalogger.createCV(\"fz\", samples[i].field.z))\n    }\n\n    datalogger.log(\n        datalogger.createCV(\"yScale\", yScale),\n        datalogger.createCV(\"zScale\", zScale),\n        datalogger.createCV(\"downX\", downXYZ.x),\n        datalogger.createCV(\"downY\", downXYZ.y),\n        datalogger.createCV(\"downZ\", downXYZ.z))\n\n}\n\n"],[0,"function dum"]],"start1":29702,"start2":29702,"length1":24,"length2":623}]}]},{"timestamp":1727852128384,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"rmScan\n\n"],[-1,"// "],[0,"let scan"]],"start1":531,"start2":531,"length1":19,"length2":16},{"diffs":[[0,"\n    }\n}*/\n\n"],[1,"class Correction {\n    offset: Vector\n    constructor ()\n}\n\n\n"],[0,"class Scan {"]],"start1":10069,"start2":10069,"length1":24,"length2":85},{"diffs":[[0,"lass Scan {\n"],[-1,""],[0,"    samples:"]],"start1":10143,"start2":10143,"length1":24,"length2":24},{"diffs":[[0,"    && ("],[-1,"this."],[0,"samples."]],"start1":11727,"start2":11727,"length1":21,"length2":16},{"diffs":[[0,"(let i = 0; i < "],[-1,"this."],[0,"nSamples; i++) {"]],"start1":13471,"start2":13471,"length1":37,"length2":32},{"diffs":[[0,"th.max(xhi, "],[-1,"this."],[0,"samples[i].f"]],"start1":13524,"start2":13524,"length1":29,"length2":24},{"diffs":[[0,"th.max(yhi, "],[-1,"this."],[0,"samples[i].f"]],"start1":13576,"start2":13576,"length1":29,"length2":24},{"diffs":[[0,"ax(zhi, "],[-1,"this."],[0,"samples["]],"start1":13632,"start2":13632,"length1":21,"length2":16},{"diffs":[[0,"th.min(xlo, "],[-1,"this."],[0,"samples[i].f"]],"start1":13680,"start2":13680,"length1":29,"length2":24},{"diffs":[[0,"th.min(ylo, "],[-1,"this."],[0,"samples[i].f"]],"start1":13732,"start2":13732,"length1":29,"length2":24},{"diffs":[[0,"in(zlo, "],[-1,"this."],[0,"samples["]],"start1":13788,"start2":13788,"length1":21,"length2":16},{"diffs":[[0,"ecentre() {\n"],[-1,"    "],[0,"    // re-ce"]],"start1":14348,"start2":14348,"length1":28,"length2":24},{"diffs":[[0,"ffects.\n"],[-1,"    "],[0,"    for "]],"start1":14447,"start2":14447,"length1":20,"length2":16},{"diffs":[[0," i++) {\n        "],[-1,"    "],[0,"this.samples[i]."]],"start1":14488,"start2":14488,"length1":36,"length2":32},{"diffs":[[0,"ffset.x\n        "],[-1,"   "],[-1," "],[0,"this.samples[i]."]],"start1":14537,"start2":14537,"length1":36,"length2":32},{"diffs":[[0,"is.offset.y\n"],[-1,"    "],[0,"        this"]],"start1":14582,"start2":14582,"length1":28,"length2":24},{"diffs":[[0,"ffset.z\n    "],[-1,"  "],[-1,"  }\n    "],[0,"}"],[1,"\n"],[0,"\n\n    // Met"]],"start1":14635,"start2":14635,"length1":35,"length2":26},{"diffs":[[0," Window\n"],[-1,"\n"],[0,"    data"]],"start1":31670,"start2":31670,"length1":17,"length2":16},{"diffs":[[0,"nXYZ"],[-1,".z))"],[0,"\n    "],[-1,"\n\n    return 333"],[0,"\n}\n\n"]],"start1":32017,"start2":32017,"length1":33,"length2":13}]}]},{"timestamp":1727852721613,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"adings\n\n"],[1,"let strength = 0 // the a\n"],[0,"// Senso"]],"start1":664,"start2":664,"length1":16,"length2":42},{"diffs":[[0,"ields[]\n"],[1,"    nSamples: number\n"],[0,"    fiel"]],"start1":10233,"start2":10233,"length1":16,"length2":37},{"diffs":[[0,"h X\n"],[-1,"    strength: number // the average magnetic field-strength detected on a scan \n"],[0,"    "]],"start1":10577,"start2":10577,"length1":88,"length2":8},{"diffs":[[0,"0; i < this."],[-1,"s"],[1,"nS"],[0,"amples"],[-1,".length"],[0,"; i++) {\n   "]],"start1":13427,"start2":13427,"length1":38,"length2":32},{"diffs":[[0,"this.samples[i]."],[1,"field."],[0,"x)\n            y"]],"start1":13488,"start2":13488,"length1":32,"length2":38},{"diffs":[[0,"this.samples[i]."],[-1,"y"],[1,"field.x"],[0,")\n            zh"]],"start1":13545,"start2":13545,"length1":33,"length2":39},{"diffs":[[0,"this.samples[i]."],[-1,"z"],[1,"field.y"],[0,")\n            xl"]],"start1":13602,"start2":13602,"length1":33,"length2":39},{"diffs":[[0,"ples[i]."],[-1,"x"],[1,"field.y"],[0,")\n      "]],"start1":13667,"start2":13667,"length1":17,"length2":23},{"diffs":[[0,"ples[i]."],[-1,"y"],[1,"field.z"],[0,")\n      "]],"start1":13724,"start2":13724,"length1":17,"length2":23},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"z)\n     "]],"start1":13781,"start2":13781,"length1":16,"length2":22},{"diffs":[[0,"h.sqrt(("],[-1,"this."],[0,"swing.x "]],"start1":14028,"start2":14028,"length1":21,"length2":16},{"diffs":[[0,"ing.x * "],[-1,"this."],[0,"swing.x)"]],"start1":14038,"start2":14038,"length1":21,"length2":16},{"diffs":[[0,".x) "],[-1,"\n                                + (this."],[1,"+ ("],[0,"swin"]],"start1":14051,"start2":14051,"length1":49,"length2":11},{"diffs":[[0,"ing.y * "],[-1,"this."],[0,"swing.y)"]],"start1":14060,"start2":14060,"length1":21,"length2":16},{"diffs":[[0,".y) "],[-1,"\n                                + (this."],[1,"+ ("],[0,"swin"]],"start1":14073,"start2":14073,"length1":49,"length2":11},{"diffs":[[0,"ing.z * "],[-1,"this."],[0,"swing.x)"]],"start1":14082,"start2":14082,"length1":21,"length2":16},{"diffs":[[0," 0; i < "],[-1,"this.samples.length"],[1,"nSamples"],[0,"; i++) {"]],"start1":14461,"start2":14461,"length1":35,"length2":24},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"x -= thi"]],"start1":14506,"start2":14506,"length1":16,"length2":22},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"y -= thi"]],"start1":14559,"start2":14559,"length1":16,"length2":22},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"z -= thi"]],"start1":14612,"start2":14612,"length1":16,"length2":22},{"diffs":[[0,"*/\n\n"],[-1,"        // we'll mostly be using the squares of the zero-crossing components\n        let MM: number\n        let NN: number\n        let PP: number\n        let QQ: number\n        let RR: number\n        let SS: number\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n"],[0,"    "]],"start1":15431,"start2":15431,"length1":327,"length2":8},{"diffs":[[0,"let x = "],[-1,"this."],[0,"samples["]],"start1":15901,"start2":15901,"length1":21,"length2":16},{"diffs":[[0,"ples[0]."],[1,"field."],[0,"x\n      "]],"start1":15912,"start2":15912,"length1":16,"length2":22},{"diffs":[[0,"let y = "],[-1,"this."],[0,"samples["]],"start1":15936,"start2":15936,"length1":21,"length2":16},{"diffs":[[0,"ples[0]."],[1,"field."],[0,"y\n      "]],"start1":15947,"start2":15947,"length1":16,"length2":22},{"diffs":[[0,"let z = "],[-1,"this."],[0,"samples["]],"start1":15971,"start2":15971,"length1":21,"length2":16},{"diffs":[[0,"ples[0]."],[1,"field."],[0,"z\n      "]],"start1":15982,"start2":15982,"length1":16,"length2":22},{"diffs":[[0,"field.z\n        "],[1,"let xWas: number\n        let yWas: number\n        let zWas: number"],[0,"\n        // flag"]],"start1":15990,"start2":15990,"length1":32,"length2":98},{"diffs":[[0," = true\n        "],[1,"// we'll mostly use the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0"],[0,"\n        for (le"]],"start1":16208,"start2":16208,"length1":32,"length2":209},{"diffs":[[0," 0; i < "],[-1,"this.samples.length"],[1,"nSamples"],[0,"; i++) {"]],"start1":16422,"start2":16422,"length1":35,"length2":24},{"diffs":[[0," < this."],[-1,"this.samples.length"],[1,"nSamples"],[0,"; i++) {"]],"start1":20101,"start2":20101,"length1":35,"length2":24},{"diffs":[[0,") \n\n    "],[-1,"this.samples.length"],[1,"nSamples"],[0," = sampl"]],"start1":27792,"start2":27792,"length1":35,"length2":24},{"diffs":[[0,"samples["],[-1,"this.samples.length"],[1,"nSamples"],[0," - 1].ti"]],"start1":28020,"start2":28020,"length1":35,"length2":24},{"diffs":[[0,"   if (("],[-1,"this.samples.length"],[1,"nSamples"],[0," < Enoug"]],"start1":28066,"start2":28066,"length1":35,"length2":24},{"diffs":[[0," 0; i < "],[-1,"this.samples.length"],[1,"nSamples"],[0,"; i++) {"]],"start1":28694,"start2":28694,"length1":35,"length2":24}]}]},{"timestamp":1727853266333,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"bugging\n"],[-1,"let scan: Scan"],[0,"\nlet tes"]],"start1":611,"start2":611,"length1":30,"length2":16},{"diffs":[[0,"rection."],[1," "],[0,"\n       "]],"start1":15902,"start2":15902,"length1":16,"length2":17},{"diffs":[[0,"verage.\n"],[-1,"\n"],[0,"        "]],"start1":15988,"start2":15988,"length1":17,"length2":16},{"diffs":[[0,"/ time-stamp"],[-1,"s"],[0," of first cr"]],"start1":16138,"start2":16138,"length1":25,"length2":24},{"diffs":[[0,"irst"],[-1," crossings (not yet found)"],[0,"\n   "]],"start1":16155,"start2":16155,"length1":34,"length2":8},{"diffs":[[0,"    "],[-1,"// timestamps of last crossings"],[1,"let xFinish = 0\n        let yFinish = 0"],[0,"\n   "]],"start1":16236,"start2":16236,"length1":39,"length2":47},{"diffs":[[0,"let "],[-1,"x"],[1,"z"],[0,"Finish"],[-1,": number\n        let yFinish: number\n        let zFinish: number\n"],[1," = 0\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        "],[0,"\n   "]],"start1":16288,"start2":16288,"length1":80,"length2":130},{"diffs":[[0,"true"],[-1,"\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z"],[0,"\n   "]],"start1":16553,"start2":16553,"length1":111,"length2":8},{"diffs":[[0,"        x = "],[-1,"this."],[0,"samples[i].x"]],"start1":16690,"start2":16690,"length1":29,"length2":24},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"x\n      "]],"start1":16705,"start2":16705,"length1":16,"length2":22},{"diffs":[[0,"        y = "],[-1,"this."],[0,"samples[i].y"]],"start1":16725,"start2":16725,"length1":29,"length2":24},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"y\n      "]],"start1":16740,"start2":16740,"length1":16,"length2":22},{"diffs":[[0,"        z = "],[-1,"this."],[0,"samples[i].z"]],"start1":16760,"start2":16760,"length1":29,"length2":24},{"diffs":[[0,"ples[i]."],[1,"field."],[0,"z\n\n     "]],"start1":16775,"start2":16775,"length1":16,"length2":22},{"diffs":[[0,"s (they "],[-1,"only "],[0,"complica"]],"start1":16828,"start2":16828,"length1":21,"length2":16},{"diffs":[[0,"  zFinish = "],[-1,"this.times[i]"],[1,"samples[i].time"],[0,"\n           "]],"start1":17345,"start2":17345,"length1":37,"length2":39},{"diffs":[[0,"ot this "],[-1,"plane"],[1,"axis"],[0,"-crossin"]],"start1":17495,"start2":17495,"length1":21,"length2":20},{"diffs":[[0,"ow other"],[-1," plane"],[0,"s to be "]],"start1":17533,"start2":17533,"length1":22,"length2":16},{"diffs":[[0,"  xFinish = "],[-1,"this.times[i]"],[1,"samples[i].time"],[0,"\n           "]],"start1":17827,"start2":17827,"length1":37,"length2":39},{"diffs":[[0,"h = "],[-1,"this.times[i]"],[1,"samples[i].time"],[0,"\n   "]],"start1":18212,"start2":18212,"length1":21,"length2":23},{"diffs":[[0,"        "],[-1,"this.p"],[1,"scanP"],[0,"eriod = "]],"start1":18924,"start2":18924,"length1":22,"length2":21},{"diffs":[[0,".sqrt(NN) * "],[-1,"this."],[0,"yScale\n     "]],"start1":19540,"start2":19540,"length1":29,"length2":24},{"diffs":[[0,"t(PP) * "],[-1,"this."],[0,"yScale\n "]],"start1":19583,"start2":19583,"length1":21,"length2":16},{"diffs":[[0,".sqrt(QQ) * "],[-1,"this."],[0,"zScale\n     "]],"start1":19618,"start2":19618,"length1":29,"length2":24},{"diffs":[[0,"t(MM) * "],[-1,"this."],[0,"zScale\n\n"]],"start1":19691,"start2":19691,"length1":21,"length2":16},{"diffs":[[0,"(let i = 0; i < "],[1,"this."],[0,"this.samples.len"]],"start1":20264,"start2":20264,"length1":32,"length2":37}]}]},{"timestamp":1727853854554,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"            "],[1," result ="],[0," scan.acquir"]],"start1":22551,"start2":22551,"length1":24,"length2":33},{"diffs":[[0,"000)"],[-1,"\n                result = 0"],[0,"\n\n  "]],"start1":22587,"start2":22587,"length1":35,"length2":8},{"diffs":[[0,"can.dump"],[1,"Data"],[0,"()\n     "]],"start1":22683,"start2":22683,"length1":16,"length2":20}]}]},{"timestamp":1727853944460,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"-7.617\n    }\n}\n\n"],[1,"function simulateScan(dataset: string) {\n    let times: number[]\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < times.length; i++) {\n        let sample = new Sample(times[i], xData[i], yData[i], zData[i])\n        samples.push(sample)\n    }\n    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n    }\n    return 0\n}\n"],[0,"\n// ============"]],"start1":33187,"start2":33187,"length1":32,"length2":23221}]}]},{"timestamp":1727860425458,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   }"],[-1,"\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < times.length; i++) {\n        let sample = new Sample(times[i], xData[i], yData[i], zData[i])\n        samples.push(sample)\n    }\n    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n    }\n    return 0\n}"],[0,"\n\n  "]],"start1":20284,"start2":20284,"length1":23197,"length2":8}]}]},{"timestamp":1727860452773,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"\n\n    // adopt a previously-recorded dataset\n    adopt"],[1,"function simulateScan"],[0,"(dat"]],"start1":20285,"start2":20285,"length1":62,"length2":29},{"diffs":[[0,": string) {\n    "],[-1,"  "],[-1,"  "],[0,"let times: numbe"]],"start1":20318,"start2":20318,"length1":36,"length2":32},{"diffs":[[0,"umber[]\n    "],[-1,"  "],[-1,"  "],[0,"let xData: n"]],"start1":20346,"start2":20346,"length1":28,"length2":24},{"diffs":[[0,"[] = []\n    "],[-1,"   "],[-1," "],[0,"let yData: n"]],"start1":20375,"start2":20375,"length1":28,"length2":24},{"diffs":[[0,"[] = []\n    "],[-1,"   "],[-1," "],[0,"let zData: n"]],"start1":20404,"start2":20404,"length1":28,"length2":24},{"diffs":[[0,": number[] = []\n"],[-1,"    "],[0,"    let xTest: n"]],"start1":20425,"start2":20425,"length1":36,"length2":32},{"diffs":[[0,": number[] = []\n"],[-1,"    "],[0,"    let yTest: n"]],"start1":20454,"start2":20454,"length1":36,"length2":32},{"diffs":[[0,"mber[] = []\n"],[-1,"    "],[0,"    let zTes"]],"start1":20487,"start2":20487,"length1":28,"length2":24},{"diffs":[[0,"mber[] = []\n"],[-1,"    "],[0,"    switch ("]],"start1":20516,"start2":20516,"length1":28,"length2":24},{"diffs":[[0,"set) {\n\n        "],[-1," "],[-1,"   "],[0,"case \"T07141743_"]],"start1":20544,"start2":20544,"length1":36,"length2":32},{"diffs":[[0,"upwards; dip=70\n"],[-1,"    "],[0,"            time"]],"start1":20600,"start2":20600,"length1":36,"length2":32},{"diffs":[[0,"49]\n            "],[-1,"  "],[-1,"  "],[0,"xData = [887.59,"]],"start1":22446,"start2":22446,"length1":36,"length2":32},{"diffs":[[0,"881.16]\n"],[-1,"    "],[0,"        "]],"start1":24526,"start2":24526,"length1":20,"length2":16},{"diffs":[[0,"09]\n            "],[-1,"   "],[-1," "],[0,"zData = [424.65,"]],"start1":26860,"start2":26860,"length1":36,"length2":32},{"diffs":[[0,"74]\n            "],[-1,"    "],[0,"xTest = [881.04,"]],"start1":28922,"start2":28922,"length1":36,"length2":32},{"diffs":[[0,"879.79]\n"],[-1,"    "],[0,"        "]],"start1":29139,"start2":29139,"length1":20,"length2":16},{"diffs":[[0,"11]\n            "],[-1," "],[-1,"   "],[0,"zTest = [430.54,"]],"start1":29388,"start2":29388,"length1":36,"length2":32},{"diffs":[[0,".5]\n            "],[-1,"    "],[0,"break\n\n         "]],"start1":29608,"start2":29608,"length1":36,"length2":32},{"diffs":[[0,"ak\n\n        "],[-1," "],[-1,"   "],[0,"case \"T07260"]],"start1":29627,"start2":29627,"length1":28,"length2":24},{"diffs":[[0,"h-board: dip=70\n"],[-1,"    "],[0,"            time"]],"start1":29692,"start2":29692,"length1":36,"length2":32},{"diffs":[[0,"37]\n            "],[-1,"  "],[-1,"  "],[0,"xData = [-17.069"]],"start1":32224,"start2":32224,"length1":36,"length2":32},{"diffs":[[0,"36]\n            "],[-1,"    "],[0,"yData = [-4.611,"]],"start1":35287,"start2":35287,"length1":36,"length2":32},{"diffs":[[0,"24]\n            "],[-1,"   "],[-1," "],[0,"zData = [80.422,"]],"start1":38032,"start2":38032,"length1":36,"length2":32},{"diffs":[[0,"13]\n            "],[-1,"    "],[0,"xTest = [1.093, "]],"start1":40927,"start2":40927,"length1":36,"length2":32},{"diffs":[[0,"43]\n            "],[-1,"    "],[0,"yTest = [9.086, "]],"start1":41550,"start2":41550,"length1":36,"length2":32},{"diffs":[[0,".7]\n            "],[-1," "],[-1,"   "],[0,"zTest = [75.514,"]],"start1":42122,"start2":42122,"length1":36,"length2":32},{"diffs":[[0,"75]\n    "],[-1,"    }\n  "],[1,"}\n"],[0,"    "],[-1,"  "],[0,"let gxTe"]],"start1":42722,"start2":42722,"length1":30,"length2":22},{"diffs":[[0,"24, 25]\n    "],[-1,"   "],[-1," "],[0,"let gyTest ="]],"start1":42836,"start2":42836,"length1":28,"length2":24},{"diffs":[[0,"24, 25]\n    "],[-1,"   "],[-1," "],[0,"let gzTest ="]],"start1":42948,"start2":42948,"length1":28,"length2":24},{"diffs":[[0,"4, 25]\n\n"],[-1,"    "],[0,"    // t"]],"start1":43061,"start2":43061,"length1":20,"length2":16},{"diffs":[[0,"triples\n"],[-1,"    "],[0,"    for "]],"start1":43117,"start2":43117,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"    this.samples.push(new Vector("],[1,"let sample = new Sample(times[i], "],[0,"xDat"]],"start1":43174,"start2":43174,"length1":41,"length2":42},{"diffs":[[0,"], zData[i])"],[-1,")"],[0,"\n           "]],"start1":43229,"start2":43229,"length1":25,"length2":24},{"diffs":[[0,"    "],[-1,"    this, times.push(times[i])\n    "],[1,"samples.push(sample)\n"],[0,"    "]],"start1":43246,"start2":43246,"length1":43,"length2":29},{"diffs":[[0,"  }\n    "],[-1,"    /*"],[1,"//"],[0," do the "]],"start1":43273,"start2":43273,"length1":22,"length2":18},{"diffs":[[0,"t cases\n"],[-1,"    "],[0,"    for "]],"start1":43307,"start2":43307,"length1":20,"length2":16},{"diffs":[[0,"gth; n++) {\n"],[-1,"    "],[0,"        let "]],"start1":43348,"start2":43348,"length1":28,"length2":24},{"diffs":[[0,"    "],[-1,"    }\n        */\n    "],[1,"}\n"],[0,"    "]],"start1":43457,"start2":43457,"length1":29,"length2":10},{"diffs":[[0,"eturn 0\n"],[-1,"    "],[0,"}\n\n    /"]],"start1":43468,"start2":43468,"length1":20,"length2":16}]}]},{"timestamp":1727860668326,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sult = s"],[1,"imulateS"],[0,"ca"],[1,"n"],[0,"(\"T07260"]],"start1":45882,"start2":45882,"length1":18,"length2":27}]}]},{"timestamp":1727936966544,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lt = sca"],[-1,"n"],[0,"(\"T07260"]],"start1":45884,"start2":45884,"length1":17,"length2":16}]}]},{"timestamp":1727936967965,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"point...\n    }\n\n"],[1,"\n"],[0,"    // adopt a p"]],"start1":20274,"start2":20274,"length1":32,"length2":33},{"diffs":[[0,"    "],[-1,"use(samples: Vector[], tim"],[1,"adopt(dataset: string) {\n        let times: number[]\n        let xData: number[] = []\n        let yData: number[] = []\n        let zData: number[] = []\n        let xTest: number[] = []\n        let yT"],[0,"es"],[1,"t"],[0,": nu"]],"start1":20334,"start2":20334,"length1":36,"length2":210},{"diffs":[[0,"er[]"],[1," = []\n        let zTest: number[] = []\n        switch (dataset"],[0,") {\n"],[1,"\n  "],[0,"        "],[-1,"this.samples = samples\n        this.times = times\n    }\n"],[1,"  case \"T07141743_blup70\": // bottom-left upwards; dip=70\n                times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n                xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n                yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n                zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n                xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n                yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n                zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n                break\n\n            case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n                times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n                xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n                yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n                zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n                xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n                yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n                zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n        }\n        let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n        let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n        let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n        // transpose the three arrays into array of triples\n        for (let i = 0; i < times.length; i++) {\n            this.samples.push(new Vector(xData[i], yData[i], zData[i]))\n            this, times.push(times[i])\n        }\n        /* do the same for the test cases\n        for (let n = 0; n < xTest.length; n++) {\n            let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n        }\n        */\n        return 0\n    }"],[0,"\n\n  "]],"start1":20546,"start2":20546,"length1":76,"length2":23141},{"diffs":[[0,"sult = s"],[-1,"imulateS"],[0,"can(\"T07"]],"start1":45882,"start2":45882,"length1":24,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"function simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < times.length; i++) {\n        samples.push(new Vector(xData[i], yData[i], zData[i]))\n        times.push(times[i])\n    }\n\n    // adopt them, as if just scanned\n    scan.use(samples, times)\n\n    return 0\n}\n\n\n"],[0,"\n// "]],"start1":56586,"start2":56586,"length1":23104,"length2":8}]}]},{"timestamp":1727937564850,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"let "],[-1,"scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY"],[1,"xData: number[] = []\n    let yData"],[0,": nu"]],"start1":33458,"start2":33458,"length1":139,"length2":42},{"diffs":[[0,"    let "],[-1,"testFieldZ"],[1,"zData"],[0,": number"]],"start1":33512,"start2":33512,"length1":26,"length2":21},{"diffs":[[0,"    let "],[-1,"t"],[1,"xT"],[0,"est"],[-1,"PoseX"],[0,": number"]],"start1":33541,"start2":33541,"length1":25,"length2":21},{"diffs":[[0,"    let "],[-1,"t"],[1,"yT"],[0,"est"],[-1,"PoseY"],[0,": number"]],"start1":33570,"start2":33570,"length1":25,"length2":21},{"diffs":[[0,"    let "],[-1,"t"],[1,"zT"],[0,"est"],[-1,"PoseZ"],[0,": number"]],"start1":33599,"start2":33599,"length1":25,"length2":21},{"diffs":[[0,"            "],[-1,"scanX"],[1,"xData"],[0," = [887.59, "]],"start1":35550,"start2":35550,"length1":29,"length2":29},{"diffs":[[0,"            "],[-1,"scanY"],[1,"yData"],[0," = [1586.86,"]],"start1":37634,"start2":37634,"length1":29,"length2":29},{"diffs":[[0,"            "],[-1,"scanZ"],[1,"zData"],[0," = [424.65, "]],"start1":39964,"start2":39964,"length1":29,"length2":29},{"diffs":[[0,"            "],[-1,"t"],[1,"xT"],[0,"est"],[-1,"FieldX"],[0," = [881.04, "]],"start1":42026,"start2":42026,"length1":34,"length2":29},{"diffs":[[0,"            "],[-1,"t"],[1,"yT"],[0,"est"],[-1,"FieldY"],[0," = [1566.06,"]],"start1":42247,"start2":42247,"length1":34,"length2":29},{"diffs":[[0,"            "],[-1,"t"],[1,"zT"],[0,"est"],[-1,"FieldZ"],[0," = [430.54, "]],"start1":42492,"start2":42492,"length1":34,"length2":29},{"diffs":[[0,".5]\n"],[-1,"            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n"],[0,"    "]],"start1":42708,"start2":42708,"length1":137,"length2":8},{"diffs":[[0,"        "],[-1,"scanX"],[1,"xData"],[0," = [-17."]],"start1":45332,"start2":45332,"length1":21,"length2":21},{"diffs":[[0,"        "],[-1,"scanY"],[1,"yData"],[0," = [-4.6"]],"start1":48395,"start2":48395,"length1":21,"length2":21},{"diffs":[[0,"        "],[-1,"scanZ"],[1,"zData"],[0," = [80.4"]],"start1":51140,"start2":51140,"length1":21,"length2":21},{"diffs":[[0,"    "],[-1,"t"],[1,"xT"],[0,"est"],[-1,"FieldX"],[0," = ["]],"start1":54039,"start2":54039,"length1":18,"length2":13},{"diffs":[[0,"    "],[-1,"t"],[1,"yT"],[0,"est"],[-1,"FieldY"],[0," = ["]],"start1":54662,"start2":54662,"length1":18,"length2":13},{"diffs":[[0,"    "],[-1,"t"],[1,"zT"],[0,"est"],[-1,"FieldZ"],[0," = ["]],"start1":55234,"start2":55234,"length1":18,"length2":13},{"diffs":[[0,"    "],[-1,"        // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n"],[0,"}\n  "]],"start1":55826,"start2":55826,"length1":147,"length2":8},{"diffs":[[0,"tor("],[-1,"scanX[i], scanY[i], scanZ"],[1,"xData[i], yData[i], zData"],[0,"[i])"]],"start1":56298,"start2":56298,"length1":33,"length2":33},{"diffs":[[0,"s)\n\n"],[-1,"    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n        tests.push(reading)\n    }\n    if (testPoseX.length > 0 ) {\n    } else {\n\n    }\n    */\n"],[0,"    "]],"start1":56433,"start2":56433,"length1":282,"length2":8}]}]},{"timestamp":1727938149331,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ENG\n"],[-1,"    if (simulating) (\n        reading = \n    )\n\n\n"],[0,"    "]],"start1":31024,"start2":31024,"length1":57,"length2":8},{"diffs":[[0,"take"],[-1,"Read"],[1,"Bear"],[0,"ing(): "],[-1,"Reading"],[1,"number"],[0," {\n "]],"start1":31521,"start2":31521,"length1":26,"length2":25},{"diffs":[[0,"    "],[-1,"reading: Reading"],[1,"magnetXYZ = new Vector(0,0,0)\n    gravityXYZ = new Vector(0,0,0)"],[0,"\n   "]],"start1":31585,"start2":31585,"length1":24,"length2":72},{"diffs":[[0,"        "],[-1,"f"],[1,"magnetXYZ."],[0,"x += inp"]],"start1":31693,"start2":31693,"length1":17,"length2":26},{"diffs":[[0,"        "],[-1,"f"],[1,"magnetXYZ."],[0,"y += inp"]],"start1":31749,"start2":31749,"length1":17,"length2":26},{"diffs":[[0,"        "],[-1,"f"],[1,"magnetXYZ."],[0,"z += inp"]],"start1":31805,"start2":31805,"length1":17,"length2":26},{"diffs":[[0,"       g"],[1,"ravityXYZ."],[0,"x += inp"]],"start1":31862,"start2":31862,"length1":16,"length2":26},{"diffs":[[0,"       g"],[1,"ravityXYZ."],[0,"y += inp"]],"start1":31918,"start2":31918,"length1":16,"length2":26},{"diffs":[[0,"       g"],[1,"ravityXYZ."],[0,"z += inp"]],"start1":31974,"start2":31974,"length1":16,"length2":26},{"diffs":[[0,"  }\n    "],[-1,"f"],[1,"magnetXYZ."],[0,"x /= Win"]],"start1":32031,"start2":32031,"length1":17,"length2":26},{"diffs":[[0,"dow\n    "],[-1,"f"],[1,"magnetXYZ."],[0,"y /= Win"]],"start1":32057,"start2":32057,"length1":17,"length2":26},{"diffs":[[0,"dow\n    "],[-1,"f"],[1,"magnetXYZ."],[0,"z /= Win"]],"start1":32083,"start2":32083,"length1":17,"length2":26},{"diffs":[[0,"ow\n    g"],[1,"ravityXYZ."],[0,"x /= Win"]],"start1":32110,"start2":32110,"length1":16,"length2":26},{"diffs":[[0,"ow\n    g"],[1,"ravityXYZ."],[0,"y /= Win"]],"start1":32137,"start2":32137,"length1":16,"length2":26},{"diffs":[[0,"ow\n    g"],[1,"ravityXYZ."],[0,"z /= Win"]],"start1":32164,"start2":32164,"length1":16,"length2":26},{"diffs":[[0,"ow\n\n"],[-1,"    reading = new Reading\n\n"],[0,"    "]],"start1":32191,"start2":32191,"length1":35,"length2":8},{"diffs":[[0,"V(\"fx\", "],[-1,"f"],[1,"northXYZ."],[0,"x),\n    "]],"start1":32290,"start2":32290,"length1":17,"length2":25},{"diffs":[[0,"V(\"fy\", "],[-1,"f"],[1,"northXYZ."],[0,"y),\n    "]],"start1":32337,"start2":32337,"length1":17,"length2":25},{"diffs":[[0,"V(\"fz\", "],[-1,"f"],[1,"northXYZ."],[0,"z),\n    "]],"start1":32384,"start2":32384,"length1":17,"length2":25},{"diffs":[[0,"urn "],[-1,"new Reading(magnetXYZ.x, magnetXYZ.y,magnetXYZ.z,gravityXYZ.x, \n    )"],[1,"333"],[0,"\n}\n\n"]],"start1":32556,"start2":32556,"length1":77,"length2":11},{"diffs":[[0," []\n"],[-1,"    let testReading: Reading\n"],[0,"    "]],"start1":33450,"start2":33450,"length1":37,"length2":8},{"diffs":[[0,"  break\n"],[-1,"    "],[0,"}\n    "],[1,"let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n"],[0,"\n    // "]],"start1":56234,"start2":56234,"length1":26,"length2":354},{"diffs":[[0,") {\n"],[-1,"            if (testPoseX.length > 0 ) {\n    "],[0,"    "]],"start1":56928,"start2":56928,"length1":53,"length2":8},{"diffs":[[0,"n])\n        "],[-1,"    "],[0,"tests.push(r"]],"start1":57025,"start2":57025,"length1":28,"length2":24},{"diffs":[[0,"eading)\n    "],[1,"}\n"],[0,"    "],[1,"if (testPoseX.length > 0 ) {\n"],[0,"    } else {"]],"start1":57049,"start2":57049,"length1":28,"length2":59},{"diffs":[[0," {\n\n    "],[-1,"    }\n\n"],[1,"}"],[0,"\n    */\n"]],"start1":57106,"start2":57106,"length1":23,"length2":17}]}]},{"timestamp":1727938743030,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"let "],[-1,"scan: Scan  // array of scanned \nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number\n\nlet nextTask: Tasks = Tasks.PerformScan"],[1,"nextTask: Tasks = Tasks.PerformScan\n\n// let scan: Scan = new Scan()\nlet simulating = isSimulating() // for debugging\nlet scan: Scan\nlet test: Reading[] = [] // array of test readings"],[0,"\n\n//"]],"start1":498,"start2":498,"length1":162,"length2":190},{"diffs":[[0,"er\n\n"],[-1,"let simulating = isSimulating() // for debugging\n"],[0,"\n// "]],"start1":1470,"start2":1470,"length1":57,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"// take a single test reading\n"],[0,"func"]],"start1":31557,"start2":31557,"length1":38,"length2":8},{"diffs":[[0,"    "],[-1,"reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n    "],[1,"// take single reading as magnetXYZ\n    reading: Reading\n"],[0,"    "]],"start1":31595,"start2":31595,"length1":126,"length2":65},{"diffs":[[0," Window; i++) {\n"],[-1,"    "],[0,"        fx += in"]],"start1":31679,"start2":31679,"length1":36,"length2":32},{"diffs":[[0,"        "],[-1,"   "],[-1," "],[0,"fy += in"]],"start1":31742,"start2":31742,"length1":20,"length2":16},{"diffs":[[0,"ce(Dimension.Y)\n"],[-1,"    "],[0,"        fz += in"]],"start1":31773,"start2":31773,"length1":36,"length2":32},{"diffs":[[0,"imension.Z)\n"],[-1,"    "],[0,"        gx +"]],"start1":31824,"start2":31824,"length1":28,"length2":24},{"diffs":[[0,"        "],[-1,"    "],[0,"gy += in"]],"start1":31882,"start2":31882,"length1":20,"length2":16},{"diffs":[[0,"        "],[-1," "],[-1,"   "],[0,"gz += in"]],"start1":31928,"start2":31928,"length1":20,"length2":16},{"diffs":[[0,"sion.Z)\n    "],[-1,"  "],[-1,"  }\n    "],[1,"}\n"],[0,"    fx /= Wi"]],"start1":31966,"start2":31966,"length1":34,"length2":26},{"diffs":[[0,"dow\n    "],[-1,"   "],[-1," "],[0,"fy /= Wi"]],"start1":31993,"start2":31993,"length1":20,"length2":16},{"diffs":[[0,"y /= Window\n"],[-1,"    "],[0,"    fz /= Wi"]],"start1":32002,"start2":32002,"length1":28,"length2":24},{"diffs":[[0,"z /= Window\n"],[-1,"    "],[0,"    gx /= Wi"]],"start1":32019,"start2":32019,"length1":28,"length2":24},{"diffs":[[0,"dow\n    "],[-1," "],[-1,"   "],[0,"gy /= Wi"]],"start1":32044,"start2":32044,"length1":20,"length2":16},{"diffs":[[0,"y /= Window\n"],[-1,"    "],[0,"    gz /= Wi"]],"start1":32053,"start2":32053,"length1":28,"length2":24},{"diffs":[[0,"Window\n\n    "],[-1," "],[1,"reading = new Reading\n\n"],[0,"   "],[1," "],[0,"datalogger.l"]],"start1":32075,"start2":32075,"length1":28,"length2":51},{"diffs":[[0,"datalogger.log(\n"],[-1,"    "],[0,"        datalogg"]],"start1":32114,"start2":32114,"length1":36,"length2":32},{"diffs":[[0,"raw "],[-1,"reading\"),\n    "],[1,"test\"),\n"],[0,"    "]],"start1":32167,"start2":32167,"length1":23,"length2":16},{"diffs":[[0,"\", fx),\n        "],[-1," "],[-1,"   "],[0,"datalogger.creat"]],"start1":32210,"start2":32210,"length1":36,"length2":32},{"diffs":[[0,"\", fy),\n        "],[-1,"  "],[-1,"  "],[0,"datalogger.creat"]],"start1":32249,"start2":32249,"length1":36,"length2":32},{"diffs":[[0,"\", fz),\n        "],[-1,"   "],[-1," "],[0,"datalogger.creat"]],"start1":32288,"start2":32288,"length1":36,"length2":32},{"diffs":[[0,"x\", "],[-1,"gx),\n    "],[1,"downXYZ.x),\n"],[0,"    "]],"start1":32326,"start2":32326,"length1":17,"length2":20},{"diffs":[[0,"y\", "],[-1,"gy),\n    "],[1,"downXYZ.y),\n"],[0,"    "]],"start1":32372,"start2":32372,"length1":17,"length2":20},{"diffs":[[0,"V(\"gz\", "],[-1,"g"],[1,"downXYZ."],[0,"z))\n    "]],"start1":32414,"start2":32414,"length1":17,"length2":24},{"diffs":[[0,"))\n    \n"],[-1,"    "],[1,"\n"],[0,"    re"],[-1,"ading = "],[1,"turn"],[0," new Rea"]],"start1":32431,"start2":32431,"length1":34,"length2":27},{"diffs":[[0,"ing("],[-1,"fx, fy, fz, gx, gy, gz)"],[1,"magnetXYZ.x, magnetXYZ.y,magnetXYZ.z,gravityXYZ.x, "],[0,"\n    "],[-1,"}"],[1,")"],[0,"\n}\n\n"]],"start1":32459,"start2":32459,"length1":37,"length2":65}]}]},{"timestamp":1727939337130,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"let simulating = isSimulating() // true when debugging\n\n"],[0,"let "]],"start1":494,"start2":494,"length1":64,"length2":8},{"diffs":[[0,"ned "],[-1,"magnetometer samples"],[0,"\nlet"]],"start1":530,"start2":530,"length1":28,"length2":8},{"diffs":[[0,"mber"],[-1," // next testReading to use when simulating"],[0,"\n\nle"]],"start1":611,"start2":611,"length1":51,"length2":8},{"diffs":[[0,"number\n\n"],[1,"let simulating = isSimulating() // for debugging\n"],[0,"\n// fiel"]],"start1":1438,"start2":1438,"length1":16,"length2":65},{"diffs":[[0,"dow\n"],[-1,"        reading =  new Reading(fx, fy, fz, gx, gy, gz)\n    }\n    return reading\n}\n\nfunction dumpTestData {\n    for (let i = 0; i < testReadings.length; i++) {"],[0,"\n   "]],"start1":32242,"start2":32242,"length1":166,"length2":8},{"diffs":[[0,"CV(\""],[-1,"testReadings\", \"raw"],[1,"data\", \"raw readin"],[0,"g\"),"]],"start1":32300,"start2":32300,"length1":27,"length2":26},{"diffs":[[0,"x\", "],[-1,"testReadings."],[0,"f"],[1,"x"],[0,"),\n "]],"start1":32361,"start2":32361,"length1":22,"length2":10},{"diffs":[[0,"(\"gz\", gz))\n"],[1,"    \n        reading =  new Reading(fx, fy, fz, gx, gy, gz)\n"],[0,"    }\n}\n\nfun"]],"start1":32573,"start2":32573,"length1":24,"length2":84},{"diffs":[[0," triples"],[-1,"..."],[0,"\n    for"]],"start1":56416,"start2":56416,"length1":19,"length2":16},{"diffs":[[0," // "],[-1,"assemble the"],[1,"do the same for"],[0," the"]],"start1":56640,"start2":56640,"length1":20,"length2":23},{"diffs":[[0,"st cases"],[-1,"..."],[0,"\n    for"]],"start1":56666,"start2":56666,"length1":19,"length2":16},{"diffs":[[0,") {\n        "],[1,"    "],[0,"if (testPose"]],"start1":56716,"start2":56716,"length1":24,"length2":28},{"diffs":[[0,") {\n            "],[1,"let "],[0,"reading = new Re"]],"start1":56757,"start2":56757,"length1":32,"length2":36},{"diffs":[[0,"ing("],[-1,"t"],[1,"xT"],[0,"est"],[-1,"FieldX"],[0,"[n], "],[-1,"t"],[1,"yT"],[0,"est"],[-1,"FieldY"],[0,"[n], "],[-1,"testFieldZ[n], testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else {\n\n        }\n"],[1,"zTest[n], gxTest[n], gyTest[n], gzTest[n])\n    "],[0,"    "]],"start1":56795,"start2":56795,"length1":123,"length2":75},{"diffs":[[0,"    test"],[-1,"Reading"],[0,"s.push(r"]],"start1":56870,"start2":56870,"length1":23,"length2":16},{"diffs":[[0,"eading)\n    "],[-1,"}"],[1,"        } else {\n\n        }\n\n\n    */"],[0,"\n    return "]],"start1":56886,"start2":56886,"length1":25,"length2":60}]}]},{"timestamp":1727939936733,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n\n/*"],[-1,"**\n * "],[1," sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n*/\n\n\n"],[0,"func"]],"start1":23903,"start2":23903,"length1":14,"length2":3026},{"diffs":[[0,"ng\n}"],[-1,"\n***/"],[0,"\n\n//"]],"start1":27707,"start2":27707,"length1":13,"length2":8},{"diffs":[[0,"}\n\n/"],[-1,"/ eventual user interfaces"],[1,"* function show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} */\n"],[0,"\n\nfu"]],"start1":27970,"start2":27970,"length1":34,"length2":209},{"diffs":[[0,"gth = sc"],[-1,"an.scope"],[1,"opeScan"],[0,"()\n\n    "]],"start1":28783,"start2":28783,"length1":24,"length2":23},{"diffs":[[0," WEAK\"\n    }"],[1,"\n\n   "],[0,"\n}\n\n\n    // "]],"start1":29001,"start2":29001,"length1":24,"length2":29},{"diffs":[[0,"YZtoENG\n"],[-1,"    reading: Reading\n"],[0,"    if ("]],"start1":31111,"start2":31111,"length1":37,"length2":16},{"diffs":[[0,"if (simulating) "],[-1,"{"],[1,"("],[0,"\n        reading"]],"start1":31123,"start2":31123,"length1":33,"length2":33},{"diffs":[[0,"g = "],[-1,"testReadings[testIndex]\n        testIndex++\n    }"],[1,"\n    )\n\n"],[0,"\n   "]],"start1":31155,"start2":31155,"length1":57,"length2":16},{"diffs":[[0,"Z = "],[-1,"reading.f"],[1,"correctedF"],[0,"ield"],[1,"()"],[0,"\n   "]],"start1":31179,"start2":31179,"length1":21,"length2":24},{"diffs":[[0,"Z = "],[-1,"reading.pose\n"],[1,"correctedGravity()"],[0,"\n   "]],"start1":31210,"start2":31210,"length1":21,"length2":26},{"diffs":[[0,"...\n"],[-1,"    samples = []\n"],[0,"    "]],"start1":56605,"start2":56605,"length1":25,"length2":8},{"diffs":[[0,".length; i++) {\n"],[1,""],[0,"        samples."]],"start1":56638,"start2":56638,"length1":32,"length2":32},{"diffs":[[0,"the "],[-1,"array of test readings...\n    testReadings = []"],[1,"the test cases..."],[0,"\n   "]],"start1":56837,"start2":56837,"length1":55,"length2":25},{"diffs":[[0,"se {"],[-1," // old test dataset for which pose data was never captured\n            reading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, pretend it was face-up!"],[1,"\n"],[0,"\n   "]],"start1":57074,"start2":57074,"length1":195,"length2":9},{"diffs":[[0,"ding)\n    }\n"],[-1,"\n"],[0,"    return 0"]],"start1":57119,"start2":57119,"length1":25,"length2":24},{"diffs":[[0,"rn 0"],[-1," // never fails!"],[0,"\n}\n\n"]],"start1":57139,"start2":57139,"length1":24,"length2":8}]}]},{"timestamp":1727940525052,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    let heading: Reading\n"],[0,"    "]],"start1":22502,"start2":22502,"length1":33,"length2":8},{"diffs":[[0,"ading = take"],[-1,"Read"],[1,"Bear"],[0,"ing()\n      "]],"start1":23817,"start2":23817,"length1":28,"length2":28},{"diffs":[[0,"ion dumpTestData"],[-1,"()"],[0," {\n    for (let "]],"start1":29272,"start2":29272,"length1":34,"length2":32}]}]},{"timestamp":1727940603131,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g()\n"],[-1,"            \n"],[0,"    "]],"start1":23860,"start2":23860,"length1":21,"length2":8}]}]},{"timestamp":1727946507152,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tNorth:\n"],[-1,"        \n"],[0,"        "]],"start1":23631,"start2":23631,"length1":25,"length2":16},{"diffs":[[0,"ading()\n"],[1,"            "],[0,"\n       "]],"start1":23856,"start2":23856,"length1":16,"length2":28}]}]},{"timestamp":1727946528528,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    let "],[-1,"newR"],[1,"h"],[0,"eading: "]],"start1":22506,"start2":22506,"length1":20,"length2":17},{"diffs":[[0,"    "],[-1,"    newReading = takeReading()\n"],[0,"\n   "]],"start1":23643,"start2":23643,"length1":39,"length2":8},{"diffs":[[0,"    "],[-1,"newR"],[1,"h"],[0,"eadi"]],"start1":23845,"start2":23845,"length1":12,"length2":9},{"diffs":[[0,"ading {\n    "],[-1,"let "],[0,"reading: Rea"]],"start1":28611,"start2":28611,"length1":28,"length2":24},{"diffs":[[0,"ing\n"],[-1,"    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n"],[0,"    "]],"start1":28636,"start2":28636,"length1":192,"length2":8},{"diffs":[[0,"       f"],[-1,"ieldX"],[1,"x"],[0," += inpu"]],"start1":28785,"start2":28785,"length1":21,"length2":17},{"diffs":[[0,"       f"],[-1,"ieldY"],[1,"y"],[0," += inpu"]],"start1":28836,"start2":28836,"length1":21,"length2":17},{"diffs":[[0,"       f"],[-1,"ieldZ"],[1,"z"],[0," += inpu"]],"start1":28887,"start2":28887,"length1":21,"length2":17},{"diffs":[[0,"        "],[-1,"poseX"],[1,"gx"],[0," += inpu"]],"start1":28937,"start2":28937,"length1":21,"length2":18},{"diffs":[[0,"        "],[-1,"poseY"],[1,"gy"],[0," += inpu"]],"start1":28987,"start2":28987,"length1":21,"length2":18},{"diffs":[[0,"        "],[-1,"poseZ"],[1,"gz"],[0," += inpu"]],"start1":29037,"start2":29037,"length1":21,"length2":18},{"diffs":[[0,"       f"],[-1,"ieldX"],[1,"x"],[0," /= Wind"]],"start1":29094,"start2":29094,"length1":21,"length2":17},{"diffs":[[0,"       f"],[-1,"ieldY"],[1,"y"],[0," /= Wind"]],"start1":29115,"start2":29115,"length1":21,"length2":17},{"diffs":[[0,"       f"],[-1,"ieldZ"],[1,"z"],[0," /= Wind"]],"start1":29136,"start2":29136,"length1":21,"length2":17},{"diffs":[[0,"        "],[-1,"poseX"],[1,"gx"],[0," /= Wind"]],"start1":29156,"start2":29156,"length1":21,"length2":18},{"diffs":[[0,"        "],[-1,"poseY"],[1,"gy"],[0," /= Wind"]],"start1":29177,"start2":29177,"length1":21,"length2":18},{"diffs":[[0,"        "],[-1,"poseZ"],[1,"gz"],[0," /= Wind"]],"start1":29198,"start2":29198,"length1":21,"length2":18},{"diffs":[[0,"ng(f"],[-1,"ieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n    }\n    // apply corrections\n    \n"],[1,"x, fy, fz, gx, gy, gz)\n    }"],[0,"\n   "]],"start1":29247,"start2":29247,"length1":88,"length2":36},{"diffs":[[0," reading\n}\n\n"],[-1,"\n\n"],[0,"function dum"]],"start1":29290,"start2":29290,"length1":26,"length2":24}]}]},{"timestamp":1727947200016,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"h dimension\n"],[1,"    offset: Vector  // central offsets from origin in each dimension\n    yScale: number // multiplier to match Y readings with X\n    zScale: number // multiplier to match Z readings with X\n"],[0,"    strength"]],"start1":10438,"start2":10438,"length1":24,"length2":213}]}]},{"timestamp":1727947201703,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/*\nClass definitions and user-interfaces \n\n*/"],[0,"\n// "]],"start1":0,"start2":0,"length1":49,"length2":4},{"diffs":[[0,"g,\n}"],[-1,"\nlet nextTask: Tasks = Tasks.PerformScan"],[0,"\n\nle"]],"start1":492,"start2":492,"length1":48,"length2":8},{"diffs":[[0,"lating\n\n"],[1,"let nextTask: Tasks = Tasks.PerformScan\n\n"],[0,"// Senso"]],"start1":728,"start2":728,"length1":16,"length2":57},{"diffs":[[0,"me\n\n"],[-1,"// calibrated correction adjustments for magnetometer readings\nlet"],[1,"let magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n\n//"],[0," field"],[-1,"O"],[1," o"],[0,"ffset"],[-1,": Vector  // central offs"],[1,"s\nlet fxOff: number\nlet fyOff: number\nl"],[0,"et"],[-1,"s"],[0," f"],[-1,"rom origin in each dimension\nlet fieldScaleY: number // multiplier to match Y readings with X"],[1,"zOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field re-scaling factors"],[0,"\nlet f"],[-1,"ield"],[1,"y"],[0,"Scale"],[-1,"Z"],[0,": nu"]],"start1":1495,"start2":1495,"length1":225,"length2":259},{"diffs":[[0," // "],[-1,"multiplier to match Z readings with X\n\n// calibrated correction adjustments for accelerometer readings\nlet poseOffset: Vector  // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X"],[1,"= fyMag / fxMag\nlet fzScale: number // = fzMag / fxMag\n\n// gravity (or pose) sensor offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity re-scaling factors"],[0,"\nlet "],[-1,"pose"],[1,"gy"],[0,"Scale"],[-1,"Z"],[0,": nu"]],"start1":1758,"start2":1758,"length1":262,"length2":271},{"diffs":[[0," // "],[-1,"multiplier to match Z readings with X\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number"],[1,"= gyMag / gxMag\nlet gzScale: number // = gzMag / gxMag\n\n// calibration map\nlet lit: number[][]\n\nlet ready = false // ready for action!"],[0,"\n\n//"]],"start1":2033,"start2":2033,"length1":111,"length2":142}]}]},{"timestamp":1727947793924,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"/*\n"],[-1,"This code will form the b"],[1,"Cl"],[0,"as"],[-1,"i"],[0,"s "],[-1,"for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module."],[1,"definitions and user-interfaces "],[0,"\n\n*/"]],"start1":0,"start2":0,"length1":150,"length2":45},{"diffs":[[0,"number\n\n"],[-1,""],[0,"// ====="]],"start1":2135,"start2":2135,"length1":16,"length2":16},{"diffs":[[0,"======\n\n"],[1,"/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n"],[0,"/* 3-D v"]],"start1":2181,"start2":2181,"length1":16,"length2":2702},{"diffs":[[0,"*/\n\n"],[-1,"\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Mwthods are provided to acquire, scope and analyse this sequence to give the correction parameters\n \n*/\n\n\n\n\n"],[0,"clas"]],"start1":10129,"start2":10129,"length1":2915,"length2":8}]}]},{"timestamp":1727948385598,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ot.\n * M"],[-1,"e"],[1,"w"],[0,"thods ar"]],"start1":10344,"start2":10344,"length1":17,"length2":17},{"diffs":[[0," to "],[-1,"der"],[1,"g"],[0,"ive the "],[-1,"global "],[0,"corr"]],"start1":10415,"start2":10415,"length1":26,"length2":17},{"diffs":[[0,"ers\n"],[-1," * for the magnetometer. Analysis of a dataset also reveals how long each rotation took, and the spin-axis \n * (in the sensor's XYZ frame).\n *"],[0," \n*/"]],"start1":10446,"start2":10446,"length1":150,"length2":8},{"diffs":[[0,"mber"],[-1,", dumpIt: boolean"],[0,") {\n"]],"start1":11130,"start2":11130,"length1":25,"length2":8},{"diffs":[[0,"ets the "],[-1,"global "],[0,"offsets "]],"start1":13409,"start2":13409,"length1":23,"length2":16},{"diffs":[[0,"his scan"],[1," (and its analysis)"],[0," to the "]],"start1":20656,"start2":20656,"length1":16,"length2":35},{"diffs":[[0,"dump"],[-1,"Raw"],[0,"() {"]],"start1":20706,"start2":20706,"length1":11,"length2":8},{"diffs":[[0,"  }\n"],[-1,"    }\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {"],[0,"\n"],[1,""],[0,"    "]],"start1":21048,"start2":21048,"length1":87,"length2":9},{"diffs":[[0,"XYZ.z))\n"],[-1,"    }"],[0,"\n    "],[1,"}"],[0,"\n}\n\n\n// "]],"start1":21355,"start2":21355,"length1":26,"length2":22}]}]},{"timestamp":1727948983417,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g)\n\n"],[-1,"// calibrated correction adjustments for accelerometer readings\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n"],[0,"// r"]],"start1":1343,"start2":1343,"length1":275,"length2":8},{"diffs":[[0," frame\n\n"],[1,"// calibrated correction adjustments for magnetometer readings\nlet fieldOffset: Vector  // central offsets from origin in each dimension\nlet fieldScaleY: number // multiplier to match Y readings with X\nlet fieldScaleZ: number // multiplier to match Z readings with X\n\n// calibrated correction adjustments for accelerometer readings\nlet poseOffset: Vector  // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n"],[0,"let magn"]],"start1":1640,"start2":1640,"length1":16,"length2":550},{"diffs":[[0,"is \n * ("],[-1,"measured "],[0,"in the s"]],"start1":10563,"start2":10563,"length1":25,"length2":16},{"diffs":[[0,"    "],[-1,"period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    swing: Vector   // amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average"],[1,"fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n\n    swing: Vector   // amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n"],[0,"\n   "]],"start1":10767,"start2":10767,"length1":630,"length2":359},{"diffs":[[0,"on(0) - "],[-1,"poseOffset.x"],[1,"gxOff"],[0,")\n      "]],"start1":24954,"start2":24954,"length1":28,"length2":21},{"diffs":[[0,"on(1) - "],[-1,"poseOffset.y"],[1,"gyOff"],[0,") * gySc"]],"start1":25006,"start2":25006,"length1":28,"length2":21},{"diffs":[[0,"on(2) - "],[-1,"poseOffset."],[1,"gzOff"],[0,") * gzSc"]],"start1":25068,"start2":25068,"length1":27,"length2":21},{"diffs":[[0,"\"){\n        "],[-1,"poseOffset.x"],[1,"gxMag"],[0," = 1042.89\n "]],"start1":30510,"start2":30510,"length1":36,"length2":29},{"diffs":[[0,".73\n        "],[-1,"poseOffset.x"],[1,"gxOff"],[0," = -70.92\n  "]],"start1":30582,"start2":30582,"length1":36,"length2":29},{"diffs":[[0,"        "],[-1,"poseOffset.y"],[1,"gyOff"],[0," = 44.59"]],"start1":30609,"start2":30609,"length1":28,"length2":21},{"diffs":[[0,"        "],[-1,"poseOffset."],[1,"gzOff"],[0," = 6.804"]],"start1":30632,"start2":30632,"length1":27,"length2":21},{"diffs":[[0,") {\n        "],[-1,"poseOffset.x"],[1,"gxMag"],[0," = 1017.578\n"]],"start1":30691,"start2":30691,"length1":36,"length2":29},{"diffs":[[0,"315\n        "],[-1,"poseOffset.x"],[1,"gxOff"],[0," = -25.411\n "]],"start1":30765,"start2":30765,"length1":36,"length2":29},{"diffs":[[0,"        "],[-1,"poseOffset.y"],[1,"gyOff"],[0," = -3.25"]],"start1":30793,"start2":30793,"length1":28,"length2":21},{"diffs":[[0,"251\n        "],[-1,"poseOffset."],[1,"gzOff"],[0," = -1.300\n  "]],"start1":30812,"start2":30812,"length1":35,"length2":29},{"diffs":[[0,") {\n        "],[-1,"poseOffset.x"],[1,"gxMag"],[0," = 1057.89\n "]],"start1":30870,"start2":30870,"length1":36,"length2":29},{"diffs":[[0,".06\n        "],[-1,"poseOffset.x"],[1,"gxOff"],[0," = -85.33\n  "]],"start1":30942,"start2":30942,"length1":36,"length2":29},{"diffs":[[0,"        "],[-1,"poseOffset.y"],[1,"gyOff"],[0," = 7.22\n"]],"start1":30969,"start2":30969,"length1":28,"length2":21},{"diffs":[[0,".22\n        "],[-1,"poseOffset."],[1,"gzOff"],[0," = -18.94\n  "]],"start1":30986,"start2":30986,"length1":35,"length2":29},{"diffs":[[0,"        "],[-1,"poseOffset.x"],[1,"gxMag"],[0," = 1049."]],"start1":31048,"start2":31048,"length1":28,"length2":21},{"diffs":[[0,"        "],[-1,"poseOffset.x"],[1,"gxOff"],[0," = -74.0"]],"start1":31122,"start2":31122,"length1":28,"length2":21},{"diffs":[[0,"        "],[-1,"poseOffset.y"],[1,"gyOff"],[0," = 8.455"]],"start1":31146,"start2":31146,"length1":28,"length2":21},{"diffs":[[0,"455\n        "],[-1,"poseOffset."],[1,"gzOff"],[0," = -7.617\n  "]],"start1":31164,"start2":31164,"length1":35,"length2":29},{"diffs":[[0,"    "],[-1,"poseOffset.x = 4.00\n    poseOffset.y"],[1,"gxOff = 4.00\n    gyOff"],[0," = 1"]],"start1":55168,"start2":55168,"length1":44,"length2":30},{"diffs":[[0,".00\n    "],[-1,"poseOffset."],[1,"gzOff"],[0," = -142."]],"start1":55199,"start2":55199,"length1":27,"length2":21},{"diffs":[[0,"x\", "],[-1,"poseOffset.x"],[1,"gxOff"],[0,"),\n "]],"start1":55589,"start2":55589,"length1":20,"length2":13},{"diffs":[[0,"y\", "],[-1,"poseOffset.y"],[1,"gyOff"],[0,"),\n "]],"start1":55627,"start2":55627,"length1":20,"length2":13},{"diffs":[[0,"z\", "],[-1,"poseOffset."],[1,"gzOff"],[0,"))\n\n"]],"start1":55665,"start2":55665,"length1":19,"length2":13}]}]},{"timestamp":1727949582697,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ings"],[-1," (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector  = new Vector([0, 0, 0]"],[1,"\nlet poseOffset: Vector"],[0," // "]],"start1":1406,"start2":1406,"length1":183,"length2":31},{"diffs":[[0,"eScaleY: number "],[-1," = 1 "],[0,"// multiplier to"]],"start1":1490,"start2":1490,"length1":37,"length2":32},{"diffs":[[0,"ber "],[-1," = 1 "],[0,"// m"]],"start1":1566,"start2":1566,"length1":13,"length2":8},{"diffs":[[0,"ing\n"],[-1,"    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n"],[0,"})\n\n"]],"start1":21987,"start2":21987,"length1":100,"length2":8},{"diffs":[[0,"eOffset."],[-1,"z"],[0,") * gzSc"]],"start1":25106,"start2":25106,"length1":17,"length2":16},{"diffs":[[0,"        pose"],[-1,"ScaleY"],[1,"Offset.x"],[0," = 1042.89 /"]],"start1":30547,"start2":30547,"length1":30,"length2":32},{"diffs":[[0," 1042.89"],[-1," /"],[1,"\n        gyMag ="],[0," 1007.23"]],"start1":30569,"start2":30569,"length1":18,"length2":32},{"diffs":[[0,"    "],[-1,"poseScaleZ = 1042.89 /"],[1,"gzMag = "],[0," 992"]],"start1":30606,"start2":30606,"length1":30,"length2":16},{"diffs":[[0,"eOffset."],[-1,"z"],[0," = 6.804"]],"start1":30697,"start2":30697,"length1":17,"length2":16},{"diffs":[[0,"        pose"],[-1,"ScaleY"],[1,"Offset.x"],[0," = 1017.578 "]],"start1":30755,"start2":30755,"length1":30,"length2":32},{"diffs":[[0,"1017.578"],[-1," /"],[1,"\n        gyMag ="],[0," 996.736"]],"start1":30778,"start2":30778,"length1":18,"length2":32},{"diffs":[[0,"    "],[-1,"poseScaleZ = 1017.578 /"],[1,"gzMag ="],[0," 102"]],"start1":30815,"start2":30815,"length1":31,"length2":15},{"diffs":[[0," poseOffset."],[-1,"z"],[0," = -1.300\n  "]],"start1":30904,"start2":30904,"length1":25,"length2":24},{"diffs":[[0,"        pose"],[-1,"ScaleY"],[1,"Offset.x"],[0," = 1057.89 /"]],"start1":30961,"start2":30961,"length1":30,"length2":32},{"diffs":[[0," 1057.89"],[-1," /"],[1,"\n        gyMag ="],[0," 1023.98"]],"start1":30983,"start2":30983,"length1":18,"length2":32},{"diffs":[[0,"    "],[-1,"poseScaleZ = 1057.89 /"],[1,"gzMag ="],[0," 107"]],"start1":31020,"start2":31020,"length1":30,"length2":15},{"diffs":[[0," poseOffset."],[-1,"z"],[0," = -18.94\n  "]],"start1":31105,"start2":31105,"length1":25,"length2":24},{"diffs":[[0,"    pose"],[-1,"ScaleY"],[1,"Offset.x"],[0," = 1049."]],"start1":31166,"start2":31166,"length1":22,"length2":24},{"diffs":[[0,"1049.285"],[-1," /"],[1,"\n        gyMag ="],[0," 1059.74"]],"start1":31185,"start2":31185,"length1":18,"length2":32},{"diffs":[[0,"    "],[-1,"poseScaleZ = 1049.285 /"],[1,"gzMag ="],[0," 986"]],"start1":31223,"start2":31223,"length1":31,"length2":15},{"diffs":[[0," poseOffset."],[-1,"z"],[0," = -7.617\n  "]],"start1":31310,"start2":31310,"length1":25,"length2":24},{"diffs":[[0,"eOffset."],[-1,"z"],[0," = -142."]],"start1":55365,"start2":55365,"length1":17,"length2":16},{"diffs":[[0,"eOffset."],[-1,"z"],[0,"))\n\n\ndat"]],"start1":55847,"start2":55847,"length1":17,"length2":16}]}]},{"timestamp":1727950181936,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"fset: Vector"],[1,"  = new Vector([0, 0, 0]"],[0," // central "]],"start1":1549,"start2":1549,"length1":24,"length2":48},{"diffs":[[0,"eScaleY: number "],[1," = 1 "],[0,"// multiplier to"]],"start1":1642,"start2":1642,"length1":32,"length2":37},{"diffs":[[0,"eScaleZ: number "],[1," = 1 "],[0,"// multiplier to"]],"start1":1711,"start2":1711,"length1":32,"length2":37},{"diffs":[[0,"i < test"],[-1,"Readings"],[0,".length;"]],"start1":28178,"start2":28178,"length1":24,"length2":16},{"diffs":[[0,"V(\"fx\", test"],[-1,"Readings"],[0,"[i].field.x)"]],"start1":28256,"start2":28256,"length1":32,"length2":24},{"diffs":[[0,"V(\"fy\", test"],[-1,"Readings"],[0,"[i].field.y)"]],"start1":28312,"start2":28312,"length1":32,"length2":24},{"diffs":[[0,"V(\"fz\", test"],[-1,"Readings"],[0,"[i].field.z)"]],"start1":28368,"start2":28368,"length1":32,"length2":24},{"diffs":[[0,"V(\"gx\", test"],[-1,"Readings"],[0,"[i].pose.x),"]],"start1":28424,"start2":28424,"length1":32,"length2":24},{"diffs":[[0,"V(\"gy\", test"],[-1,"Readings"],[0,"[i].pose.y),"]],"start1":28479,"start2":28479,"length1":32,"length2":24},{"diffs":[[0,"z\", test"],[-1,"Readings"],[0,"[i].pose"]],"start1":28538,"start2":28538,"length1":24,"length2":16},{"diffs":[[0,"and "],[-1,"from it"],[1,"thence"],[0," com"]],"start1":28609,"start2":28609,"length1":15,"length2":14},{"diffs":[[0,"YZtoENG\n    "],[-1,"let "],[0,"reading: Rea"]],"start1":28633,"start2":28633,"length1":28,"length2":24},{"diffs":[[0,"x++\n"],[-1,"    } else {\n        reading = takeReading\n"],[0,"    "]],"start1":28742,"start2":28742,"length1":51,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"// adopt extrnally-measured calibration for some microbits I have known..."],[1,"\n\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"testReadings\", \"rawg\"),\n            datalogger.createCV(\"fx\", testReadings.f),\n            datalogger.createCV(\"fy\", fy),\n            datalogger.createCV(\"fz\", fz),\n            datalogger.createCV(\"gx\", gx),\n            datalogger.createCV(\"gy\", gy),\n            datalogger.createCV(\"gz\", gz))\n    }\n}\n"],[0,"\nfun"]],"start1":30253,"start2":30253,"length1":82,"length2":447},{"diffs":[[0,"    "],[-1,"switch"],[1,"if"],[0," (myName"],[-1,") {\n        case"],[1," =="],[0," \"zapop\""],[-1,":\n  "],[1,"){\n"],[0,"        "],[-1,"  "],[0,"pose"]],"start1":30774,"start2":30774,"length1":60,"length2":40},{"diffs":[[0,"1007.23\n        "],[-1,"    "],[0,"poseScaleZ = 104"]],"start1":30833,"start2":30833,"length1":36,"length2":32},{"diffs":[[0," 992.73\n        "],[-1," "],[-1,"   "],[0,"poseOffset.x = -"]],"start1":30871,"start2":30871,"length1":36,"length2":32},{"diffs":[[0," -70.92\n"],[-1,"    "],[0,"        "]],"start1":30901,"start2":30901,"length1":20,"length2":16},{"diffs":[[0," 44.597\n        "],[-1,"    "],[0,"poseOffset.z = 6"]],"start1":30931,"start2":30931,"length1":36,"length2":32},{"diffs":[[0,".804"],[-1,"\n"],[0,"      "],[1,"\n"],[0,"    "],[-1,"  break\n\n        case"],[1,"}\n    if (myName =="],[0," \"gateg\""],[-1,":\n    "],[1,") {\n"],[0,"    "]],"start1":30963,"start2":30963,"length1":54,"length2":50},{"diffs":[[0,"996.736\n        "],[-1,"   "],[-1," "],[0,"poseScaleZ = 101"]],"start1":31041,"start2":31041,"length1":36,"length2":32},{"diffs":[[0,"026.315\n        "],[-1,"    "],[0,"poseOffset.x = -"]],"start1":31082,"start2":31082,"length1":36,"length2":32},{"diffs":[[0,"-25.411\n        "],[-1,"  "],[-1,"  "],[0,"poseOffset.y = -"]],"start1":31113,"start2":31113,"length1":36,"length2":32},{"diffs":[[0," -3.251\n"],[-1,"    "],[0,"        "]],"start1":31143,"start2":31143,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1," "],[-1,"       break\n\n        case"],[1,"}\n    if (myName =="],[0," \"gigav\""],[-1,":\n    "],[1,") {\n"],[0,"    "]],"start1":31181,"start2":31181,"length1":49,"length2":39},{"diffs":[[0,"1023.98\n"],[-1,"    "],[0,"        "]],"start1":31247,"start2":31247,"length1":20,"length2":16},{"diffs":[[0,"1074.06\n        "],[-1,"    "],[0,"poseOffset.x = -"]],"start1":31286,"start2":31286,"length1":36,"length2":32},{"diffs":[[0," -85.33\n        "],[-1,"   "],[-1," "],[0,"poseOffset.y = 7"]],"start1":31316,"start2":31316,"length1":36,"length2":32},{"diffs":[[0," = 7.22\n"],[-1,"    "],[0,"        "]],"start1":31344,"start2":31344,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"        break\n\n        case"],[1,"}\n    if (myName =="],[0," \"zavov\""],[-1,":\n  "],[1,") {\n"],[0,"        "],[-1,"  "],[0,"pose"]],"start1":31382,"start2":31382,"length1":57,"length2":47},{"diffs":[[0,"059.746\n        "],[-1,"    "],[0,"poseScaleZ = 104"]],"start1":31450,"start2":31450,"length1":36,"length2":32},{"diffs":[[0,"986.272\n        "],[-1," "],[-1,"   "],[0,"poseOffset.x = -"]],"start1":31490,"start2":31490,"length1":36,"length2":32},{"diffs":[[0,"-74.082\n        "],[-1,"   "],[-1," "],[0,"poseOffset.y = 8"]],"start1":31521,"start2":31521,"length1":36,"length2":32},{"diffs":[[0,"= 8.455\n"],[-1,"    "],[0,"        "]],"start1":31550,"start2":31550,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"        break\n\n        default: // presume perfection until proved otherwise\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } "],[1,"}"],[0,"\n}\n\n"]],"start1":31588,"start2":31588,"length1":250,"length2":9}]}]},{"timestamp":1727950781450,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)"],[0,"\n"],[1,""],[0,"func"]],"start1":28587,"start2":28587,"length1":136,"length2":9},{"diffs":[[0,"eReading"],[-1,"()"],[0,"\n    }\n "]],"start1":28807,"start2":28807,"length1":18,"length2":16},{"diffs":[[0,"))\n\n"],[-1," // compute required conversion into world East-North-Gravity frame\n"],[0,"    "]],"start1":29224,"start2":29224,"length1":76,"length2":8},{"diffs":[[0," 1000))\n"],[1,""],[0,"}\n\n"],[-1,"\n\n"],[0,"// take "]],"start1":29287,"start2":29287,"length1":21,"length2":19},{"diffs":[[0,"ons\n"],[-1,"        reading.\n"],[0,"    "]],"start1":30295,"start2":30295,"length1":25,"length2":8}]}]},{"timestamp":1727951368963,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ding"],[-1," in the XYZ sensor-frame"],[0,"\nfun"]],"start1":29522,"start2":29522,"length1":32,"length2":8},{"diffs":[[0,"Y, poseZ)\n    }\n"],[-1,"\n"],[0,"    // apply cor"]],"start1":30457,"start2":30457,"length1":33,"length2":32},{"diffs":[[0,"    "],[-1,"reading.field.x -= scan.fieldOffset.x\n    reading.field.y = (reading.field.y - scan.fieldOffset.y) * scan.fieldScaleY\n    reading.field.z = (reading.field.z - scan.fieldOffset.x) * scan.fieldScaleZ\n    reading.pose.x -= poseOffset.x\n    reading.pose.y = (reading.pose.y - poseOffset.y) * poseScaleY\n    reading.pose.z = (reading.pose.z - poseOffset.z) * poseScaleY"],[1,"    reading.\n    \n"],[0,"\n   "]],"start1":30498,"start2":30498,"length1":372,"length2":26},{"diffs":[[0,"bration "],[-1,"("],[0,"for some"]],"start1":30575,"start2":30575,"length1":17,"length2":16},{"diffs":[[0,"known..."],[-1,")"],[0,"\nfunctio"]],"start1":30609,"start2":30609,"length1":17,"length2":16},{"diffs":[[0,"therwise"],[-1,"!"],[0,"\n       "]],"start1":31689,"start2":31689,"length1":17,"length2":16},{"diffs":[[0," 0; n < "],[-1,"t"],[1,"xT"],[0,"est"],[-1,"FieldX"],[0,".length;"]],"start1":55163,"start2":55163,"length1":26,"length2":21},{"diffs":[[0,") {\n            "],[-1,"testR"],[1,"r"],[0,"eading = new Rea"]],"start1":55225,"start2":55225,"length1":37,"length2":33},{"diffs":[[0,"Reading("],[-1,"\n                "],[0,"testFiel"]],"start1":55255,"start2":55255,"length1":33,"length2":16},{"diffs":[[0,"ldZ[n], "],[-1,"\n                "],[0,"testPose"]],"start1":55300,"start2":55300,"length1":33,"length2":16},{"diffs":[[0,"{ //"],[-1," this is an"],[0," old"]],"start1":55365,"start2":55365,"length1":19,"length2":8},{"diffs":[[0," dataset"],[-1,","],[0," for whi"]],"start1":55378,"start2":55378,"length1":17,"length2":16},{"diffs":[[0,"            "],[-1,"testR"],[1,"r"],[0,"eading = new"]],"start1":55426,"start2":55426,"length1":29,"length2":25},{"diffs":[[0,"for now,"],[-1," always"],[0," pretend"]],"start1":55521,"start2":55521,"length1":23,"length2":16},{"diffs":[[0,"gs.push("],[-1,"testR"],[1,"r"],[0,"eading)\n"]],"start1":55582,"start2":55582,"length1":21,"length2":17},{"diffs":[[0,"ding)\n    }\n"],[1,"\n"],[0,"    return 0"]],"start1":55593,"start2":55593,"length1":24,"length2":25},{"diffs":[[0,"unt = 0\n"],[-1,"basic.clearScreen()"],[1,"/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    poseOffset.x = 4.00\n    poseOffset.y = 14.00\n    poseOffset.z = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", poseOffset.x),\n    datalogger.createCV(\"gy\", poseOffset.y),\n    datalogger.createCV(\"gz\", poseOffset.z))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n"],[0,"\n\n/*\n* W"]],"start1":55699,"start2":55699,"length1":35,"length2":995}]}]},{"timestamp":1727951911404,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," X\n\n    "],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,": Vector"]],"start1":11051,"start2":11051,"length1":21,"length2":21},{"diffs":[[0,"   this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".x = (xh"]],"start1":14420,"start2":14420,"length1":21,"length2":21},{"diffs":[[0,"   this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".y = (yh"]],"start1":14459,"start2":14459,"length1":21,"length2":21},{"diffs":[[0,"   this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".z = (zh"]],"start1":14498,"start2":14498,"length1":21,"length2":21},{"diffs":[[0,"t((this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".x * thi"]],"start1":14564,"start2":14564,"length1":21,"length2":21},{"diffs":[[0," * this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".x) \n   "]],"start1":14579,"start2":14579,"length1":21,"length2":21},{"diffs":[[0,"+ (this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".y * thi"]],"start1":14629,"start2":14629,"length1":21,"length2":21},{"diffs":[[0," * this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".y) \n   "]],"start1":14644,"start2":14644,"length1":21,"length2":21},{"diffs":[[0,"+ (this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".z * thi"]],"start1":14694,"start2":14694,"length1":21,"length2":21},{"diffs":[[0," * this."],[-1,"ra"],[1,"swi"],[0,"ng"],[-1,"e"],[0,".x))\n\n  "]],"start1":14709,"start2":14709,"length1":21,"length2":21},{"diffs":[[0,"       this."],[-1,"fieldO"],[1,"o"],[0,"ffset.x = (x"]],"start1":14826,"start2":14826,"length1":30,"length2":25},{"diffs":[[0,"       this."],[-1,"fieldO"],[1,"o"],[0,"ffset.y = (y"]],"start1":14866,"start2":14866,"length1":30,"length2":25},{"diffs":[[0,"       this."],[-1,"fieldO"],[1,"o"],[0,"ffset.z = (z"]],"start1":14906,"start2":14906,"length1":30,"length2":25},{"diffs":[[0,"].x -= this."],[-1,"fieldO"],[1,"o"],[0,"ffset.x\n    "]],"start1":15150,"start2":15150,"length1":30,"length2":25},{"diffs":[[0,"].y -= this."],[-1,"fieldO"],[1,"o"],[0,"ffset.y\n    "]],"start1":15197,"start2":15197,"length1":30,"length2":25},{"diffs":[[0,"-= this."],[-1,"fieldO"],[1,"o"],[0,"ffset.z\n"]],"start1":15248,"start2":15248,"length1":22,"length2":17},{"diffs":[[0,"   this."],[-1,"field"],[1,"y"],[0,"Scale"],[-1,"Y"],[0," = Math."]],"start1":19690,"start2":19690,"length1":27,"length2":22},{"diffs":[[0,"   this."],[-1,"field"],[1,"z"],[0,"Scale"],[-1,"Z"],[0," = Math."]],"start1":19766,"start2":19766,"length1":27,"length2":22},{"diffs":[[0,"ely "],[-1,"rebalance the Y and Z components of"],[1,"correct"],[0," the"]],"start1":19861,"start2":19861,"length1":43,"length2":15},{"diffs":[[0,"sing vectors"],[1,", using yScale & zScale:"],[0,"\n           "]],"start1":19887,"start2":19887,"length1":24,"length2":48},{"diffs":[[0,"(NN) * this."],[-1,"field"],[1,"y"],[0,"Scale"],[-1,"Y"],[0,"\n        let"]],"start1":20149,"start2":20149,"length1":35,"length2":30},{"diffs":[[0," * this."],[-1,"field"],[1,"y"],[0,"Scale"],[-1,"Y"],[0,"\n       "]],"start1":20197,"start2":20197,"length1":27,"length2":22},{"diffs":[[0," * this."],[-1,"field"],[1,"z"],[0,"Scale"],[-1,"Z"],[0,"\n       "]],"start1":20241,"start2":20241,"length1":27,"length2":22},{"diffs":[[0," * this."],[-1,"field"],[1,"z"],[0,"Scale"],[-1,"Z"],[0,"\n\n      "]],"start1":20315,"start2":20315,"length1":27,"length2":22},{"diffs":[[0,"     // "],[-1,"S"],[1,"s"],[0,"ince the"]],"start1":20334,"start2":20334,"length1":17,"length2":17},{"diffs":[[0,"axis"],[-1," (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)"],[0,"\n   "]],"start1":20525,"start2":20525,"length1":131,"length2":8},{"diffs":[[0,"6000"],[-1,", true"],[0,")\n  "]],"start1":23432,"start2":23432,"length1":14,"length2":8},{"diffs":[[0,"  result = 0"],[1,"\n\n                basic.showString(\"D\") // dump the smoothed raw scan data\n                scan.dump()"],[0,"\n           "]],"start1":23452,"start2":23452,"length1":24,"length2":126}]}]},{"timestamp":1727952504777,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ive "],[-1,"dynamically "],[0,"the "]],"start1":20561,"start2":20561,"length1":20,"length2":8},{"diffs":[[0,"rmalised()\n\n"],[1,"\n"],[0,"        let "]],"start1":20931,"start2":20931,"length1":24,"length2":25},{"diffs":[[0,"0 //"],[-1," just a"],[0," deb"]],"start1":20964,"start2":20964,"length1":15,"length2":8},{"diffs":[[0,"    }\n    }\n"],[-1,"\n"],[0,"    // dump "]],"start1":21533,"start2":21533,"length1":25,"length2":24},{"diffs":[[0,"\", this."],[-1,"field"],[1,"y"],[0,"Scale"],[-1,"Y"],[0,"),\n     "]],"start1":21681,"start2":21681,"length1":27,"length2":22},{"diffs":[[0,"\", this."],[-1,"field"],[1,"z"],[0,"Scale"],[-1,"Z"],[0,"),\n     "]],"start1":21737,"start2":21737,"length1":27,"length2":22},{"diffs":[[0,"n()\n            "],[1,"ready = true"],[0,"\n            bre"]],"start1":24463,"start2":24463,"length1":32,"length2":44},{"diffs":[[0,"0))\n}\n\n/"],[-1,"*"],[1,"/"],[0," eventua"]],"start1":25724,"start2":25724,"length1":17,"length2":17},{"diffs":[[0,"r {\n"],[-1,"\n    let nSamples = scan."],[1,"    strength = -1\n    scanPeriod = -1\n\n    // unless data has already been pre-loaded into scan[]...\n    // if (!debugMode) \n\n    this.samples.length = "],[0,"samp"]],"start1":25801,"start2":25801,"length1":33,"length2":160},{"diffs":[[0," = s"],[-1,"can.times[scan"],[1,"amples[this"],[0,".sam"]],"start1":26163,"start2":26163,"length1":22,"length2":19},{"diffs":[[0,"- 1]"],[-1," = scan.times[0]"],[1,".time = samples[0].time"],[0,"\n   "]],"start1":26194,"start2":26194,"length1":24,"length2":31},{"diffs":[[0," }\n\n    "],[-1,"let "],[0,"strength"]],"start1":26353,"start2":26353,"length1":20,"length2":16},{"diffs":[[0,"e\n    }\n"],[1,"    "],[0,"*/\n\n\nfun"]],"start1":26960,"start2":26960,"length1":16,"length2":20},{"diffs":[[0,"ion "],[-1,"getHeading() {\n    let reading: Reading = takeReading()"],[1,"process() {"],[0,"\n   "]],"start1":26982,"start2":26982,"length1":63,"length2":19},{"diffs":[[0,"magnetXYZ = "],[-1,"reading.f"],[1,"correctedF"],[0,"ield"],[1,"()"],[0,"\n    gravity"]],"start1":27002,"start2":27002,"length1":37,"length2":40},{"diffs":[[0,"tyXYZ = "],[-1,"reading.pose"],[1,"correctedGravity()"],[0,"\n    dat"]],"start1":27040,"start2":27040,"length1":28,"length2":34}]}]},{"timestamp":1727953061136,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"let "],[-1,"bear"],[1,"newRead"],[0,"ing: "],[-1,"number"],[1,"Reading"],[0,"\n   "]],"start1":23307,"start2":23307,"length1":23,"length2":27},{"diffs":[[0,"tNorth:\n"],[1,"            newReading = takeReading()\n\n"],[0,"        "]],"start1":24335,"start2":24335,"length1":16,"length2":56},{"diffs":[[0,"ng(\"N\")\n"],[-1,""],[0,"        "]],"start1":24409,"start2":24409,"length1":16,"length2":16},{"diffs":[[0,"c.clearScreen()\n"],[1,"            \n"],[0,"            brea"]],"start1":24480,"start2":24480,"length1":32,"length2":45},{"diffs":[[0,"    "],[-1,"bear"],[1,"newRead"],[0,"ing = "],[-1,"getH"],[1,"takeR"],[0,"eadi"]],"start1":24568,"start2":24568,"length1":22,"length2":26},{"diffs":[[0,"keReading()\n"],[1,"\n"],[0,"            "]],"start1":24587,"start2":24587,"length1":24,"length2":25},{"diffs":[[0,"ber("],[-1,"bear"],[1,"head"],[0,"ing)\n"],[-1,"            pause(1000)\n            basic.clearScreen(\n"],[0,"    "]],"start1":24625,"start2":24625,"length1":72,"length2":17}]}]},{"timestamp":1727953408145,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sic.clearScreen("],[-1,")"],[0,"\n            bre"]],"start1":24614,"start2":24614,"length1":33,"length2":32}]}]},{"timestamp":1727972937840,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e {\n"],[-1,"                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n"],[0,"    "]],"start1":23787,"start2":23787,"length1":186,"length2":8},{"diffs":[[0,"(1000)\n\n"],[1,"                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n"],[0,"        "]],"start1":24153,"start2":24153,"length1":16,"length2":194}]}]},{"timestamp":1727973029275,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," derive the "],[1,"global "],[0,"correction p"]],"start1":10279,"start2":10279,"length1":24,"length2":31},{"diffs":[[0,"eter"],[-1," (used for future readings). \n *"],[1,"."],[0," Ana"]],"start1":10339,"start2":10339,"length1":40,"length2":9},{"diffs":[[0,"ysis of "],[-1,"the"],[1,"a"],[0," dataset"]],"start1":10349,"start2":10349,"length1":19,"length2":17},{"diffs":[[0,"the "],[-1,"orientation of the "],[0,"spin"]],"start1":10413,"start2":10413,"length1":27,"length2":8},{"diffs":[[0,"e).\n * \n"],[-1,""],[0,"*/\n"],[1,"\n\n\n\n"],[0,"class Sc"]],"start1":10465,"start2":10465,"length1":19,"length2":23},{"diffs":[[0," at rest"],[-1,"."],[1,","],[0,"\n    */\n"],[-1,"\n"],[0,"// ====="]],"start1":23215,"start2":23215,"length1":26,"length2":25},{"diffs":[[0,"    "],[-1,"}\n"],[0,"    "],[-1,"        // now analyse the "],[1,"result = 0\n            }\n"],[0,"\n   "]],"start1":23664,"start2":23664,"length1":41,"length2":37},{"diffs":[[0,"            "],[1,"    "],[0,"// analyse a"]],"start1":23969,"start2":23969,"length1":24,"length2":28},{"diffs":[[0,"ata\n            "],[1,"    "],[0,"basic.showString"]],"start1":24015,"start2":24015,"length1":32,"length2":36},{"diffs":[[0,"            "],[1,"  "],[1,"  "],[0,"scan.scope()"]],"start1":24057,"start2":24057,"length1":24,"length2":28},{"diffs":[[0,"can.scope()\n"],[1,"    "],[0,"            "]],"start1":24074,"start2":24074,"length1":24,"length2":28},{"diffs":[[0,"n.analyse()\n"],[1,"    "],[0,"            "]],"start1":24105,"start2":24105,"length1":24,"length2":28},{"diffs":[[0,") {\n            "],[-1,"}\n"],[1,"    }\n    "],[0,"            // a"]],"start1":24148,"start2":24148,"length1":34,"length2":42},{"diffs":[[0,"ta?\n            "],[1,"  "],[1,"  "],[0,"basic.showString"]],"start1":24225,"start2":24225,"length1":32,"length2":36},{"diffs":[[0,"            "],[1,"    "],[0,"scan.recentr"]],"start1":24278,"start2":24278,"length1":24,"length2":28},{"diffs":[[0,".recentre()\n"],[1,"    "],[0,"            "]],"start1":24298,"start2":24298,"length1":24,"length2":28}]}]},{"timestamp":1727973520726,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   }"],[-1,"\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }"],[0,"\n   "]],"start1":13523,"start2":13523,"length1":450,"length2":8},{"diffs":[[0,"imes\n    }\n\n"],[1,"\n    // dump this scan to the datalogger\n    dumpRaw() {\n        for (let i = 0; i < this.samples.length; i++) {\n            datalogger.log(\n                datalogger.createCV(\"data\", \"raw scan\"),\n                datalogger.createCV(\"fx\", this.samples[i].x),\n                datalogger.createCV(\"fy\", this.samples[i].y),\n                datalogger.createCV(\"fz\", this.samples[i].z))\n        }\n    }\n\n"],[0,"    // dump "]],"start1":21192,"start2":21192,"length1":24,"length2":425},{"diffs":[[0,"    "],[-1,"\n            scan.scope()    \n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre()\n\n            scan.analyse()\n"],[1,"// now analyse the "],[0,"\n   "]],"start1":23720,"start2":23720,"length1":160,"length2":27}]}]},{"timestamp":1727974118242,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e() "],[-1,"// find extremes of rotational variation"],[1,"   "],[0,"\n   "]],"start1":23787,"start2":23787,"length1":48,"length2":11},{"diffs":[[0,"re()"],[-1," // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0"],[1,"\n\n            scan.analyse()\n"],[0,"\n   "]],"start1":23884,"start2":23884,"length1":136,"length2":37},{"diffs":[[0,"e {\n"],[-1,"                scan.samples = [] // release memory used for scan data\n"],[0,"    "]],"start1":24007,"start2":24007,"length1":79,"length2":8},{"diffs":[[0,"tNorth:\n"],[1,"            // analyse and re-centre the data\n"],[0,"        "]],"start1":24181,"start2":24181,"length1":16,"length2":62},{"diffs":[[0,"String(\""],[-1,"N"],[1,"A"],[0,"\")\n     "]],"start1":24257,"start2":24257,"length1":17,"length2":17},{"diffs":[[0,"    "],[-1,"pause(500) // ensure accelerometer is at res"],[1,"scan.scope()\n            scan.analyse()\n            if (!simulating) {\n            }\n            // apply scaling corrections to scan data?\n            basic.showString(\"C\") // correc"],[0,"t\n  "]],"start1":24277,"start2":24277,"length1":52,"length2":191},{"diffs":[[0,"   s"],[-1,"etNorth"],[1,"can.recentre"],[0,"()"],[1,"\n"],[0,"  "],[-1,"// take a fix on \"North\" and the \"Down\" orientation"],[1,"          pause(1000)\n\n            basic.showString(\"N\")\n            setNorth()"],[0,"\n   "]],"start1":24475,"start2":24475,"length1":70,"length2":104},{"diffs":[[0,"g))\n"],[-1,"    return heading\n}\n\n\n// dump the test readings from this session to the datalogger"],[1,"}\n\n\n"],[0,"\nfun"]],"start1":28275,"start2":28275,"length1":92,"length2":12},{"diffs":[[0,"og(\n"],[-1,"            datalogger.createCV(\"data\", \"test readings\"),\n"],[0,"    "]],"start1":28382,"start2":28382,"length1":66,"length2":8},{"diffs":[[0,"compute "],[-1,"rotation "],[0,"required"]],"start1":29547,"start2":29547,"length1":25,"length2":16},{"diffs":[[0,"red "],[-1,"to "],[0,"conver"],[-1,"t XYZ readings"],[1,"sion"],[0," into "],[-1,"the "],[0,"worl"]],"start1":29560,"start2":29560,"length1":41,"length2":24}]}]},{"timestamp":1727974713682,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"setNorth() {"],[1," // set NorthXYZ, and from it compute fromXYZtoENG"],[0,"\n    let rea"]],"start1":29040,"start2":29040,"length1":24,"length2":74},{"diffs":[[0,"nto the "],[1,"world "],[0,"East-Nor"]],"start1":29724,"start2":29724,"length1":16,"length2":22},{"diffs":[[0,"Gravity "],[-1,"world-"],[0,"frame\n  "]],"start1":29749,"start2":29749,"length1":22,"length2":16},{"diffs":[[0,") {\n"],[-1,"        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n\n"],[0,"    "]],"start1":31424,"start2":31424,"length1":189,"length2":8},{"diffs":[[0,"en()"],[-1,"\nbasic.showString(control.deviceName())"],[0,"\n\n/*"]],"start1":56503,"start2":56503,"length1":47,"length2":8}]}]},{"timestamp":1727975299768,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e()\n"],[-1,"    let dx = 0\n    let dy = 0\n    let dz = 0\n"],[0,"    "]],"start1":31352,"start2":31352,"length1":53,"length2":8},{"diffs":[[0," (myName) {\n"],[1,""],[0,"        case"]],"start1":31366,"start2":31366,"length1":24,"length2":24},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"x = 0\n      "]],"start1":31453,"start2":31453,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"y = 0\n      "]],"start1":31482,"start2":31482,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"z = 0\n      "]],"start1":31511,"start2":31511,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"x = -70.92\n "]],"start1":31666,"start2":31666,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"y = 44.597\n "]],"start1":31700,"start2":31700,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"z = 6.804\n  "]],"start1":31734,"start2":31734,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"x = -25.411\n"]],"start1":31897,"start2":31897,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"y = -3.251\n "]],"start1":31932,"start2":31932,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"z = -1.300\n "]],"start1":31966,"start2":31966,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"x = -85.33\n "]],"start1":32127,"start2":32127,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"y = 7.22\n   "]],"start1":32161,"start2":32161,"length1":25,"length2":35},{"diffs":[[0,"            "],[-1,"d"],[1,"poseOffset."],[0,"z = -18.94\n "]],"start1":32193,"start2":32193,"length1":25,"length2":35},{"diffs":[[0,"        "],[-1,"d"],[1,"poseOffset."],[0,"x = -74."]],"start1":32361,"start2":32361,"length1":17,"length2":27},{"diffs":[[0,"        "],[-1,"d"],[1,"poseOffset."],[0,"y = 8.45"]],"start1":32396,"start2":32396,"length1":17,"length2":27},{"diffs":[[0,"        "],[-1,"d"],[1,"poseOffset."],[0,"z = -7.6"]],"start1":32429,"start2":32429,"length1":17,"length2":27},{"diffs":[[0,"eak\n"],[1,""],[0,"    } \n"],[-1,"    poseOffset = new Vector(dx, dy, dz)\n"],[0,"}\n\nf"]],"start1":32696,"start2":32696,"length1":55,"length2":15}]}]},{"timestamp":1727975896936,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"Z /= Window\n"],[1,"        reading =  new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n"],[0,"    }\n\n    /"]],"start1":30691,"start2":30691,"length1":24,"length2":100},{"diffs":[[0,"ons\n    "],[1,"reading."],[0,"field"],[-1,"X"],[1,".x"],[0," -= scan"]],"start1":30807,"start2":30807,"length1":22,"length2":31},{"diffs":[[0,"    "],[1,"reading."],[0,"field"],[-1,"Y"],[1,".y"],[0," = ("],[1,"reading."],[0,"field"],[-1,"Y"],[1,".y"],[0," - s"]],"start1":30853,"start2":30853,"length1":24,"length2":42},{"diffs":[[0,"    "],[1,"reading."],[0,"field"],[-1,"Z"],[1,".z"],[0," = ("],[1,"reading."],[0,"field"],[-1,"Z"],[1,".z"],[0," - s"]],"start1":30933,"start2":30933,"length1":24,"length2":42},{"diffs":[[0,"leZ\n    "],[1,"reading."],[0,"pose"],[-1,"X"],[1,".x"],[0," -= pose"]],"start1":31009,"start2":31009,"length1":21,"length2":30},{"diffs":[[0,"    "],[1,"reading."],[0,"pose"],[-1,"Y"],[1,".y"],[0," = ("],[1,"reading."],[0,"pose"],[-1,"Y"],[1,".y"],[0," - p"]],"start1":31048,"start2":31048,"length1":22,"length2":40},{"diffs":[[0,"    "],[1,"reading."],[0,"pose"],[-1,"Z"],[1,".z"],[0," = ("],[1,"reading."],[0,"pose"],[-1,"Z"],[1,".z"],[0," - p"]],"start1":31114,"start2":31114,"length1":22,"length2":40},{"diffs":[[0,"urn "],[-1,"new R"],[1,"r"],[0,"eading"],[-1,"(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)"],[0,"\n}\n\n"]],"start1":31187,"start2":31187,"length1":64,"length2":15}]}]},{"timestamp":1727976232955,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= Tasks."],[-1,"PerformScan"],[1,"TakeBearing"],[0,"\n    cha"]],"start1":22397,"start2":22397,"length1":27,"length2":27}]}]},{"timestamp":1727976737335,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," scanZ[i]))\n"],[1,"        times.push(times[i])\n"],[0,"    }\n\n    /"]],"start1":55624,"start2":55624,"length1":24,"length2":53}]}]},{"timestamp":1728021741745,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"anZ[i]))\n    }\n\n"],[1,"    // adopt them, as if just scanned\n    scan.use(samples, times)\n\n"],[0,"    // assemble "]],"start1":55627,"start2":55627,"length1":32,"length2":100}]}]},{"timestamp":1728022047399,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ys into "],[-1,"the scan "],[0,"array of"]],"start1":55483,"start2":55483,"length1":25,"length2":16},{"diffs":[[0,"ples...\n    "],[-1,"scan."],[0,"samples = []"]],"start1":55503,"start2":55503,"length1":29,"length2":24},{"diffs":[[0," []\n"],[-1,"    scan.times = []\n"],[0,"    "]],"start1":55524,"start2":55524,"length1":28,"length2":8},{"diffs":[[0,") {\n        "],[-1,"scan."],[0,"samples.push"]],"start1":55569,"start2":55569,"length1":29,"length2":24},{"diffs":[[0,"]))\n"],[-1,"        scan.times.push(times[i])\n"],[0,"    "]],"start1":55632,"start2":55632,"length1":42,"length2":8},{"diffs":[[0,"===\n"],[-1,"scan = new Scan()"],[1,"let count = 0"],[0,"\nbas"]],"start1":56322,"start2":56322,"length1":25,"length2":21}]}]},{"timestamp":1728022801741,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"with X\n\n"],[1,"    range: Vector   // amplitudes in each dimension\n"],[0,"    stre"]],"start1":11088,"start2":11088,"length1":16,"length2":68},{"diffs":[[0,"an \n"],[-1,"    range: Vector   // amplitudes in each dimension\n"],[0,"    "]],"start1":11224,"start2":11224,"length1":60,"length2":8}]}]},{"timestamp":1728022862739,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tes)"],[-1,"\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan "],[0,"\n\n  "]],"start1":10818,"start2":10818,"length1":146,"length2":8},{"diffs":[[0,"with X\n\n"],[1,"    strength: number // the average magnetic field-strength detected on a scan \n    range: Vector   // amplitudes in each dimension\n"],[0,"    fiel"]],"start1":11088,"start2":11088,"length1":16,"length2":148},{"diffs":[[0,"    "],[-1,"let "],[1,"this."],[0,"range"],[-1,"X"],[1,".x"],[0," = ("]],"start1":14902,"start2":14902,"length1":18,"length2":20},{"diffs":[[0,"    "],[-1,"let "],[1,"this."],[0,"range"],[-1,"Y"],[1,".y"],[0," = ("]],"start1":14941,"start2":14941,"length1":18,"length2":20},{"diffs":[[0,"    "],[-1,"let "],[1,"this."],[0,"range"],[-1,"Z"],[1,".z"],[0," = ("]],"start1":14980,"start2":14980,"length1":18,"length2":20},{"diffs":[[0,"his."],[-1,"range = new Vector(rangeX, rangeY, "],[1,"strength = Math.sqrt((this.range.x * this."],[0,"range"],[-1,"Z)"],[1,".x) "],[0,"\n   "]],"start1":15024,"start2":15024,"length1":50,"length2":59},{"diffs":[[0,"    "],[-1,"this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + ("],[1,"                        + (this.range.y * this.range.y) \n                                + (this."],[0,"range"],[-1,"Z"],[1,".z"],[0," * "],[1,"this."],[0,"range"],[-1,"Z"],[1,".x"],[0,"))\n\n"]],"start1":15084,"start2":15084,"length1":90,"length2":127}]}]},{"timestamp":1728023158120,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lo) / 2\n"],[-1,"        \n"],[0,"    }\n\n "]],"start1":15389,"start2":15389,"length1":25,"length2":16}]}]},{"timestamp":1728023946387,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"        "],[-1,"this"],[0,"\n    }\n\n"]],"start1":15397,"start2":15397,"length1":20,"length2":16}]}]},{"timestamp":1728023954730,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"let offX"],[1,"this.fieldOffset.x"],[0," = ("]],"start1":15266,"start2":15266,"length1":16,"length2":26},{"diffs":[[0,"    "],[-1,"let offY"],[1,"this.fieldOffset.y"],[0," = ("]],"start1":15311,"start2":15311,"length1":16,"length2":26},{"diffs":[[0,"    "],[-1,"let offZ"],[1,"this.fieldOffset.z"],[0," = ("]],"start1":15356,"start2":15356,"length1":16,"length2":26},{"diffs":[[0,"this"],[-1,".fieldOffset = new Vector(offX, offY, offZ)"],[0,"\n   "]],"start1":15405,"start2":15405,"length1":51,"length2":8},{"diffs":[[0," northXYZ = "],[-1,"new Vector("],[0,"reading.fiel"]],"start1":29183,"start2":29183,"length1":35,"length2":24},{"diffs":[[0,"ield"],[-1,".x, reading.field.y, reading.field.z)"],[0,"\n   "]],"start1":29204,"start2":29204,"length1":45,"length2":8},{"diffs":[[0,"wnXYZ = "],[-1,"new Vector("],[0,"reading."]],"start1":29215,"start2":29215,"length1":27,"length2":16},{"diffs":[[0,"pose"],[-1,".x, reading.pose.y, reading.pose.z)"],[0,"\n\n  "]],"start1":29231,"start2":29231,"length1":43,"length2":8}]}]},{"timestamp":1728024385667,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"    testIndex = 0\n"],[0,"    "]],"start1":56382,"start2":56382,"length1":26,"length2":8}]}]},{"timestamp":1728024844765,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n()\n"],[-1,"            nextTask = Tasks.TakeBearing\n"],[0,"    "]],"start1":24596,"start2":24596,"length1":49,"length2":8},{"diffs":[[0,"ame\n"],[-1,"    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n"],[0,"    "]],"start1":29783,"start2":29783,"length1":99,"length2":8},{"diffs":[[0,"ownXYZ, "],[-1,"vertical"],[1,"new Vector(0, 0, 1000)"],[0,")\n}\n\n\n\n/"]],"start1":29822,"start2":29822,"length1":24,"length2":38}]}]},{"timestamp":1728025373610,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n\n    /"],[-1,"*"],[1,"/"],[0," adopt a"]],"start1":21469,"start2":21469,"length1":17,"length2":17}]}]},{"timestamp":1728109477734,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"es\n    }"],[-1,"*"],[0,"\n\n    //"]],"start1":21616,"start2":21616,"length1":17,"length2":16}]}]},{"timestamp":1728109481457,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  let MM"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16631,"start2":16631,"length1":20,"length2":24},{"diffs":[[0,"  let NN"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16654,"start2":16654,"length1":20,"length2":24},{"diffs":[[0,"  let PP"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16677,"start2":16677,"length1":20,"length2":24},{"diffs":[[0,"  let QQ"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16700,"start2":16700,"length1":20,"length2":24},{"diffs":[[0,"  let RR"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16723,"start2":16723,"length1":20,"length2":24},{"diffs":[[0,"  let SS"],[-1," = 0"],[1,": number"],[0,"\n       "]],"start1":16746,"start2":16746,"length1":20,"length2":24},{"diffs":[[0,"s\n    }*"],[-1,"/"],[0,"\n\n    //"]],"start1":21617,"start2":21617,"length1":17,"length2":16},{"diffs":[[0,"data"],[-1,"...\n                scan.times = [] // .. and their timestamps"],[0,"\n   "]],"start1":24194,"start2":24194,"length1":70,"length2":8}]}]},{"timestamp":1728109742136,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"on plane"],[-1,"\n\n    "],[0,"\n    toA"]],"start1":4395,"start2":4395,"length1":22,"length2":16}]}]},{"timestamp":1728112499553,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ane\n"],[1,"\n"],[0,"    "],[-1,"v) {\n\n    d = dot(u, v)\n    w = cross(u, v)\n\n    return Quaternion(d + sqrt(d * d + dot(w, w)), w).normalize()\n}\n"],[0,"\n   "]],"start1":4400,"start2":4400,"length1":125,"length2":13}]}]},{"timestamp":1728112506978,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"/*\n        function fromVectors(u, v) {\n        "],[1,"v) {\n\n"],[0,"    "]],"start1":4404,"start2":4404,"length1":56,"length2":14},{"diffs":[[0,"= dot(u, v)\n"],[-1,"        "],[0,"    w = cros"]],"start1":4420,"start2":4420,"length1":32,"length2":24},{"diffs":[[0,"s(u, v)\n"],[-1,"      "],[1,"\n"],[0,"    "],[-1,"  "],[0,"return Q"]],"start1":4444,"start2":4444,"length1":28,"length2":21},{"diffs":[[0,"e()\n"],[-1,"        }\n\n\n    */"],[1,"}"],[0,"\n\n"],[-1,"    \n"],[0,"    "]],"start1":4515,"start2":4515,"length1":33,"length2":11},{"diffs":[[0,"        "],[-1,"let dot ="],[1,"this.w = (a.getMagnitude() * b.getMagnitude()) +"],[0," a.dotte"]],"start1":4565,"start2":4565,"length1":25,"length2":64},{"diffs":[[0,"(b)\n"],[-1,"            this.w = dot\n"],[0,"    "]],"start1":4705,"start2":4705,"length1":33,"length2":8}]}]},{"timestamp":1728112885315,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n   "],[-1,"Quaternion get_rotation_between("],[1,"     function from"],[0,"Vector"],[-1,"3 "],[1,"s("],[0,"u,"],[-1," Vector3"],[0," v)"],[-1,"\n"],[1," "],[0,"{\n  "],[-1,"float k_cos_theta"],[1,"          d"],[0," = d"]],"start1":4410,"start2":4410,"length1":83,"length2":55},{"diffs":[[0,", v)"],[-1,";"],[0,"\n  "],[-1,"float k = sqrt(length_2(u) * length_2(v));\n\n  if (k_cos_theta / k == -1"],[1,"          w = cross(u, v"],[0,")\n  "],[-1,"{\n"],[0,"    "],[-1,"// 180 degree rotation around any orthogonal vector\n    return Quaternion(0, normalized(orthogonal(u)));\n  }\n\n  return normalized(Quaternion(k_cos_theta + k, cross(u, v)));\n}"],[1,"      return Quaternion(d + sqrt(d * d + dot(w, w)), w).normalize()\n        }\n\n"],[0,"\n   "]],"start1":4469,"start2":4469,"length1":267,"length2":122}]}]},{"timestamp":1728113580242,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tor3 v)\n"],[-1,"    {\n  "],[1,"{\n"],[0,"  float "]],"start1":4460,"start2":4460,"length1":24,"length2":18},{"diffs":[[0,", v);\n  "],[-1," "],[-1," "],[0,"float k "]],"start1":4497,"start2":4497,"length1":18,"length2":16},{"diffs":[[0,"2(v));\n\n"],[-1,"  "],[0,"  if (k_"]],"start1":4541,"start2":4541,"length1":18,"length2":16},{"diffs":[[0,")\n  "],[-1,"  {\n  "],[1,"{\n"],[0,"    "],[-1,"  "],[0,"// 1"]],"start1":4576,"start2":4576,"length1":20,"length2":14},{"diffs":[[0," vector\n"],[-1,"    "],[0,"    retu"]],"start1":4630,"start2":4630,"length1":20,"length2":16},{"diffs":[[0,"u)));\n  "],[-1," "],[-1," "],[0,"}\n\n"],[-1,"  "],[0,"  return"]],"start1":4685,"start2":4685,"length1":23,"length2":19},{"diffs":[[0,", v)));\n"],[-1,"    "],[0,"}\n    */"]],"start1":4751,"start2":4751,"length1":20,"length2":16}]}]},{"timestamp":1728113584270,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ctor3 v)"],[-1,"  {"],[0,"\n    "],[1,"{\n"],[0,"    floa"]],"start1":4459,"start2":4459,"length1":24,"length2":23},{"diffs":[[0,"v);\n    "],[-1,"  "],[-1,"  "],[0,"float k "]],"start1":4505,"start2":4505,"length1":20,"length2":16},{"diffs":[[0,"ngth_2(v));\n"],[-1,"    "],[1,"\n"],[0,"    if (k_co"]],"start1":4544,"start2":4544,"length1":28,"length2":25},{"diffs":[[0,"-1)\n    "],[-1,"    {\n    "],[1,"{\n"],[0,"        "]],"start1":4584,"start2":4584,"length1":26,"length2":18},{"diffs":[[0,"tor\n        "],[-1,"    "],[0,"return Quate"]],"start1":4650,"start2":4650,"length1":28,"length2":24},{"diffs":[[0,"l(u)));\n    "],[-1," "],[-1,"   }\n\n    "],[1,"}\n\n"],[0,"    return n"]],"start1":4703,"start2":4703,"length1":35,"length2":27},{"diffs":[[0,"        "],[-1,"this.w"],[1,"let dot"],[0," = a.dot"]],"start1":4845,"start2":4845,"length1":22,"length2":23},{"diffs":[[0,"(b)\n"],[-1,"        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n"],[0,"    "]],"start1":4875,"start2":4875,"length1":71,"length2":8}]}]},{"timestamp":1728113708253,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," length\n"],[-1,"            \n"],[0,"        "]],"start1":5266,"start2":5266,"length1":29,"length2":16}]}]},{"timestamp":1728117871594,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"        "],[-1,"this."],[0,"\n       "]],"start1":5278,"start2":5278,"length1":21,"length2":16}]}]},{"timestamp":1728117873828,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"if ("],[-1,"k < 0.0001) {\n            \n        }\n        if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length"],[1,"this.w > 0.0001) {\n            let axis = a.crossedWith(b)"],[0,"\n   "]],"start1":4977,"start2":4977,"length1":179,"length2":66},{"diffs":[[0,"his.w = "],[-1,"0"],[1,"dot"],[0,"\n       "]],"start1":5053,"start2":5053,"length1":17,"length2":19},{"diffs":[[0,"his.i = "],[-1,"-"],[0,"a"],[1,"xis"],[0,".x\n     "]],"start1":5078,"start2":5078,"length1":18,"length2":20},{"diffs":[[0,"his.j = "],[-1,"-"],[0,"a"],[1,"xis"],[0,".y\n     "]],"start1":5106,"start2":5106,"length1":18,"length2":20},{"diffs":[[0,"his.k = "],[-1,"-"],[0,"a"],[1,"xis"],[0,".z\n     "]],"start1":5134,"start2":5134,"length1":18,"length2":20},{"diffs":[[0,"    "],[-1,"let axis = a.crossedWith(b)"],[1,"// vectors are aligned, or ~180 degrees apart, so pick an arbitrary axis with a non-zero length"],[0,"\n   "]],"start1":5174,"start2":5174,"length1":35,"length2":103},{"diffs":[[0,"           this."],[-1,"w = dot"],[0,"\n            thi"]],"start1":5275,"start2":5275,"length1":39,"length2":32},{"diffs":[[0,"       this.i = "],[-1,"axis.x"],[1,"-a.z"],[0,"\n            thi"]],"start1":5297,"start2":5297,"length1":38,"length2":36},{"diffs":[[0,"      this.j = a"],[-1,"xis"],[0,".y\n            t"]],"start1":5324,"start2":5324,"length1":35,"length2":32},{"diffs":[[0,"      this.k = a"],[1,"."],[0,"x"],[-1,"is.z"],[0,"\n        } else "]],"start1":5349,"start2":5349,"length1":37,"length2":34},{"diffs":[[0," = a.x\n        }"],[-1," else {"],[0,"\n        this.no"]],"start1":5361,"start2":5361,"length1":39,"length2":32}]}]},{"timestamp":1728118329278,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".0001) {"],[-1," "],[0,"\n       "]],"start1":4986,"start2":4986,"length1":17,"length2":16}]}]},{"timestamp":1728134751312,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0001) { "],[-1,"/"],[0,"\n       "]],"start1":4987,"start2":4987,"length1":17,"length2":16}]}]},{"timestamp":1728134751427,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," { /"],[-1,"/ vectors align: use identity quaternion\n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else"],[1,"\n            \n        }\n       "],[0," if "]],"start1":4992,"start2":4992,"length1":155,"length2":39}]}]},{"timestamp":1728134869981,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,");\n    }"],[-1,"\n\n    "],[0,"\n    */\n"]],"start1":4808,"start2":4808,"length1":22,"length2":16}]}]},{"timestamp":1728135873438,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"\n"],[0,"    "],[-1,"return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n        } else if (dot > 0.999999) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out[0] = tmpvec3[0];\n            out[1] = tmpvec3[1];\n            out[2] = tmpvec3[2];\n            out[3] = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };"],[0,"\n   "]],"start1":4814,"start2":4814,"length1":733,"length2":12}]}]},{"timestamp":1728135875642,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    // another version:"],[0,"\n   "]],"start1":4814,"start2":4814,"length1":31,"length2":8},{"diffs":[[0,"     out"],[-1,".i"],[1,"[0]"],[0," = 0;\n  "]],"start1":5208,"start2":5208,"length1":18,"length2":19},{"diffs":[[0,"     out"],[-1,".j"],[1,"[1]"],[0," = 0;\n  "]],"start1":5232,"start2":5232,"length1":18,"length2":19},{"diffs":[[0,"     out"],[-1,".k"],[1,"[2]"],[0," = 0;\n  "]],"start1":5256,"start2":5256,"length1":18,"length2":19},{"diffs":[[0,"         out"],[-1,".w"],[1,"[3]"],[0," = 1;\n      "]],"start1":5276,"start2":5276,"length1":26,"length2":27},{"diffs":[[0,"     out"],[-1,".i"],[1,"[0]"],[0," = tmpve"]],"start1":5360,"start2":5360,"length1":18,"length2":19},{"diffs":[[0," tmpvec3"],[-1,".x"],[1,"[0]"],[0,";\n      "]],"start1":5373,"start2":5373,"length1":18,"length2":19},{"diffs":[[0,"     out"],[-1,".j"],[1,"[1]"],[0," = tmpve"]],"start1":5393,"start2":5393,"length1":18,"length2":19},{"diffs":[[0," tmpvec3"],[-1,".y"],[1,"[1]"],[0,";\n      "]],"start1":5406,"start2":5406,"length1":18,"length2":19},{"diffs":[[0,"     out"],[-1,".k"],[1,"[2]"],[0," = tmpve"]],"start1":5426,"start2":5426,"length1":18,"length2":19},{"diffs":[[0," tmpvec3"],[-1,".z"],[1,"[2]"],[0,";\n      "]],"start1":5439,"start2":5439,"length1":18,"length2":19},{"diffs":[[0,"     out"],[-1,".w"],[1,"[3]"],[0," = 1 + d"]],"start1":5459,"start2":5459,"length1":18,"length2":19},{"diffs":[[0,"\n    };\n"],[-1,"\n\n"],[0,"    */\n\n"]],"start1":5536,"start2":5536,"length1":18,"length2":16}]}]},{"timestamp":1728136075751,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"};\n\n"],[-1,"    //\n\n"],[0,"\n   "]],"start1":5553,"start2":5553,"length1":16,"length2":8}]}]},{"timestamp":1728136939551,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  //"],[-1," yet another "],[0,"\n\n\n "]],"start1":5559,"start2":5559,"length1":21,"length2":8}]}]},{"timestamp":1728136943027,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ane\n"],[1,"  "],[0,"  /*\n   "],[-1," Public Function DxQuatB"],[1,"Quaternion get_rotation_b"],[0,"etween"],[1,"("],[0,"Vector"],[-1,"s(uV1 As D3DVECTOR, uV2 As D3DVECTOR) As D3DQUATERNION\n    ' Vector uV1 is the start, vector uV2 is the end.\n    ' So, to make the two vectors parallel, we would do: uV_New = VecByQuatMultiply(uV1, QuatBetweenVectors(uV1, uV2))"],[1,"3 u, Vector3 v)  {\n        float k_cos_theta = dot(u, v);"],[0,"\n    "],[-1,"'\n"],[0,"    "],[-1,"Dim fAABB As Single\n    Dim fAB As Single\n    Dim uV3 As D3DVECTOR\n    Dim fCC As Single\n    Dim fS As Single\n    Dim fM As Single\n    '\n    fAABB = Sqr(DxVecDot(uV1, uV1) * DxVecDot(uV2, uV2))    ' Product of the lengths of the arguments.\n    If Abs(fAABB) < 0.000001! Then"],[1,"float k = sqrt(length_2(u) * length_2(v));\n        if (k_cos_theta / k == -1)\n"],[0,"        "],[1,"{\n"],[0,"    "]],"start1":4400,"start2":4400,"length1":572,"length2":210},{"diffs":[[0,"    "],[-1,"      ' The arguments are too small, return zero rotation\n        DxQuatBetweenVectors = DxQuatIdentity\n        Exit Function\n    End If\n    '\n    fAB = DxVecDot(uV1, uV2) / fAABB                        ' Normalized dot product of the arguments (cosine).\n    uV3.X = (uV1.Y * uV2.Z - uV1.Z * uV2.Y) / fAABB         ' Normalized crossproduct of the arguments.\n    uV3.Y = (uV1.Z * uV2.X - uV1.X * uV2.Z) / fAABB\n    uV3.Z = (uV1.X * uV2.Y - uV1.Y * uV2.X) / fAABB\n    fCC = DxVecDot(uV3, uV3)                                ' Squared length of the normalized crossproduct (sine).\n    '\n    If fCC <> 0! Then                                       ' Test if the arguments are not parallel or anti-parallel.\n        If fAB > -0.707106781186548 Then                    ' -Sqr(2)/2.\n            fS = 1! + fAB                                   ' Use the cosine to adjust the fS-element.\n        Else\n            fS = fCC / (1! + Sqr(1! - fCC))     "],[1,"// 180 degree rotation around any orthogonal vector\n            return Quaternion(0, normalized(orthogonal(u)));\n        }\n\n        return normalized(Quaternion(k_cos_theta + k, cross(u, v)));\n"],[0,"    "],[1,"}\n\n"],[0,"    "],[-1,"    ' Use the sine to adjust the fS-element.\n        End If\n        fM = Sqr(fCC + fS * fS)                             ' The magnitude of the quaternion.\n        '\n        DxQuatBetweenVectors.w = fS / fM                    ' Return the normalized quaternion.\n        DxQuatBetweenVectors.X = uV3.X / fM\n        DxQuatBetweenVectors.Y = uV3.Y / fM\n        DxQuatBetweenVectors.Z = uV3.Z / fM\n    Else                                                    ' Parallel or anti-parallel.\n        If fAB > 0! Then                                    ' The arguments are parallel.\n            DxQuatBetweenVectors = DxQuatIdentity\n        Else                                                ' The arguments are anti-parallel.\n            fM = Sqr(uV1.X * uV1.X + uV1.Y * uV1.Y)         ' The length of one argument projected on the XY-plane.\n            If fM <> 0! Then                                ' Return uV1 rotation with the axis in the XY-plane.\n                DxQuatBetweenVectors.w = 0!                 ' 180 degrees.\n                DxQuatBetweenVectors.X = uV1.Y / fM\n                DxQuatBetweenVectors.Y = -uV1.X / fM\n                DxQuatBetweenVectors.Z = 0!\n            Else                                            ' The arguments are parallel to the Z-axis, rotate around the X-axis.\n                DxQuatBetweenVectors.w = 0!                 ' 180 degrees.\n                DxQuatBetweenVectors.X = 1!\n                DxQuatBetweenVectors.Y = 0!\n                DxQuatBetweenVectors.Z = 0!\n            End If\n        End If\n    End If\nEnd Function"],[1,"// another version:\n    return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n        } else if (dot > 0.999999) {\n            out.i = 0;\n            out.j = 0;\n            out.k = 0;\n            out.w = 1;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out.i = tmpvec3.x;\n            out.j = tmpvec3.y;\n            out.k = tmpvec3.z;\n            out.w = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n\n    // yet another "],[0,"\n\n\n "]],"start1":4614,"start2":4614,"length1":2521,"length2":966}]}]},{"timestamp":1728136970763,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"*\n  "],[-1,"/**\n  * Sets a quaternion to represent the shortest rotation from one\n  * vector to another.\n  *\n  * Both"],[1,"  Public Function DxQuatBetweenVectors(uV1 As D3DVECTOR, uV2 As D3DVECTOR) As D3DQUATERNION\n    ' Vector uV1 is the start, vector uV2 is the end.\n    ' So, to make the two"],[0," vec"]],"start1":4407,"start2":4407,"length1":113,"length2":179},{"diffs":[[0,"ors "],[1,"p"],[0,"ar"],[-1,"e assumed to be unit length.\n  *\n  * @param {quat} out the receiving quaternion.\n  * @param {vec3} a the initial vector\n  * @param {vec3} b the destination vector\n  * @returns {quat} out\n  */\n    quat.rotationTo = (function () {\n        var tmpvec3 = vec3.create();\n        var xUnitVec3 = vec3.fromValues(1, 0, 0);\n        var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n        return function (out, a, b) {\n            var dot = vec3.dot(a, b);\n            if (dot < -0.999999) {\n                vec3.cross(tmpvec3, xUnitVec3, a);\n                if (vec3.length(tmpvec3) < 0.000001)\n                    vec3.cross(tmpvec3, yUnitVec3, a);\n                vec3.normalize(tmpvec3, tmpvec3);\n                quat.setAxisAngle(out, tmpvec3, Math.PI);\n            } else if (dot > 0.999999) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n            } e"],[1,"allel, we would do: uV_New = VecByQuatMultiply(uV1, QuatBetweenVectors(uV1, uV2))\n    '\n    Dim fAABB As Single\n    Dim fAB As Single\n    Dim uV3 As D3DVECTOR\n    Dim fCC As Single\n    Dim fS As Single\n    Dim fM As Single\n    '\n    fAABB = Sqr(DxVecDot(uV1, uV1) * DxVecDot(uV2, uV2))    ' Product of the lengths of the arguments.\n    If Abs(fAABB) < 0.000001! Then                          ' The arguments are too small, return zero rotation\n        DxQuatBetweenVectors = DxQuatIdentity\n        Exit Function\n    End If\n    '\n    fAB = DxVecDot(uV1, uV2) / fAABB                        ' Normalized dot product of the arguments (cosine).\n    uV3.X = (uV1.Y * uV2.Z - uV1.Z * uV2.Y) / fAABB         ' Normalized crossproduct of the arguments.\n    uV3.Y = (uV1.Z * uV2.X - uV1.X * uV2.Z) / fAABB\n    uV3.Z = (uV1.X * uV2.Y - uV1.Y * uV2.X) / fAABB\n    fCC = DxVecDot(uV3, uV3)                                ' Squared length of the normalized crossproduct (sine).\n    '\n    If fCC <> 0! Then                                       ' Test if the arguments are not parallel or anti-parallel.\n        If fAB > -0.707106781186548 Then                    ' -Sqr(2)/2.\n            fS = 1! + fAB                                   ' Use the cosine to adjust the fS-element.\n        Else\n            fS = fCC / (1! + Sqr(1! - fCC))                 ' Use the sine to adjust the fS-element.\n        End If\n        fM = Sqr(fCC + fS * fS)                             ' The magnitude of the quaternion.\n        '\n        DxQuatBetweenVectors.w = fS / fM                    ' Return the normalized quaternion.\n        DxQuatBetweenVectors.X = uV3.X / fM\n        DxQuatBetweenVectors.Y = uV3.Y / fM\n        DxQuatBetweenVectors.Z = uV3.Z / fM\n    Else                                                    ' Parallel or anti-parallel.\n        If fAB > 0! Then                                    ' The arguments are parallel.\n            DxQuatBetweenVectors = DxQuatIdentity\n        Else                                                ' The arguments are anti-parallel.\n            fM = Sqr(uV1.X * uV1.X + uV1.Y * uV1.Y)         ' The length of one argument projected on the XY-plane.\n            If fM <> 0! Then                                ' Return uV1 rotation with the axis in the XY-plane.\n                DxQuatBetweenVectors.w = 0!                 ' 180 degrees.\n                DxQuatBetweenVectors.X = uV1.Y / fM\n                DxQuatBetweenVectors.Y = -uV1.X / fM\n                DxQuatBetweenVectors.Z = 0!\n            E"],[0,"lse "],[-1,"{\n"],[1,"  "],[0,"    "]],"start1":4587,"start2":4587,"length1":929,"length2":2535},{"diffs":[[0,"    "],[-1,"vec3.cross(tmpvec3, a, b);\n                out[0] = tmpvec3[0];\n                out[1] = tmpvec3[1];\n                out[2] = tmpvec3[2];\n                out[3] = 1 + dot;\n                return quat.normalize(out, out);"],[1,"                         ' The arguments are parallel to the Z-axis, rotate around the X-axis.\n                DxQuatBetweenVectors.w = 0!                 ' 180 degrees.\n                DxQuatBetweenVectors.X = 1!\n                DxQuatBetweenVectors.Y = 0!\n                DxQuatBetweenVectors.Z = 0!"],[0,"\n   "]],"start1":7130,"start2":7130,"length1":228,"length2":309},{"diffs":[[0," 0!\n            "],[-1,"}"],[1,"End If"],[0,"\n        };\n    "]],"start1":7432,"start2":7432,"length1":33,"length2":38},{"diffs":[[0,"    "],[-1,"};\n    })();"],[1,"End If\n    End If\nEnd Function\n\n"],[0,"\n   "]],"start1":7459,"start2":7459,"length1":20,"length2":40}]}]},{"timestamp":1728196757386,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"} out\n  "],[1,"*/"],[0,"\n    qua"]],"start1":4708,"start2":4708,"length1":16,"length2":18}]}]},{"timestamp":1728196767673,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"} out\n  "],[-1,"*/"],[0,"\n    "],[1,"quat."],[0,"rotation"]],"start1":4708,"start2":4708,"length1":23,"length2":26},{"diffs":[[0,"ationTo "],[1,"= (function "],[0,"() {\n   "]],"start1":4729,"start2":4729,"length1":16,"length2":28},{"diffs":[[0,"();\n    "],[1,"*/"],[0,"\n\n    \n "]],"start1":5712,"start2":5712,"length1":16,"length2":18},{"diffs":[[0,"(b)\n"],[-1,"        if (this.w < )\n\n\n\n\n"],[0,"    "]],"start1":5801,"start2":5801,"length1":35,"length2":8}]}]},{"timestamp":1728197043812,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," (this.w"],[1," <"],[0," )\n\n\n\n\n "]],"start1":5798,"start2":5798,"length1":16,"length2":18}]}]},{"timestamp":1728198199695,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," (this.w"],[-1," <"],[0," )\n\n\n\n\n "]],"start1":5798,"start2":5798,"length1":18,"length2":16}]}]},{"timestamp":1728198202035,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  */"],[-1,"\n\n  /*"],[0,"\n   "]],"start1":4714,"start2":4714,"length1":14,"length2":8},{"diffs":[[0,"();\n    "],[-1,"*/\n\n\n"],[1,"\n\n    \n    "],[0,"toAlignV"]],"start1":5697,"start2":5697,"length1":21,"length2":27},{"diffs":[[0,"    "],[-1,"let dot: Vector\n    dot = a.dottedWith(b)\n    if (dot < 0.000001) { // vectors align: use identity quaternion\n        this.w = 1\n        this.i = 0\n        this.j = 0\n        this.k = 0\n    } else if (dot > 0.999999) \n\n"],[1,"    this.w = a.dottedWith(b)\n        if (this.w < )"],[0,"\n\n\n\n"]],"start1":5755,"start2":5755,"length1":227,"length2":59}]}]},{"timestamp":1728198472540,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  })();\n"],[-1,"\n\n\n"],[0,"    */\n\n"]],"start1":5699,"start2":5699,"length1":19,"length2":16},{"diffs":[[0,"(b)\n"],[-1,"    cross = a.crossedWith(b)\n"],[0,"    "]],"start1":5797,"start2":5797,"length1":37,"length2":8}]}]},{"timestamp":1728199061558,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"o align "],[-1,"unit "],[0,"vector ("]],"start1":4314,"start2":4314,"length1":21,"length2":16},{"diffs":[[0,"nto "],[-1,"unit vector "],[0,"(b)\n"]],"start1":4334,"start2":4334,"length1":20,"length2":8},{"diffs":[[0,"ane\n"],[-1,"    // The axis is just their cross-product, and the angle is deived from their dot-product\n\n\n    /* Two special cases:\n      1. If (a) parallel to (b) (or very close), use the unit Quaternion (1,0,0,0)\n      2. If (a) opposite to (b) (or very close), we need a rotation by 180 degrees around any orthogonal axis\n"],[0,"  /*"]],"start1":4400,"start2":4400,"length1":321,"length2":8}]}]},{"timestamp":1728199653126,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"w = "],[-1,"1 + dot // gives half-angle after normalisation"],[1,"dot"],[0,"\n   "]],"start1":6885,"start2":6885,"length1":55,"length2":11}]}]},{"timestamp":1728199704831,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"99999) {"],[-1," "],[0,"\n       "]],"start1":5315,"start2":5315,"length1":17,"length2":16}]}]},{"timestamp":1728232608678,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"if (dot "],[1,"< 0.000001"],[0,") { // v"]],"start1":6168,"start2":6168,"length1":16,"length2":26}]}]},{"timestamp":1728232635296,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    let "],[-1,"cross"],[1,"dot"],[0,": Vector"]],"start1":6089,"start2":6089,"length1":21,"length2":19},{"diffs":[[0,"dot "],[-1,"> 0.999999) { \n       "],[1,") {"],[0," // "]],"start1":6172,"start2":6172,"length1":30,"length2":11},{"diffs":[[0,"aternion"],[-1," "],[0,"\n       "]],"start1":6213,"start2":6213,"length1":17,"length2":16},{"diffs":[[0," } else if (dot "],[-1,"< -"],[1,"> "],[0,"0.999999) { \n   "]],"start1":6301,"start2":6301,"length1":35,"length2":34},{"diffs":[[0,"99) "],[-1,"{ \n        // vectors are opposite: need 180 degree rotation about any orthogonal axis\n        // first try using the normal to the plane containing (a) and the x-axis\n        cross = a.crossedWith(new Vector(1,0,0))\n\n    }"],[0,"\n\n\n\n"]],"start1":6325,"start2":6325,"length1":231,"length2":8}]}]},{"timestamp":1728233474598,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"al axis\n"],[-1,"        \n"],[0,"        "]],"start1":6431,"start2":6431,"length1":25,"length2":16}]}]},{"timestamp":1728233488173,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"site"],[-1,"s: we"],[1,":"],[0," nee"]],"start1":6382,"start2":6382,"length1":13,"length2":9},{"diffs":[[0,"need 180"],[-1,"-"],[1," "],[0,"degree r"]],"start1":6388,"start2":6388,"length1":17,"length2":17},{"diffs":[[0,"hogonal axis"],[-1,"."],[0,"\n        \n  "]],"start1":6426,"start2":6426,"length1":25,"length2":24},{"diffs":[[0,"   \n"],[-1,"        // \n"],[0,"    "]],"start1":6444,"start2":6444,"length1":20,"length2":8}]}]},{"timestamp":1728233849442,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," vectors"],[1," are opposites"],[0,": we nee"]],"start1":6365,"start2":6365,"length1":16,"length2":30}]}]},{"timestamp":1728285266737,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"     // "],[-1,"an"],[0,"vectors:"]],"start1":6358,"start2":6358,"length1":18,"length2":16}]}]},{"timestamp":1728285270297,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"h(b)"],[-1," // fails if "],[0,"\n   "]],"start1":6161,"start2":6161,"length1":21,"length2":8},{"diffs":[[0,"  //"],[-1," parallel"],[0," vectors"],[1," align"],[0,": us"]],"start1":6199,"start2":6199,"length1":25,"length2":22},{"diffs":[[0,"/ an"],[-1,"ti-parallel "],[0,"vect"]],"start1":6364,"start2":6364,"length1":20,"length2":8},{"diffs":[[0,"gonal axis.\n"],[1,"        \n        // \n"],[0,"        // f"]],"start1":6420,"start2":6420,"length1":24,"length2":45},{"diffs":[[0,"ane "],[-1,"through"],[1,"containing"],[0," (a)"]],"start1":6500,"start2":6500,"length1":15,"length2":18},{"diffs":[[0,"0,0)"],[-1,"\n        // \n        \n        \n        )\n        // so half-angle will be 90 degrees\n        "],[1,")"],[0,"\n\n  "]],"start1":6577,"start2":6577,"length1":101,"length2":9}]}]},{"timestamp":1728285488511,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"r(1,0,0)"],[-1,")"],[0,"\n       "]],"start1":6577,"start2":6577,"length1":17,"length2":16},{"diffs":[[0," // "],[-1,"if (by chance) a WAS the x-axis, use the y-axis as our rotation axis\n        if()"],[0,"\n   "]],"start1":6593,"start2":6593,"length1":89,"length2":8}]}]},{"timestamp":1728286087340,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"xis\n"],[-1,"\n\n    toAlignVectors(a: Vector, b: Vector) {\n        let cross: Vector"],[1,"  /*\n  /**\n  * Sets a quaternion to represent the shortest rotation from one\n  * vector to another.\n  *\n  * Both vectors are assumed to be unit length.\n  *\n  * @param {quat} out the receiving quaternion.\n  * @param {vec3} a the initial vector\n  * @param {vec3} b the destination vector\n  * @returns {quat} out\n  */\n\n  /*\n    rotationTo () {\n        var tmpvec3 = vec3.create();\n        var xUnitVec3 = vec3.fromValues(1, 0, 0);\n        var yUnitVec3 = vec3.fromValues(0, 1, 0);\n"],[0,"\n   "]],"start1":4730,"start2":4730,"length1":78,"length2":486},{"diffs":[[0,"    "],[-1,"let dot = a.dottedWith(b)\n        cross = a.crossedWith(b) // degenerates if vectors align \n    "],[1,"return function (out, a, b) {\n            var dot = vec3.dot(a, b);\n            if (dot < -0.999999) { \n                vec3.cross(tmpvec3, xUnitVec3, a);\n                if (vec3.length(tmpvec3) < 0.000001)\n                    vec3.cross(tmpvec3, yUnitVec3, a);\n                vec3.normalize(tmpvec3, tmpvec3);\n                quat.setAxisAngle(out, tmpvec3, Math.PI);\n            } else if (dot > 0.999999) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n            } else {\n                vec3.cross(tmpvec3, a, b);\n                out[0] = tmpvec3[0];\n                out[1] = tmpvec3[1];\n                out[2] = tmpvec3[2];\n                out[3] = 1 + dot;\n                return quat.normalize(out, out);\n            }\n        };\n    })();\n\n\n\n    */\n\n\ntoAlignVectors(a: Vector, b: Vector) {\n    let cross: Vector\n    dot = a.dottedWith(b)\n    cross = a.crossedWith(b) // fails if \n"],[0,"    "]],"start1":5217,"start2":5217,"length1":104,"length2":966},{"diffs":[[0,"ot > 0.999999) {"],[-1,"\n   "],[0," "],[1,"\n"],[0,"        // paral"]],"start1":6188,"start2":6188,"length1":37,"length2":34},{"diffs":[[0,"ernion \n        "],[-1,"    "],[0,"this.w = 1\n     "]],"start1":6252,"start2":6252,"length1":36,"length2":32},{"diffs":[[0,"s.w = 1\n        "],[-1,"    "],[0,"this.i = 0\n     "]],"start1":6271,"start2":6271,"length1":36,"length2":32},{"diffs":[[0," this.i = 0\n"],[-1,"    "],[0,"        this"]],"start1":6286,"start2":6286,"length1":28,"length2":24},{"diffs":[[0,"s.j = 0\n        "],[-1,"    "],[0,"this.k = 0\n     "]],"start1":6309,"start2":6309,"length1":36,"length2":32},{"diffs":[[0," this.k = 0\n"],[-1,"    "],[0,"    } else i"]],"start1":6324,"start2":6324,"length1":28,"length2":24},{"diffs":[[0,"t < -0.999999) {"],[-1,"\n   "],[0," "],[1,"\n"],[0,"        // anti-"]],"start1":6353,"start2":6353,"length1":37,"length2":34},{"diffs":[[0," vectors"],[1,": we"],[0," need 18"]],"start1":6395,"start2":6395,"length1":16,"length2":20},{"diffs":[[0,"is.\n        "],[-1,"    "],[0,"// first try"]],"start1":6456,"start2":6456,"length1":28,"length2":24},{"diffs":[[0," x-axis\n        "],[-1,"    "],[0,"cross = a.crosse"]],"start1":6530,"start2":6530,"length1":36,"length2":32},{"diffs":[[0,"ector(1,"],[-1," "],[0,"0,"],[-1," "],[0,"0))\n    "]],"start1":6573,"start2":6573,"length1":20,"length2":18},{"diffs":[[0,"    "],[-1,"    "],[0,"// if "],[1,"("],[0,"by c"]],"start1":6591,"start2":6591,"length1":18,"length2":15},{"diffs":[[0,"y chance"],[-1," (a)"],[1,") a"],[0," WAS the"]],"start1":6603,"start2":6603,"length1":20,"length2":19},{"diffs":[[0,"    "],[-1,"    if (cross.getLengthSquared() < 0.00001) {\n                cross = new Vector(0, 1, 0)"],[1,"if()\n        \n        \n        )\n        // so half-angle will be 90 degrees\n        \n\n    }\n\n\n\n\n\n\n        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n        if (k < 0.0001) { // vectors align: use identity quaternion"],[0,"\n   "]],"start1":6671,"start2":6671,"length1":97,"length2":237},{"diffs":[[0,"ion\n            "],[-1,"}"],[1,"this.w = 1"],[0,"\n            thi"]],"start1":6901,"start2":6901,"length1":33,"length2":42},{"diffs":[[0,"       this.i = "],[-1,"cross.x"],[1,"0"],[0,"\n            thi"]],"start1":6933,"start2":6933,"length1":39,"length2":33},{"diffs":[[0,"       this.j = "],[-1,"cross.y"],[1,"0"],[0,"\n            thi"]],"start1":6956,"start2":6956,"length1":39,"length2":33},{"diffs":[[0,"k = "],[-1,"cross.z\n            // the half-angle needed will be 90 degrees"],[1,"0\n        } else if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.w = 0\n            this.i = -a.x"],[0,"\n   "]],"start1":6991,"start2":6991,"length1":71,"length2":200},{"diffs":[[0,"his."],[-1,"w = Math.PI"],[1,"j = -a.y\n            this.k = -a.z"],[0,"\n   "]],"start1":7201,"start2":7201,"length1":19,"length2":42},{"diffs":[[0,"    "],[-1,"this.i"],[1,"let axis"],[0," = "],[1,"a."],[0,"cross"],[-1,".x"],[1,"edWith(b)"],[0,"\n   "]],"start1":7265,"start2":7265,"length1":24,"length2":35},{"diffs":[[0,"his."],[-1,"j = cross.y"],[1,"w = 1 + dot // gives half-angle after normalisation\n            this.i = axis.x"],[0,"\n   "]],"start1":7310,"start2":7310,"length1":19,"length2":87},{"diffs":[[0,"his."],[-1,"k = cross.z"],[1,"j = axis.y"],[0,"\n   "]],"start1":7407,"start2":7407,"length1":19,"length2":18},{"diffs":[[0,"his."],[-1,"w = dot"],[1,"k = axis.z"],[0,"\n   "]],"start1":7435,"start2":7435,"length1":15,"length2":18},{"diffs":[[0,"axis.z\n        }"],[1," else {"],[0,"\n        this.no"]],"start1":7443,"start2":7443,"length1":32,"length2":39},{"diffs":[[0,"\n    }\n\n"],[-1,"\n\n"],[0,"    // u"]],"start1":7713,"start2":7713,"length1":18,"length2":16}]}]},{"timestamp":1728286656512,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"duct"],[-1,"."],[1,"\n\n"],[0,"\n    /"],[-1,"/ We need to deal with t"],[1,"* T"],[0,"wo s"]],"start1":4508,"start2":4508,"length1":39,"length2":19},{"diffs":[[0," cases:\n    "],[-1,"//  - i"],[1,"  1. I"],[0,"f (a) parall"]],"start1":4533,"start2":4533,"length1":31,"length2":30},{"diffs":[[0,"    "],[-1,"//  - i"],[1,"  2. I"],[0,"f (a"]],"start1":4624,"start2":4624,"length1":15,"length2":14},{"diffs":[[0,"l axis\n\n"],[1,"\n"],[0,"    toAl"]],"start1":4727,"start2":4727,"length1":16,"length2":17},{"diffs":[[0,"e {\n"],[-1,"            // general case\n"],[0,"    "]],"start1":5730,"start2":5730,"length1":36,"length2":8}]}]}],"snapshots":[{"timestamp":1724515575489,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1724605625899,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n   */\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n * A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n* XYZ: the microbit's Sensor-Frame\n* RFD: the buggy's Body-Frame (Right, Front, Down)\n* ENG: the World - Frame in which it is navigating(East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt((this.w * this.w)\n            + (this.i * this.i)\n            + (this.j * this.j)\n            + (this.k * this.k))\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n\n    }\n}\n\n\ninput.onButtonPressed(Button.A, function() {\n    let field = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let gravity = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n    let dot = field.dottedWith(gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log( datalogger.createCV(\"fx\", field.x),\n                    datalogger.createCV(\"fy\", field.y),\n                    datalogger.createCV(\"fz\", field.z),\n                    datalogger.createCV(\"gx\", gravity.x),\n                    datalogger.createCV(\"gy\", gravity.y),\n                    datalogger.createCV(\"gz\", gravity.z),\n                    datalogger.createCV(\"dot\", dot),\n                    datalogger.createCV(\"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n                    datalogger.createCV(\"crossz\", cross.z))\n\n})\n\nlet lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\nlet count = 0\nlet fxLo = 99999\nlet fyLo = 99999\nlet fzLo = 99999\nlet fxHi = -99999\nlet fyHi = -99999\nlet fzHi = -99999\n\nlet gxLo = 99999\nlet gyLo = 99999\nlet gzLo = 99999\nlet gxHi = -99999\nlet gyHi = -99999\nlet gzHi = -99999\nwhile (count < 25) {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n\n    // set LED pixel (px,py) if tilt angle is: \n    //         outer -45 inner +45 outer \n    // topside:     1 | 2 | 2 | 3\n    // underside:   1 | 0 | 4 | 3\n    let px=2\n    let py=2\n    let absZ = Math.abs(g.z)\n    if (g.x < -absZ) px = 1 // outer left\n    if (g.x > absZ) px = 3 // outer right\n    if (g.y < -absZ) py = 1 // outer front\n    if (g.y > absZ) py = 3 // outer back\n    // special lower hemisphere cases\n    if (g.z < 0) {\n        if ((-g.x > -g.z) && (g.x < 0)) px = 0 // lower inner left\n        if ((g.x < -g.z) && (g.x > 0)) px = 4 // lower inner right\n        if ((-g.y > -g.z) && (g.y < 0)) py = 0 // lower inner front\n        if ((g.y < -g.z) && (g.y > 0)) py = 4 // lower inner back\n    }\n    meter.show(px*10+py)\n    basic.pause(1000)\n\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        //led.plot(px,py)\n        count++\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n}\n\nlet fxOff = (fxHi + fxLo) / 2\nlet fyOff = (fyHi + fyLo) / 2\nlet fzOff = (fzHi + fzLo) / 2\nlet fxMag = (fxHi - fxLo) / 2\nlet fyMag = (fyHi - fyLo) / 2\nlet fzMag = (fzHi - fzLo) / 2\n\nlet gxOff = (gxHi + gxLo) / 2\nlet gyOff = (gyHi + gyLo) / 2\nlet gzOff = (gzHi + gzLo) / 2\nlet gxMag = (gxHi - gxLo) / 2\nlet gyMag = (gyHi - gyLo) / 2\nlet gzMag = (gzHi - gzLo) / 2\n\ndatalogger.log( datalogger.createCV(\"fxMag\", fxMag),\n                datalogger.createCV(\"fyMag\", fyMag),\n                datalogger.createCV(\"fzMag\", fzMag),\n                datalogger.createCV(\"gxMag\", gxMag),\n                datalogger.createCV(\"gyMag\", gyMag),\n                datalogger.createCV(\"gzMag\", gzMag))\n\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1724688644269,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n   */\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n * A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n* XYZ: the microbit's Sensor-Frame\n* RFD: the buggy's Body-Frame (Right, Front, Down)\n* ENG: the World - Frame in which it is navigating(East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt((this.w * this.w)\n            + (this.i * this.i)\n            + (this.j * this.j)\n            + (this.k * this.k))\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n\n    }\n}\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity()\n    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n    let dot = field.dottedWith(gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log( datalogger.createCV(\"fx\", field.x),\n                    datalogger.createCV(\"fy\", field.y),\n                    datalogger.createCV(\"fz\", field.z),\n                    datalogger.createCV(\"gx\", gravity.x),\n                    datalogger.createCV(\"gy\", gravity.y),\n                    datalogger.createCV(\"gz\", gravity.z),\n                    datalogger.createCV(\"dot\", dot),\n                    datalogger.createCV(\"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n                    datalogger.createCV(\"crossz\", cross.z))\n\n})\n\n\n\n\nlet lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\nlet count = 0\nlet fxLo = 99999\nlet fyLo = 99999\nlet fzLo = 99999\nlet fxHi = -99999\nlet fyHi = -99999\nlet fzHi = -99999\n\nlet gxLo = 99999\nlet gyLo = 99999\nlet gzLo = 99999\nlet gxHi = -99999\nlet gyHi = -99999\nlet gzHi = -99999\nwhile (count < 25) {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n\n    // set LED pixels(px,py) based on tilt angle zones. \n    let dx=0\n    let dy=0\n    let zAbs = Math.abs(g.z)\n    // left-right \n    if (g.x < -0.1 * zAbs) {\n        dx--\n        if (g.x < -0.9 * zAbs) dx--\n    }\n    if (g.x > 0.1 * zAbs) {\n        dx++\n        if (g.x > 0.9 * zAbs) dx++\n    }\n    // front-back\n    if (g.y < -0.1 * zAbs) {\n        dy--\n        if (g.y < -0.9 * zAbs) dy--\n    }\n    if (g.y > 0.1 * zAbs) {\n        dy++\n        if (g.y > 0.9 * zAbs) dy++\n    }\n    // up-down\n    if (g.z > 0) {\n        dx = 2-dx\n        dy = 2-dy\n    }\n    let px = 2+dx\n    let py = 2+dy\n\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        led.plot(px,py)\n        count++\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n        /* not much point ranging gravity: distorted by inertial movement!\n        if (g.x < gxLo) gxLo = Math.max(g.x, 0)\n        if (g.y < gyLo) gyLo = Math.max(g.y, 0)\n        if (g.z < gzLo) gzLo = Math.max(g.z, 0)\n        if (g.x > gxHi) gxHi = Math.min(g.x, 1000)\n        if (g.y > gyHi) gyHi = Math.min(g.y, 1000)\n        if (g.z > gzHi) gzHi = Math.min(g.z, 1000)\n        */\n    }\n}\nbasic.showIcon(IconNames.Happy)\n\nlet fxOff = (fxHi + fxLo) / 2\nlet fyOff = (fyHi + fyLo) / 2\nlet fzOff = (fzHi + fzLo) / 2\nlet fxMag = (fxHi - fxLo) / 2\nlet fyMag = (fyHi - fyLo) / 2\nlet fzMag = (fzHi - fzLo) / 2\n\nlet fxScale = 1000 / fxMag\nlet fyScale = 1000 / fyMag\nlet fzScale = 1000 / fzMag\n\nlet gxOff = (gxHi + gxLo) / 2\nlet gyOff = (gyHi + gyLo) / 2\nlet gzOff = (gzHi + gzLo) / 2\nlet gxMag = (gxHi - gxLo) / 2\nlet gyMag = (gyHi - gyLo) / 2\nlet gzMag = (gzHi - gzLo) / 2\n\nlet gxScale = 1000 / gxMag\nlet gyScale = 1000 / gyMag\nlet gzScale = 1000 / gzMag\n\ndatalogger.log( datalogger.createCV(\"fxOff\", fxOff),\n                datalogger.createCV(\"fyOff\", fyOff),\n                datalogger.createCV(\"fzOff\", fzOff),\n                datalogger.createCV(\"gxOff\", gxOff),\n                datalogger.createCV(\"gyOff\", gyOff),\n                datalogger.createCV(\"gzOff\", gzOff))\n\n\n\ndatalogger.log( datalogger.createCV(\"fxScale\", fxScale),\n                datalogger.createCV(\"fyScale\", fyScale),\n                datalogger.createCV(\"fzScale\", fzScale),\n                datalogger.createCV(\"gxScale\", gxScale),\n                datalogger.createCV(\"gyScale\", gyScale),\n                datalogger.createCV(\"gzScale\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG: Quaternion\n\nfunction correctedField(): Vector {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    f.x *= fxScale\n    f.y *= fyScale\n    f.z *= fzScale\n    return f\n}\n\nfunction correctedGravity(): Vector {\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    // g.x *= gxScale\n    // g.y *= gyScale\n    // g.z *= gzScale\n    return g\n}\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1724793560570,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n   */\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n * A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n* XYZ: the microbit's Sensor-Frame\n* RFD: the buggy's Body-Frame (Right, Front, Down)\n* ENG: the World - Frame in which it is navigating(East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt((this.w * this.w)\n            + (this.i * this.i)\n            + (this.j * this.j)\n            + (this.k * this.k))\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n\n    }\n}\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity()\n    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n    let dot = field.dottedWith(gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log( datalogger.createCV(\"fx\", field.x),\n                    datalogger.createCV(\"fy\", field.y),\n                    datalogger.createCV(\"fz\", field.z),\n                    datalogger.createCV(\"gx\", gravity.x),\n                    datalogger.createCV(\"gy\", gravity.y),\n                    datalogger.createCV(\"gz\", gravity.z),\n                    datalogger.createCV(\"dot\", dot),\n                    datalogger.createCV(\"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n                    datalogger.createCV(\"crossz\", cross.z))\n\n})\n\ninput.onLogoEvent(TouchButtonEvent.Pressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n})\n\n\n\n// REMEMBER: chip is on the underside, so Z is -1023 when microbit is face-up!\n\nlet lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\nlet count = 0\nlet fxLo = 99999\nlet fyLo = 99999\nlet fzLo = 99999\nlet fxHi = -99999\nlet fyHi = -99999\nlet fzHi = -99999\n\nlet gxLo = 99999\nlet gyLo = 99999\nlet gzLo = 99999\nlet gxHi = -99999\nlet gyHi = -99999\nlet gzHi = -99999\nlet f = new Vector(0,0,0)\nlet g = new Vector(0, 0, 0)\nlet xAbs: number\nlet yAbs: number\nlet zAbs: number\nlet px = 0\nlet py = 0\nwhile (count < 25) {\n    f.x = input.magneticForce(0)\n    f.y = input.magneticForce(1)\n    f.z = input.magneticForce(2)\n    g.x = input.acceleration(0)\n    g.y = input.acceleration(1)\n    g.z = input.acceleration(2)\n    zAbs = Math.abs(g.z)\n    xAbs = Math.abs(g.x)\n    yAbs = Math.abs(g.y)\n\n    // set LED pixels(px,py) based on tilt angle zones. \n\n    // face-down from left/front:    gx/gy near 0; gz +1000\n    if (g.z > 5 * (-g.x)) px = 0\n    if (g.z > 5 * (-g.y)) py = 0\n    // facing left/front             gx/gy -1000; gz near 0\n    if ((-g.x) > 5 * zAbs) px = 1\n    if ((-g.y) > 5 * zAbs) py = 1\n    // face-up\n    if ((-g.z) > 5 * xAbs) px = 2\n    if ((-g.z) > 5 * yAbs) py = 2\n    // facing right/back\n    if (g.x > 5 * zAbs) px = 3\n    if (g.y > 5 * zAbs) py = 3\n    // face-down from right/back\n    if (g.z > 5 * g.x) px = 4\n    if (g.z > 5 * g.y) py = 4\n\n    datalogger.log(\n        datalogger.createCV(\"g.x\", g.x), \n        datalogger.createCV(\"g.y\", g.y), \n        datalogger.createCV(\"g.z\", g.z),\n        datalogger.createCV(\"px\", px), \n        datalogger.createCV(\"py\", py))\n    meter.show(px*10 + py)\n    pause(1000)\n\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        // led.plot(px, py)\n\n        \n        count++\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n        /* not much point ranging gravity: distorted by inertial movement!\n        if (g.x < gxLo) gxLo = Math.max(g.x, 0)\n        if (g.y < gyLo) gyLo = Math.max(g.y, 0)\n        if (g.z < gzLo) gzLo = Math.max(g.z, 0)\n        if (g.x > gxHi) gxHi = Math.min(g.x, 1000)\n        if (g.y > gyHi) gyHi = Math.min(g.y, 1000)\n        if (g.z > gzHi) gzHi = Math.min(g.z, 1000)\n        */\n    }\n}\nbasic.showIcon(IconNames.Happy)\n\nlet fxOff = (fxHi + fxLo) / 2\nlet fyOff = (fyHi + fyLo) / 2\nlet fzOff = (fzHi + fzLo) / 2\nlet fxMag = (fxHi - fxLo) / 2\nlet fyMag = (fyHi - fyLo) / 2\nlet fzMag = (fzHi - fzLo) / 2\n\nlet fxScale = 1000 / fxMag\nlet fyScale = 1000 / fyMag\nlet fzScale = 1000 / fzMag\n\nlet gxOff = (gxHi + gxLo) / 2\nlet gyOff = (gyHi + gyLo) / 2\nlet gzOff = (gzHi + gzLo) / 2\nlet gxMag = (gxHi - gxLo) / 2\nlet gyMag = (gyHi - gyLo) / 2\nlet gzMag = (gzHi - gzLo) / 2\n\nlet gxScale = 1000 / gxMag\nlet gyScale = 1000 / gyMag\nlet gzScale = 1000 / gzMag\n\ndatalogger.log( datalogger.createCV(\"fxOff\", fxOff),\n                datalogger.createCV(\"fyOff\", fyOff),\n                datalogger.createCV(\"fzOff\", fzOff),\n                datalogger.createCV(\"gxOff\", gxOff),\n                datalogger.createCV(\"gyOff\", gyOff),\n                datalogger.createCV(\"gzOff\", gzOff))\n\n\ndatalogger.log( datalogger.createCV(\"fxScale\", fxScale),\n                datalogger.createCV(\"fyScale\", fyScale),\n                datalogger.createCV(\"fzScale\", fzScale),\n                datalogger.createCV(\"gxScale\", gxScale),\n                datalogger.createCV(\"gyScale\", gyScale),\n                datalogger.createCV(\"gzScale\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG: Quaternion\n\nfunction correctedField(): Vector {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    f.x *= fxScale\n    f.y *= fyScale\n    f.z *= fzScale\n    return f\n}\n\nfunction correctedGravity(): Vector {\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    // g.x *= gxScale\n    // g.y *= gyScale\n    // g.z *= gzScale\n    return g\n}\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1724837202310,"editorVersion":"7.0.25","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n   */\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n * A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n* XYZ: the microbit's Sensor-Frame\n* RFD: the buggy's Body-Frame (Right, Front, Down)\n* ENG: the World - Frame in which it is navigating(East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt((this.w * this.w)\n            + (this.i * this.i)\n            + (this.j * this.j)\n            + (this.k * this.k))\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n\n    }\n}\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity()\n    field.x -= fxOff\n    field.y -= fyOff\n    field.z -= fzOff\n    gravity.x -= gxOff\n    gravity.y -= gyOff\n    gravity.z -= gzOff\n    let dot = field.dottedWith(gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log( datalogger.createCV(\"fx\", field.x),\n                    datalogger.createCV(\"fy\", field.y),\n                    datalogger.createCV(\"fz\", field.z),\n                    datalogger.createCV(\"gx\", gravity.x),\n                    datalogger.createCV(\"gy\", gravity.y),\n                    datalogger.createCV(\"gz\", gravity.z),\n                    datalogger.createCV(\"dot\", dot),\n                    datalogger.createCV(\"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n                    datalogger.createCV(\"crossz\", cross.z))\n\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n})\n\n\n\n// REMEMBER: chip is on the underside, ;\n// X is +1000 when facing left; Y is +1000 when facing front;so Z is +1000 when microbit is face-down\n\nlet lit = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\nlet count = 0\nlet fxLo = 99999\nlet fyLo = 99999\nlet fzLo = 99999\nlet fxHi = -99999\nlet fyHi = -99999\nlet fzHi = -99999\n\nlet gxLo = 99999\nlet gyLo = 99999\nlet gzLo = 99999\nlet gxHi = -99999\nlet gyHi = -99999\nlet gzHi = -99999\nlet f = new Vector(0,0,0)\nlet g = new Vector(0, 0, 0)\nlet zAbs: number\nlet px = 0\nlet py = 0\nwhile (count < 25) {\n    f.x = input.magneticForce(0)\n    f.y = input.magneticForce(1)\n    f.z = input.magneticForce(2)\n    g.x = input.acceleration(0)\n    g.y = input.acceleration(1)\n    g.z = input.acceleration(2)\n    zAbs = Math.abs(g.z)\n\n    // set LED pixels(px,py) based on tilt angle zones. \n\n    // face-down from left:                 gx just above 0; gz +1000\n    if ((g.z > 10 * g.x) && (g.x > 0)) px = 0\n    // facing right:                        gx +1000; gz near 0\n    if (g.x > 10 * zAbs) px = 3\n    // face-up:                             gx near 0; gz -1000\n    if ((-g.z) > 10 * Math.abs(g.x)) px = 2\n    // facing left:                         gx -1000; gz near 0\n    if ((-g.x) > 10 * zAbs) px = 1\n    // face-down from right:                gx just below 0; gz +1000\n    if ((g.z > 10 * (-g.x)) && (g.x < 0)) px = 4\n\n    // face-down from front:                gy just above 0; gz +1000\n    if ((g.z > 10 * g.y) && (g.y > 0)) py = 0\n    // facing back:                         gy +1000; gz near 0\n    if (g.y > 10 * zAbs) py = 1\n    // face-up:                             gy near 0; gz -1000\n    if ((-g.z) > 10 * Math.abs(g.y)) py = 2\n    // facing front:                        gy -1000; gz near 0\n    if ((-g.y) > 10 * zAbs) py = 3\n    // face-down from back:                 gy just below 0; gz +1000\n    if ((g.z > 10 * (-g.y)) && (g.y < 0)) py = 4\n\n\n    datalogger.log(\n        datalogger.createCV(\"g.x\", g.x), \n        datalogger.createCV(\"g.y\", g.y), \n        datalogger.createCV(\"g.z\", g.z),\n        datalogger.createCV(\"px\", px), \n        datalogger.createCV(\"py\", py))\n    meter.show(px*10 + py)\n    pause(1000)\n\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        // led.plot(px, py)\n\n        \n        count++\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n        /* not much point ranging gravity: distorted by inertial movement!\n        if (g.x < gxLo) gxLo = Math.max(g.x, 0)\n        if (g.y < gyLo) gyLo = Math.max(g.y, 0)\n        if (g.z < gzLo) gzLo = Math.max(g.z, 0)\n        if (g.x > gxHi) gxHi = Math.min(g.x, 1000)\n        if (g.y > gyHi) gyHi = Math.min(g.y, 1000)\n        if (g.z > gzHi) gzHi = Math.min(g.z, 1000)\n        */\n    }\n}\nbasic.showIcon(IconNames.Happy)\n\nlet fxOff = (fxHi + fxLo) / 2\nlet fyOff = (fyHi + fyLo) / 2\nlet fzOff = (fzHi + fzLo) / 2\nlet fxMag = (fxHi - fxLo) / 2\nlet fyMag = (fyHi - fyLo) / 2\nlet fzMag = (fzHi - fzLo) / 2\n\nlet fxScale = 1000 / fxMag\nlet fyScale = 1000 / fyMag\nlet fzScale = 1000 / fzMag\n\nlet gxOff = (gxHi + gxLo) / 2\nlet gyOff = (gyHi + gyLo) / 2\nlet gzOff = (gzHi + gzLo) / 2\nlet gxMag = (gxHi - gxLo) / 2\nlet gyMag = (gyHi - gyLo) / 2\nlet gzMag = (gzHi - gzLo) / 2\n\nlet gxScale = 1000 / gxMag\nlet gyScale = 1000 / gyMag\nlet gzScale = 1000 / gzMag\n\ndatalogger.log( datalogger.createCV(\"fxOff\", fxOff),\n                datalogger.createCV(\"fyOff\", fyOff),\n                datalogger.createCV(\"fzOff\", fzOff),\n                datalogger.createCV(\"gxOff\", gxOff),\n                datalogger.createCV(\"gyOff\", gyOff),\n                datalogger.createCV(\"gzOff\", gzOff))\n\n\ndatalogger.log( datalogger.createCV(\"fxScale\", fxScale),\n                datalogger.createCV(\"fyScale\", fyScale),\n                datalogger.createCV(\"fzScale\", fzScale),\n                datalogger.createCV(\"gxScale\", gxScale),\n                datalogger.createCV(\"gyScale\", gyScale),\n                datalogger.createCV(\"gzScale\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG: Quaternion\n\nfunction correctedField(): Vector {\n    let f = new Vector(input.magneticForce(0), input.magneticForce(1), input.magneticForce(2))\n    f.x *= fxScale\n    f.y *= fyScale\n    f.z *= fzScale\n    return f\n}\n\nfunction correctedGravity(): Vector {\n    let g = new Vector(input.acceleration(0), input.acceleration(1), input.acceleration(2))\n    // g.x *= gxScale\n    // g.y *= gyScale\n    // g.z *= gzScale\n    return g\n}\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1724954185053,"editorVersion":"7.0.29","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity()\n    let dot = field.dottedWith(gravity)\n    let cross = field.crossedWith(gravity)\n\n    datalogger.log( datalogger.createCV(\"fx\", field.x),\n                    datalogger.createCV(\"fy\", field.y),\n                    datalogger.createCV(\"fz\", field.z),\n                    datalogger.createCV(\"gx\", gravity.x),\n                    datalogger.createCV(\"gy\", gravity.y),\n                    datalogger.createCV(\"gz\", gravity.z),\n                    datalogger.createCV(\"dot\", dot),\n                    datalogger.createCV(\"crossx\", cross.x),\n                    datalogger.createCV(\"crossy\", cross.y),\n                    datalogger.createCV(\"crossz\", cross.z))\n\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed:\n        // X is -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y is -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z is -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.x > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(4, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let fNew = new Vector(0, 0, 0)\n    if (simulating) {\n        fNew.x = 8.16\n        fNew.y = 7.91\n        fNew.z = 32.72\n    } else {\n        fNew.x = (input.magneticForce(0) - fxOff) * fxScale\n        fNew.y = (input.magneticForce(1) - fyOff) * fyScale\n        fNew.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return fNew\n}\n\nfunction correctedGravity(): Vector {\n    let gNew = new Vector(0, 0, 0)\n    if (simulating) {\n        gNew.x = -23.53\n        gNew.y = 30.43\n        gNew.z = -762.48\n    } else {\n        gNew.x = (input.acceleration(0) - gxOff) * gxScale\n        gNew.y = (input.acceleration(1) - gyOff) * gyScale\n        gNew.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return gNew\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        lit[px][py] = 1\n        led.plot(px, py)\n        count++\n    }\n}\n\n\n// ================================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( datalogger.createCV(\"fxOff\", fxOff),\n                datalogger.createCV(\"fyOff\", fyOff),\n                datalogger.createCV(\"fzOff\", fzOff),\n                datalogger.createCV(\"gxOff\", gxOff),\n                datalogger.createCV(\"gyOff\", gyOff),\n                datalogger.createCV(\"gzOff\", gzOff))\n\n\ndatalogger.log( datalogger.createCV(\"fxScale\", fxScale),\n                datalogger.createCV(\"fyScale\", fyScale),\n                datalogger.createCV(\"fzScale\", fzScale),\n                datalogger.createCV(\"gxScale\", gxScale),\n                datalogger.createCV(\"gyScale\", gyScale),\n                datalogger.createCV(\"gzScale\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0,0,1))\nlet from\n// await button-pressing...","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.29\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1725113471868,"editorVersion":"7.0.35","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    let field = correctedField()\n    let gravity = correctedGravity()\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n\n    datalogger.log(\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z),\n        datalogger.createCV(\"ENG.x\", fieldENG.x),\n        datalogger.createCV(\"ENG.y\", fieldENG.y),\n        datalogger.createCV(\"ENG.z\", fieldENG.z),\n        datalogger.createCV(\"heading\", heading))\n\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed:\n        // X is -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y is -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z is -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let fNew = new Vector(0, 0, 0)\n    if (simulating) {\n        fNew.x = 8.16\n        fNew.y = 7.91\n        fNew.z = 32.72\n    } else {\n        fNew.x = (input.magneticForce(0) - fxOff) * fxScale\n        fNew.y = (input.magneticForce(1) - fyOff) * fyScale\n        fNew.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return fNew\n}\n\nfunction correctedGravity(): Vector {\n    let gNew = new Vector(0, 0, 0)\n    if (simulating) {\n        gNew.x = -23.53\n        gNew.y = 30.43\n        gNew.z = -762.48\n    } else {\n        gNew.x = (input.acceleration(0) - gxOff) * gxScale\n        gNew.y = (input.acceleration(1) - gyOff) * gyScale\n        gNew.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return gNew\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n}\n\n\n// ================================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( datalogger.createCV(\"fxOff\", fxOff),\n                datalogger.createCV(\"fyOff\", fyOff),\n                datalogger.createCV(\"fzOff\", fzOff),\n                datalogger.createCV(\"gxOff\", gxOff),\n                datalogger.createCV(\"gyOff\", gyOff),\n                datalogger.createCV(\"gzOff\", gzOff))\n\n\ndatalogger.log( datalogger.createCV(\"fxScale\", fxScale),\n                datalogger.createCV(\"fyScale\", fyScale),\n                datalogger.createCV(\"fzScale\", fzScale),\n                datalogger.createCV(\"gxScale\", gxScale),\n                datalogger.createCV(\"gyScale\", gyScale),\n                datalogger.createCV(\"gzScale\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0,0,1))\nlet fieldENG: Vector\nlet heading: number\n// await button-pressing...","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.29\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1726729570348,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed:\n        // X is -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y is -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z is -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n}\n\n\n// ================================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing...","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.35\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1726812560138,"editorVersion":"7.0.45","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"let simulating = isSimulating() // for debugging\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n// calibration map\nlet lit: number[][]\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\n   class Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n/**\n* A Quaternion is used here as tool for manipulating rotations between the\n* three 3D frames of reference we are using:\n*\n*       XYZ: the microbit Sensor-Frame\n*\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log( datalogger.createCV(\"w\", this.w),\n                        datalogger.createCV(\"i\", this.i),\n                        datalogger.createCV(\"j\", this.j),\n                        datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x \n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y \n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z \n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// set NorthXYZ, and thence compute fromXYZtoENG\ninput.onButtonPressed(Button.A, function() {\n    northXYZ = correctedField()\n    downXYZ = correctedGravity() \n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0,0,1000))\n    \n})\n\n// test dot-products and cross-products between field and gravity\ninput.onButtonPressed(Button.B, function() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n})\n\ninput.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    let count = 0\n})\n\n// sample field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n}\n\n\n// ================================\nlet count = 0\n// set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log( \n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing...","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.35\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727450681847,"editorVersion":"7.0.42","text":{"pxt.json":"{\n    \"name\": \"this\",\n    \"description\": \"invalid pxt.json file\",\n    \"dependencies\": {\n        \"microphone\": \"*\"\n    },\n    \"files\": [],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727544890500,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst TooManySamples = 500\nlet simulating = isSimulating() // for debugging\nlet scanTimes: number[] = []\nlet scanData: number[][] = []\n\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n\n// calibration map\nlet lit: number[][]\n\n// ================ CLASSES ================\n\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    scanData = []\n    scanTimes = []\n    basic.showString(\"S\")\n    pause(1000)\n    basic.clearScreen()\n    collectSamples(6000)\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.B, function() {\n    basic.showString(\"D\")\n    pause(1000)\n    basic.clearScreen()\n    dumpScan()\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n})\n\n// ============== FUNCTIONS ===============\n\n// sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let fresh: number[] = [] //\n    let updated: number[] = []\n\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    fresh = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z),\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let smoothedSample = new Smoother(timeStamp, Window, SampleGap, fresh)\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * SampleGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        fresh = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z),\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z)]\n        updated = smoothedSample.update(timeStamp, fresh)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the sextet of averaged sensor values (as a deep copy!)\n            scanData.push([updated[0], updated[1], updated[2], updated[3], updated[4], updated[5]])\n            scanTimes.push(timeStamp)  // timestamp it              \n        }\n    }\n}\n\n\nfunction correct() {\n    // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction process() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\nfunction dumpScan() {\n    for (let i = 0; i < scanTimes.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", scanData[i][0]),\n            datalogger.createCV(\"fy\", scanData[i][1]),\n            datalogger.createCV(\"fz\", scanData[i][2]),\n            datalogger.createCV(\"gx\", scanData[i][3]),\n            datalogger.createCV(\"gy\", scanData[i][4]),\n            datalogger.createCV(\"gz\", scanData[i][5])\n        )\n    }\n}\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727629530674,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst TooManySamples = 500\nlet simulating = isSimulating() // for debugging\n//let scanTimes: number[] = []\n//let scanData: number[][] = []\nlet scan: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\nlet nSamples: number\n\n\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field scaling factors\nlet fxScale: number\nlet fyScale: number\nlet fzScale: number\n\n// gravity offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity scale factors\nlet gxScale: number\nlet gyScale: number\nlet gzScale: number\n\n// calibration map\nlet lit: number[][]\n\n// ================ CLASSES ================\n\n\n/*   A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n     It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n     Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n     The expected gap between readings (averagePeriod) governs the blend of new and old readings \n     and therefore the overall latency associated with the exponential averaging process.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    scan = []\n    basic.showString(\"S\")\n    pause(1000)\n    basic.clearScreen()\n    collectSamples(6000)\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.B, function() {\n    basic.showString(\"D\")\n    pause(1000)\n    basic.clearScreen()\n    dumpScan()\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n})\n\n// ============== FUNCTIONS ===============\n\n// sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let updated: number[] = []\n    let newSample: Sample // Sampled magnetic field and pose\n    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n    let pose: Number[] = [\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z)]\n        \n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    field  =,\n        input.acceleration(Dimension.X),\n        input.acceleration(Dimension.Y),\n        input.acceleration(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n    let poseSmoother = new Smoother(timeStamp, Window, SampleGap, pose)\n\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * SampleGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scanTimes.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        smoothField = fieldSmoother.update(timeNow, field)\n\n        pose: Number[] = [\n            input.acceleration(Dimension.X),\n            input.acceleration(Dimension.Y),\n            input.acceleration(Dimension.Z)]\n        smoothPose = poseSmoother.update(timeNow,pose)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the sextet of averaged sensor values (as a deep copy!)\n            //scanData.push([updated[0], updated[1], updated[2], updated[3], updated[4], updated[5]])\n            //scanTimes.push(timeStamp)  // timestamp it   ]\n            newSample.time = timeNow\n            newSample.field = []\n            scan.push(newSample)           \n        }\n\n    }\n}\n\n\nfunction correct() {\n    // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    fromXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction process() {\n    field = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", field.x),\n        datalogger.createCV(\"fy\", field.y),\n        datalogger.createCV(\"fz\", field.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = fromXYZtoENG.appliedToVector(field)\n    gravityENG = fromXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\nfunction dumpScan() {\n    for (let i = 0; i < scanTimes.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", scanData[i][0]),\n            datalogger.createCV(\"fy\", scanData[i][1]),\n            datalogger.createCV(\"fz\", scanData[i][2]),\n            datalogger.createCV(\"gx\", scanData[i][3]),\n            datalogger.createCV(\"gy\", scanData[i][4]),\n            datalogger.createCV(\"gz\", scanData[i][5])\n        )\n    }\n}\n\n\n/** Function to analyse the scan-readings and derive the magnetometer scaling factors\n     * and the scan spin-axis in the XYZ sensor frame.\n     * \n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first \n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings and so derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     * \n     * NOTE: There is no guarantee that the spin-axis is truly vertical: the buggy may be operating \n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish their relationship, we need to call SetNorth() with the buggy at rest,\n    */\nfunction analyseScan() {\n    /* given the set of six [X,Y,Z] measurements:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n\n    ...and knowing that: \n            X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n    \n    ...we can (after some maths!) derive the calibration factors:\n            yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n            zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n    */\n\n    // First, collect the plane-crossings in each direction. \n    // Simultaneously, collect half-periods of rotation, which we will average.\n    let nCrossXY = 0\n    let nCrossYZ = 0\n    let nCrossZX = 0\n    let xStart = -1\n    let yStart = -1\n    let zStart = -1\n    let xFinish = 0\n    let yFinish = 0\n    let zFinish = 0\n    let x = scan[0].field.x\n    let y = scan[0].field.y\n    let z = scan[0].field.z\n    let xWas: number\n    let yWas: number\n    let zWas: number\n    // flags to inhibit clocking multiple jittery crossings \n    let needXY = true\n    let needYZ = true\n    let needZX = true\n    // we mostly use the squares of the zero-crossing components\n    let MM = 0\n    let NN = 0\n    let PP = 0\n    let QQ = 0\n    let RR = 0\n    let SS = 0\n    for (let i = 0; i < nSamples; i++) {\n        xWas = x\n        yWas = y\n        zWas = z\n        x = scan[i].field.x\n        y = scan[i].field.y\n        z = scan[i].field.z\n\n        // avoid any exact zeroes (they complicate comparisons!)\n        if (x == 0) x = xWas\n        if (y == 0) y = yWas\n        if (z == 0) z = zWas\n\n        // look for the first transition of each half-cycle\n        // (jitter or near-axis alignment may cause fluctuations)\n        if ((z * zWas < 0) && needXY) {\n            MM += x ** 2\n            NN += y ** 2\n            nCrossXY++\n            zFinish = scan[i].time\n            if (zStart < 0) zStart = zFinish\n            needXY = false\n            // got this axis-crossing, so now allow others\n            needYZ = true\n            needZX = true\n        }\n        if ((x * xWas < 0) && needYZ) {\n            PP += y ** 2\n            QQ += z ** 2\n            nCrossYZ++\n            xFinish = scan[i].time\n            if (xStart < 0) xStart = xFinish\n            needYZ = false\n            needXY = true\n            needZX = true\n        }\n        if ((y * yWas < 0) && needZX) {\n            RR += x ** 2\n            SS += z ** 2\n            nCrossZX++\n            yFinish = scan[i].time\n            if (yStart < 0) yStart = yFinish\n            needZX = false\n            needXY = true\n            needYZ = true\n        }\n    }\n    // average the crossing vectors\n    MM /= nCrossXY\n    NN /= nCrossXY\n    PP /= nCrossYZ\n    QQ /= nCrossYZ\n    RR /= nCrossZX\n    SS /= nCrossZX\n    // derive the average \"flip\" times (each making half a rotation)\n    let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n    let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n    let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n    // average and double them to get best period measure\n    scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n    // assemble the relative scaling factors\n    let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n    yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n    zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n    /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n    */\n    let M = Math.sqrt(MM)\n    let N = Math.sqrt(NN) * yScale\n    let P = Math.sqrt(PP) * yScale\n    let Q = Math.sqrt(QQ) * zScale\n    let R = Math.sqrt(RR)\n    let S = Math.sqrt(MM) * zScale\n\n    // since the crossings form a co-planar triangle in the Spin-Circle, we can take the \n    // cross-product of two edges to derive the orthogonal rotation-axis\n    let I = (Q * N) - (N * S) + (S * P)\n    let J = (R * Q) - (Q * M) + (M * S)\n    let K = (N * R) - (R * P) + (P * M)\n\n    down = new Vector(I, J, K)\n    down = down.normalised()\n\n    let check = 0 // debug point...\n}\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\nlet northXYZ: Vector\nlet downXYZ: Vector\nlet fromXYZtoENG = new Quaternion(0, new Vector(0, 0, 1))\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"pxt-meter\": \"github:grandpabond/pxt-meter#v0.1.20\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727708201331,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\n\n\nlet simulating = isSimulating() // for debugging\n//let scanTimes: number[] = []\n//let scanData: number[][] = []\nlet scan: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\nlet nSamples: number\n\n\nlet strength = 0 // the average magnetic field-strength observed by the magnetometer\nlet scanPeriod = -1 // average scanning rotation time\n\n// amplitudes and central offsets of sinusoidal scan-readings in each dimension\nlet swing: Vector\nlet offset: Vector\nlet xOff: number\nlet yOff: number\nlet zOff: number\n// sensitivity adjustment factors that will match Y & Z readings to X readings\nlet yScale: number\nlet zScale: number\n\n// Sensor Measurements\nlet downXYZ: Vector // buggy's Down axis (fixed, dependent on mounting)\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // starting orientation of the buggy\n//let northXYZ: Vector // starting field of the buggy\nlet northXYZ: Vector\nlet startXYZ: Reading // starting field and pose of the buggy (deemed north and upright)\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet field: Vector\nlet gravity: Vector\nlet fieldENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field re-scaling factors\nlet fyScale: number // = fyMag / fxMag\nlet fzScale: number // = fzMag / fxMag\n\n// gravity (or pose) sensor offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity re-scaling factors\nlet gyScale: number // = gyMag / gxMag\nlet gzScale: number // = gzMag / gxMag\n\n// calibration map\nlet lit: number[][]\n\n// ================ CLASSES ================\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    scan = []\n    basic.showString(\"S\")\n    pause(1000)\n    basic.clearScreen()\n    let result = scanClockwise(6000)\n    if (result != 0) {\n        basic.showNumber(result)\n    } else {\n        basic.showIcon(IconNames.Yes)\n    }\n    pause(1000)\n\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.B, function() {\n    basic.showString(\"D\")\n    pause(1000)\n    basic.clearScreen()\n    dumpScan()\n    basic.showIcon(IconNames.Yes)\n    pause(1000)\n    basic.clearScreen()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n})\n\n// ============== FUNCTIONS ===============\n\n/* sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n*/\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff) * fxScale\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff) * gxScale\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\nfunction show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} \n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let newSample: Sample // Sampled magnetic field\n\n    scan = [] // start with empty arrays\n    basic.pause(200) // wait for motors to stabilise (after initial kick-start)\n    // get initial reading\n    let timeStamp = input.runningTime()\n    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n    let smooth: number[]\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * SampleGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (scan.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        field = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        smooth = fieldSmoother.update(timeNow, field)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the averaged field values (as a deep copy!)\n            newSample.field = new Vector(smooth[0], smooth[1], smooth[2])\n            newSample.time = timeNow  // timestamp it  \n            scan.push(newSample)           \n        }\n    }\n}\n\n\nfunction scanClockwise(ms: number): number {\n    strength = -1\n    scanPeriod = -1\n\n    // unless data has already been pre-loaded into scan[]...\n    // if (!debugMode) \n    collectSamples(ms)  // ...take repeated magnetometer readings\n\n    nSamples = scan.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanTime = scan[nSamples - 1].time = scan[0].time\n    if ((nSamples < EnoughSamples) || (scanTime < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // The first pass finds the ranges for each axis \n    let xlo = 9999999\n    let ylo = 9999999\n    let zlo = 9999999\n    let xhi = -9999999\n    let yhi = -9999999\n    let zhi = -9999999\n    for (let i = 0; i < nSamples; i++) {\n        xhi = Math.max(xhi, scan[i].field.x)\n        yhi = Math.max(yhi, scan[i].field.x)\n        zhi = Math.max(zhi, scan[i].field.y)\n        xlo = Math.min(xlo, scan[i].field.y)\n        ylo = Math.min(ylo, scan[i].field.z)\n        zlo = Math.min(zlo, scan[i].field.z)\n    }\n\n    // get RMS field-strength\n    swing.x = (xhi - xlo) / 2\n    swing.y = (yhi - ylo) / 2\n    swing.z = (zhi - zlo) / 2\n    strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n    // Bail out early if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n    // The means of the extremes give a good approximation to the central offsets.\n    xOff = (xhi + xlo) / 2\n    yOff = (yhi + ylo) / 2\n    zOff = (zhi + zlo) / 2\n\n    // 2nd pass re-centres all the scanData samples, eliminating \"hard-iron\" environmental magnetic effects.\n    for (let i = 0; i < nSamples; i++) {\n        scan[i].field.x -= xOff\n        scan[i].field.y -= yOff\n        scan[i].field.z -= zOff\n    }\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < nSamples; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n    */\n\n    return 0\n}\n\n\n\n\nfunction correct() {\n    // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction process() {\n    magnetXYZ = correctedField()\n    gravity = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravity.x),\n        datalogger.createCV(\"gy\", gravity.y),\n        datalogger.createCV(\"gz\", gravity.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    fieldENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravity)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", fieldENG.x),\n        datalogger.createCV(\"fy\", fieldENG.y),\n        datalogger.createCV(\"fz\", fieldENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(fieldENG.y, fieldENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\n\n\nfunction dumpScan() {\n    for (let i = 0; i < scan.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", scan[i].field.x),\n            datalogger.createCV(\"fy\", scan[i].field.x),\n            datalogger.createCV(\"fz\", scan[i].field.x))\n    }\n}\n\n\n\n/** Function to analyse the scan-readings and derive the magnetometer scaling factors\n     * and the scan spin-axis in the XYZ sensor frame.\n     * \n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first \n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings and so derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     * \n     * NOTE: There is no guarantee that the spin-axis is truly vertical: the buggy may be operating \n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish their relationship, we need to call SetNorth() with the buggy at rest,\n    */\nfunction analyseScan() {\n    /* given the set of six [X,Y,Z] measurements:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n\n    ...and knowing that: \n            X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n    \n    ...we can (after some maths!) derive the calibration factors:\n            yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n            zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n    */\n\n    // First, collect the plane-crossings in each direction. \n    // Simultaneously, collect half-periods of rotation, which we will average.\n    // counts of zero-crossings detected in this scan\n    let nCrossXY = 0\n    let nCrossYZ = 0\n    let nCrossZX = 0\n    // time-stamp of first\n    let xStart = -1\n    let yStart = -1\n    let zStart = -1\n    let xFinish = 0\n    let yFinish = 0\n    let zFinish = 0\n    let x = scan[0].field.x\n    let y = scan[0].field.y\n    let z = scan[0].field.z\n    let xWas: number\n    let yWas: number\n    let zWas: number\n    // flags to inhibit clocking multiple jittery crossings \n    let needXY = true\n    let needYZ = true\n    let needZX = true\n    // we'll mostly use the squares of the zero-crossing components\n    let MM = 0\n    let NN = 0\n    let PP = 0\n    let QQ = 0\n    let RR = 0\n    let SS = 0\n    for (let i = 0; i < nSamples; i++) {\n        xWas = x\n        yWas = y\n        zWas = z\n        x = scan[i].field.x\n        y = scan[i].field.y\n        z = scan[i].field.z\n\n        // avoid any exact zeroes (they complicate comparisons!)\n        if (x == 0) x = xWas\n        if (y == 0) y = yWas\n        if (z == 0) z = zWas\n\n        // Look for the first transition of each half-cycle (i.e. where the sign flips)\n        // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n        if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n            MM += x ** 2\n            NN += y ** 2\n            nCrossXY++\n            zFinish = scan[i].time\n            if (zStart < 0) zStart = zFinish // start the clock...\n            needXY = false\n            // got this axis-crossing, so now only allow others to be detected\n            needYZ = true\n            needZX = true\n        }\n        if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n            PP += y ** 2\n            QQ += z ** 2\n            nCrossYZ++\n            xFinish = scan[i].time\n            if (xStart < 0) xStart = xFinish\n            needYZ = false\n            needXY = true\n            needZX = true\n        }\n        if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n            RR += x ** 2\n            SS += z ** 2\n            nCrossZX++\n            yFinish = scan[i].time\n            if (yStart < 0) yStart = yFinish\n            needZX = false\n            needXY = true\n            needYZ = true\n        }\n    }\n    // average the squared crossing points\n    MM /= nCrossXY\n    NN /= nCrossXY\n\n    PP /= nCrossYZ\n    QQ /= nCrossYZ\n\n    RR /= nCrossZX\n    SS /= nCrossZX\n\n    // derive the average \"flip\" times (each making half a rotation)\n    let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n    let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n    let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n    // average the three half-periods, then double them to get our best measure for full period\n    scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n    // construct the relative scaling factors\n    let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n    yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n    zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n    /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n    */\n\n    let M = Math.sqrt(MM)\n    let N = Math.sqrt(NN) * yScale\n    let P = Math.sqrt(PP) * yScale\n    let Q = Math.sqrt(QQ) * zScale\n    let R = Math.sqrt(RR)\n    let S = Math.sqrt(MM) * zScale\n\n    // since the three crossing-points form a co-planar triangle lying in the Spin-Circle, we can take the \n    // cross-product of any two edges to derive the orthogonal rotation-axis\n    let I = (Q * N) - (N * S) + (S * P)\n    let J = (R * Q) - (Q * M) + (M * S)\n    let K = (N * R) - (R * P) + (P * M)\n\n    downXYZ = new Vector(I, J, K)\n    downXYZ = downXYZ.normalised()\n\n    let check = 0 // debug point...\n}\n\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    if (myName == \"zapop\"){\n        gxMag = 1042.89\n        gyMag = 1007.23\n        gzMag =  992.73\n        gxOff = -70.92\n        gyOff = 44.597\n        gzOff = 6.804      \n    }\n    if (myName == \"gateg\") {\n        gxMag = 1017.578\n        gyMag = 996.736\n        gzMag = 1026.315\n        gxOff = -25.411\n        gyOff = -3.251\n        gzOff = -1.300\n    }\n    if (myName == \"gigav\") {\n        gxMag = 1057.89\n        gyMag = 1023.98\n        gzMag = 1074.06\n        gxOff = -85.33\n        gyOff = 7.22\n        gzOff = -18.94\n    }\n    if (myName == \"zavov\") {\n        gxMag = 1049.285\n        gyMag = 1059.746\n        gzMag = 986.272\n        gxOff = -74.082\n        gyOff = 8.455\n        gzOff = -7.617\n    }\n\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727803711875,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\n\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // for debugging\n\nlet test: Reading[] = [] // array of test readings\n\nlet strength = 0 // the a\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field re-scaling factors\nlet fyScale: number // = fyMag / fxMag\nlet fzScale: number // = fzMag / fxMag\n\n// gravity (or pose) sensor offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity re-scaling factors\nlet gyScale: number // = gyMag / gxMag\nlet gzScale: number // = gzMag / gxMag\n\n// calibration map\nlet lit: number[][]\n\nlet ready = false // ready for action!\n\n// ================ CLASSES ================\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are aligned, or ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n// a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}\n\n\nclass Scan {\n    samples: Sample[] // sequence of time-stamped magnetometer & accelerometer readings\n    nSamples: number\n    swing: Vector   // amplitudes  in each dimension\n    offset: Vector  // central offsets from origin in each dimension\n\n\n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.TakeBearing\n})\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            samples = []\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                result = scanClockwise(6000)\n                basic.showString(\"D\") // dump the smoothed raw scan data\n                dumpScanData()\n            }\n\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                // analyse and re-centre the data\n                basic.showString(\"A\")\n                analyseScan()\n                if (!simulating) {\n                }\n                // apply scaling corrections to scan data?\n                basic.showString(\"C\") // correct\n                recentreScan()\n                pause(1000)\n\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            setNorth()\n            pause(1000)\n            basic.clearScreen()\n            ready = true\n            break\n\n        case Tasks.TakeBearing:\n            heading = takeBearing()\n            basic.showNumber(heading)\n            break\n\n    }\n}\n\n/* sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n*/\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff)\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* function show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} */\n\nfunction collectSamples(ms: number) {\n    let timeWas: number\n    let timeNow: number\n    let newSample: Sample // Sampled magnetic field\n\n    samples = [] // start with empty arrays\n    // get initial reading\n    let timeStamp = input.runningTime()\n    let field: number[] = [\n        input.magneticForce(Dimension.X),\n        input.magneticForce(Dimension.Y),\n        input.magneticForce(Dimension.Z)]\n\n    // use a Smoother to maintain a rolling average\n    let fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n    let smooth: number[]\n\n    // after an initial settling period, continue cranking out updated moving averages... \n    let startTime = timeStamp + (Window * SampleGap) \n    let stopTime = timeStamp + ms\n\n    // ...until we run out of time (or space!)\n    while ((timeStamp < stopTime)\n        && (samples.length < TooManySamples)) {\n        // After processing, sleep until it's time for next sample.\n        // NOTE: here is where various system subprograms will get scheduled.\n        // If they need more time than we've offered, our next sample will get delayed!\n        // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n        timeWas = timeStamp // remember time of latest sample\n        timeNow = input.runningTime()\n        basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n        timeStamp = input.runningTime() // take a fresh set of readings\n\n        field = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n        smooth = fieldSmoother.update(timeNow, field)\n\n        // only start recording once the moving average has stabilised\n        if (timeStamp > startTime) {\n            // store the averaged field values (as a deep copy!)\n            newSample.field = new Vector(smooth[0], smooth[1], smooth[2])\n            newSample.time = timeNow  // timestamp it  \n            samples.push(newSample)           \n        }\n    }\n}\n\n\nfunction scanClockwise(ms: number): number {\n    strength = -1\n    scanPeriod = -1\n\n    // unless data has already been pre-loaded into scan[]...\n    // if (!debugMode) \n    collectSamples(ms)  // ...take repeated magnetometer readings\n\n    nSamples = samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = samples[nSamples - 1].time = samples[0].time\n    if ((nSamples < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    strength = scopeScan()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n   \n}\n\n\nfunction scopeScan() {\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // The first pass finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    let xlo = 9999999\n    let ylo = 9999999\n    let zlo = 9999999\n    let xhi = -9999999\n    let yhi = -9999999\n    let zhi = -9999999\n    for (let i = 0; i < nSamples; i++) {\n        xhi = Math.max(xhi, samples[i].field.x)\n        yhi = Math.max(yhi, samples[i].field.x)\n        zhi = Math.max(zhi, samples[i].field.y)\n        xlo = Math.min(xlo, samples[i].field.y)\n        ylo = Math.min(ylo, samples[i].field.z)\n        zlo = Math.min(zlo, samples[i].field.z)\n    }\n\n    // derive RMS field-strength from the ranges detected in each axis\n    swing.x = (xhi - xlo) / 2\n    swing.y = (yhi - ylo) / 2\n    swing.z = (zhi - zlo) / 2\n    strength = Math.sqrt((swing.x * swing.x) + (swing.y * swing.y) + (swing.z * swing.x))\n\n    // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n    offset.x = (xhi + xlo) / 2\n    offset.y = (yhi + ylo) / 2\n    offset.z = (zhi + zlo) / 2\n}\n\nfunction recentreScan() {\n    // first re-centre all the scanData samples, eliminating \"hard-iron\" environmental magnetic effects.\n    for (let i = 0; i < nSamples; i++) {\n        samples[i].field.x -= offset.x\n        samples[i].field.y -= offset.y\n        samples[i].field.z -= offset.z\n    }\n}\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < nSamples; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n    */\n\n    return 0\n}\n\nfunction process() {\n    magnetXYZ = correctedField()\n    gravityXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\n\n\nfunction dumpScanData() {\n    for (let i = 0; i < samples.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"raw scan\"),\n            datalogger.createCV(\"fx\", samples[i].field.x),\n            datalogger.createCV(\"fy\", samples[i].field.y),\n            datalogger.createCV(\"fz\", samples[i].field.z))\n    }\n\n    datalogger.log(\n        datalogger.createCV(\"yScale\", yScale),\n        datalogger.createCV(\"zScale\", zScale),\n        datalogger.createCV(\"downX\", downXYZ.x),\n        datalogger.createCV(\"downY\", downXYZ.y),\n        datalogger.createCV(\"downZ\", downXYZ.z))\n\n}\n\nfunction dumpTestData() {\n    for (let i = 0; i < test.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", test[i].field.x),\n            datalogger.createCV(\"fy\", test[i].field.y),\n            datalogger.createCV(\"fz\", test[i].field.z),\n            datalogger.createCV(\"gx\", test[i].pose.x),\n            datalogger.createCV(\"gy\", test[i].pose.y),\n            datalogger.createCV(\"gz\", test[i].pose.z))\n\n    }\n}\n\n\n/** Function to analyse the scan-readings and derive the magnetometer scaling factors\n     * and the scan spin-axis (measured in the XYZ sensor frame).\n     * \n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first \n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     * \n     * NOTE: There is no guarantee that the spin-axis is truly vertical: the buggy may be operating \n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest,\n    */\nfunction analyseScan() {\n    /* given the set of six [X,Y,Z] measurements:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n\n    ...and knowing that: \n            X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n    \n    ...we can (after some maths!) derive the calibration factors (relative to x):\n            yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n            zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n    */\n\n    // First, collect the plane-crossings in each direction. \n    // Simultaneously, collect half-periods of rotation, which we will average.\n    // counts of zero-crossings detected in this scan\n    let nCrossXY = 0\n    let nCrossYZ = 0\n    let nCrossZX = 0\n    // time-stamp of first\n    let xStart = -1\n    let yStart = -1\n    let zStart = -1\n    let xFinish = 0\n    let yFinish = 0\n    let zFinish = 0\n    let x = samples[0].field.x\n    let y = samples[0].field.y\n    let z = samples[0].field.z\n    let xWas: number\n    let yWas: number\n    let zWas: number\n    // flags to inhibit clocking multiple jittery crossings \n    let needXY = true\n    let needYZ = true\n    let needZX = true\n    // we'll mostly use the squares of the zero-crossing components\n    let MM = 0\n    let NN = 0\n    let PP = 0\n    let QQ = 0\n    let RR = 0\n    let SS = 0\n    for (let i = 0; i < nSamples; i++) {\n        xWas = x\n        yWas = y\n        zWas = z\n        x = samples[i].field.x\n        y = samples[i].field.y\n        z = samples[i].field.z\n\n        // avoid any exact zeroes (they complicate comparisons!)\n        if (x == 0) x = xWas\n        if (y == 0) y = yWas\n        if (z == 0) z = zWas\n\n        // Look for the first transition of each half-cycle (i.e. where the sign flips)\n        // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n        if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n            MM += x ** 2\n            NN += y ** 2\n            nCrossXY++\n            zFinish = samples[i].time\n            if (zStart < 0) zStart = zFinish // start the clock...\n            needXY = false\n            // got this axis-crossing, so now only allow others to be detected\n            needYZ = true\n            needZX = true\n        }\n        if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n            PP += y ** 2\n            QQ += z ** 2\n            nCrossYZ++\n            xFinish = samples[i].time\n            if (xStart < 0) xStart = xFinish\n            needYZ = false\n            needXY = true\n            needZX = true\n        }\n        if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n            RR += x ** 2\n            SS += z ** 2\n            nCrossZX++\n            yFinish = samples[i].time\n            if (yStart < 0) yStart = yFinish\n            needZX = false\n            needXY = true\n            needYZ = true\n        }\n    }\n    // average the squared crossing points\n    MM /= nCrossXY\n    NN /= nCrossXY\n    PP /= nCrossYZ\n    QQ /= nCrossYZ\n    RR /= nCrossZX\n    SS /= nCrossZX\n\n    // derive the average \"flip\" times (each making half a rotation)\n    let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n    let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n    let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n    // average the three half-periods, then double them to get our best measure for full period\n    scanPeriod = (xFlip + yFlip + zFlip) / 1.5\n\n    // construct the relative scaling factors\n    let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n    yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n    zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n    /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n            [M, N, -] when crossing the XY plane\n            [-, P, Q] when crossing the YZ plane\n            [R, -, S] when crossing the ZX plane\n    */\n    let M = Math.sqrt(MM)\n    let N = Math.sqrt(NN) * yScale\n    let P = Math.sqrt(PP) * yScale\n    let Q = Math.sqrt(QQ) * zScale\n    let R = Math.sqrt(RR)\n    let S = Math.sqrt(MM) * zScale\n\n    // since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n    // cross-product of any two edges to derive the orthogonal rotation-axis\n    let I = (Q * N) - (N * S) + (S * P)\n    let J = (R * Q) - (Q * M) + (M * S)\n    let K = (N * R) - (R * P) + (P * M)\n\n    downXYZ = new Vector(I, J, K)\n    downXYZ = downXYZ.normalised()\n\n    let check = 0 // debug point...\n}\n\nfunction setNorth() { // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction takeBearing(): number {\n    // take single reading as magnetXYZ\n    magnetXYZ = new Vector(0,0,0)\n    gravityXYZ = new Vector(0,0,0)\n    for (let i = 0; i < Window; i++) {\n        magnetXYZ.x += input.magneticForce(Dimension.X)\n        magnetXYZ.y += input.magneticForce(Dimension.Y)\n        magnetXYZ.z += input.magneticForce(Dimension.Z)\n        gravityXYZ.x += input.acceleration(Dimension.X)\n        gravityXYZ.y += input.acceleration(Dimension.Y)\n        gravityXYZ.z += input.acceleration(Dimension.Z)\n    }\n    magnetXYZ.x /= Window\n    magnetXYZ.y /= Window\n    magnetXYZ.z /= Window\n    gravityXYZ.x /= Window\n    gravityXYZ.y /= Window\n    gravityXYZ.z /= Window\n    datalogger.log(\n        datalogger.createCV(\"data\", \"raw test\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ\n    \n}\n\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    if (myName == \"zapop\"){\n        gxMag = 1042.89\n        gyMag = 1007.23\n        gzMag =  992.73\n        gxOff = -70.92\n        gyOff = 44.597\n        gzOff = 6.804      \n    }\n    if (myName == \"gateg\") {\n        gxMag = 1017.578\n        gyMag = 996.736\n        gzMag = 1026.315\n        gxOff = -25.411\n        gyOff = -3.251\n        gzOff = -1.300\n    }\n    if (myName == \"gigav\") {\n        gxMag = 1057.89\n        gyMag = 1023.98\n        gzMag = 1074.06\n        gxOff = -85.33\n        gyOff = 7.22\n        gzOff = -18.94\n    }\n    if (myName == \"zavov\") {\n        gxMag = 1049.285\n        gyMag = 1059.746\n        gzMag = 986.272\n        gxOff = -74.082\n        gyOff = 8.455\n        gzOff = -7.617\n    }\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < times.length; i++) {\n        let sample = new Sample(times[i], xData[i], yData[i], zData[i])\n        samples.push(sample)\n    }\n    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n    }\n    return 0\n}\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727860425458,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\n\nlet nextTask: Tasks = Tasks.PerformScan\n\n// let scan: Scan = new Scan()\nlet simulating = isSimulating() // for debugging\nlet scan: Scan\nlet test: Reading[] = [] // array of test readings\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n\n// field offsets\nlet fxOff: number\nlet fyOff: number\nlet fzOff: number\n// field magnitudes\nlet fxMag: number\nlet fyMag: number\nlet fzMag: number\n// field re-scaling factors\nlet fyScale: number // = fyMag / fxMag\nlet fzScale: number // = fzMag / fxMag\n\n// gravity (or pose) sensor offsets\nlet gxOff: number\nlet gyOff: number\nlet gzOff: number\n// gravity magnitudes\nlet gxMag: number\nlet gyMag: number\nlet gzMag: number\n// gravity re-scaling factors\nlet gyScale: number // = gyMag / gxMag\nlet gzScale: number // = gzMag / gxMag\n\n// calibration map\nlet lit: number[][]\n\nlet ready = false // ready for action!\n\n// ================ CLASSES ================\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are aligned, or ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n\n    swing: Vector   // amplitudes in each dimension\n    offset: Vector  // central offsets from origin in each dimension\n    yScale: number // multiplier to match Y readings with X\n    zScale: number // multiplier to match Z readings with X\n    strength: number // the average magnetic field-strength detected on a scan \n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        this.swing.x = (xhi - xlo) / 2\n        this.swing.y = (yhi - ylo) / 2\n        this.swing.z = (zhi - zlo) / 2\n        this.strength = Math.sqrt((this.swing.x * this.swing.x) \n                                + (this.swing.y * this.swing.y) \n                                + (this.swing.z * this.swing.x))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        this.offset.x = (xhi + xlo) / 2\n        this.offset.y = (yhi + ylo) / 2\n        this.offset.z = (zhi + zlo) / 2\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.offset.x\n            this.samples[i].y -= this.offset.y\n            this.samples[i].z -= this.offset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM: number\n        let NN: number\n        let PP: number\n        let QQ: number\n        let RR: number\n        let SS: number\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.yScale = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.zScale = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively correct the plane-crossing vectors, using yScale & zScale:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.yScale\n        let P = Math.sqrt(PP) * this.yScale\n        let Q = Math.sqrt(QQ) * this.zScale\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.zScale\n\n        // since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive the orthogonal rotation-axis\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n\n        let check = 0 // debug point...\n    }\n\n    // dump this scan (and its analysis) to the datalogger\n    dump() {\n        for (let i = 0; i < this.samples.length; i++) {\n            datalogger.log(\n                datalogger.createCV(\"data\", \"raw scan\"),\n                datalogger.createCV(\"fx\", this.samples[i].x),\n                datalogger.createCV(\"fy\", this.samples[i].y),\n                datalogger.createCV(\"fz\", this.samples[i].z))\n        }\n\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.yScale),\n            datalogger.createCV(\"zScale\", this.zScale),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n\n    }\n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.TakeBearing\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest,\n    */\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000)\n                result = 0\n\n                basic.showString(\"D\") // dump the smoothed raw scan data\n                scan.dump()\n            }\n\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                // analyse and re-centre the data\n                basic.showString(\"A\")\n                scan.scope()\n                scan.analyse()\n                if (!simulating) {\n                }\n                // apply scaling corrections to scan data?\n                basic.showString(\"C\") // correct\n                scan.recentre()\n                pause(1000)\n\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            setNorth()\n            pause(1000)\n            basic.clearScreen()\n            ready = true\n            break\n\n        case Tasks.TakeBearing:\n            heading = takeBearing()\n            basic.showNumber(heading)\n            break\n\n    }\n}\n\n/* sample the field and gravity for all extremes of pose\nfunction calibrate() {\n    // only need to visit the central diamond pixels\n    lit = [[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]\n    count = 0\n    let fxLo = 99999\n    let fyLo = 99999\n    let fzLo = 99999\n    let fxHi = -99999\n    let fyHi = -99999\n    let fzHi = -99999\n\n    let gxLo = 99999\n    let gyLo = 99999\n    let gzLo = 99999\n    let gxHi = -99999\n    let gyHi = -99999\n    let gzHi = -99999\n    let f = new Vector(0, 0, 0)\n    let g = new Vector(0, 0, 0)\n    let zAbs: number\n    let px = 0\n    let py = 0\n    basic.clearScreen()\n    while (count < 9) {\n        f.x = input.magneticForce(0)\n        f.y = input.magneticForce(1)\n        f.z = input.magneticForce(2)\n        g.x = input.acceleration(0)\n        g.y = input.acceleration(1)\n        g.z = input.acceleration(2)\n        zAbs = Math.abs(g.z)\n\n        // set LED pixels(px,py) based on tilt angle zones.\n        // REMEMBER: The LSM3030 chip is mounted on the underside, so X & Z axes get reversed.\n        // At rest, the measured gravitational force (implying acceleration in the OPPOSITE direction) is:\n        // X: -1000 with button B at the top; +1000 with Button A at the top.  \n        // Y: -1000 when upright with the Logo at the top; +1000 with the Logo at the bottom.\n        // Z: -1000 when microbit is face-up; +1000 when face-down.\n        if (g.x < -950) show(1, 2)\n        if (g.x > 950) show(3, 2)\n        if (g.y < -950) show(2, 1)\n        if (g.y > 950) show(2, 3)\n        if (g.z < -950) show(2, 2)\n        if (g.z > 950) {\n            show(0, 2)\n            show(4, 2)\n            show(2, 0)\n            show(2, 4)\n        }\n\n        // find range of field\n        if (f.x < fxLo) fxLo = f.x\n        if (f.y < fyLo) fyLo = f.y\n        if (f.z < fzLo) fzLo = f.z\n        if (f.x > fxHi) fxHi = f.x\n        if (f.y > fyHi) fyHi = f.y\n        if (f.z > fzHi) fzHi = f.z\n\n        // ranging gravity is inaccurate (distorted by inertial movement!)\n        if (g.x < gxLo) gxLo = g.x\n        if (g.y < gyLo) gyLo = g.y\n        if (g.z < gzLo) gzLo = g.z\n        if (g.x > gxHi) gxHi = g.x\n        if (g.y > gyHi) gyHi = g.y\n        if (g.z > gzHi) gzHi = g.z\n    }\n    basic.showIcon(IconNames.Happy)\n    // field offsets\n    fxOff = (fxHi + fxLo) / 2\n    fyOff = (fyHi + fyLo) / 2\n    fzOff = (fzHi + fzLo) / 2\n    // field magnitudes\n    fxMag = (fxHi - fxLo) / 2\n    fyMag = (fyHi - fyLo) / 2\n    fzMag = (fzHi - fzLo) / 2\n    // field scaling factors (nominal strength of 1000)\n    fxScale = 1000 / fxMag\n    fyScale = 1000 / fyMag\n    fzScale = 1000 / fzMag\n    // gravity offsets\n    gxOff = (gxHi + gxLo) / 2\n    gyOff = (gyHi + gyLo) / 2\n    gzOff = (gzHi + gzLo) / 2\n    // gravity magnitudes\n    gxMag = (gxHi - gxLo) / 2\n    gyMag = (gyHi - gyLo) / 2\n    gzMag = (gzHi - gzLo) / 2\n    // gravity scaling factors (in milli-gravities)\n    gxScale = 1000 / gxMag\n    gyScale = 1000 / gyMag\n    gzScale = 1000 / gzMag\n\n}\n*/\n\n\nfunction correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - gxOff)\n        reading.y = (input.acceleration(1) - gyOff) * gyScale\n        reading.z = (input.acceleration(2) - gzOff) * gzScale\n    }\n    return reading\n}\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* function show(px: number, py: number) {\n    if (lit[px][py] == 0) {\n        count++\n        lit[px][py] = 1\n        led.plot(px, py)\n        //basic.showNumber(count)\n        //pause(200)\n    }\n} */\n\n\nfunction scanClockwise(ms: number): number {\n    strength = -1\n    scanPeriod = -1\n\n    // unless data has already been pre-loaded into scan[]...\n    // if (!debugMode) \n\n    this.samples.length = samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = samples[this.samples.length - 1].time = samples[0].time\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    strength = scopeScan()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n\n   \n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n    */\n\n\nfunction process() {\n    magnetXYZ = correctedField()\n    gravityXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n}\n\n\n\nfunction dumpTestData() {\n    for (let i = 0; i < test.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"fx\", test[i].field.x),\n            datalogger.createCV(\"fy\", test[i].field.y),\n            datalogger.createCV(\"fz\", test[i].field.z),\n            datalogger.createCV(\"gx\", test[i].pose.x),\n            datalogger.createCV(\"gy\", test[i].pose.y),\n            datalogger.createCV(\"gz\", test[i].pose.z))\n\n    }\n}\n\n\nfunction setNorth() { // set NorthXYZ, and thence compute fromXYZtoENG\n    northXYZ = correctedField()\n    downXYZ = correctedGravity()\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\nfunction takeBearing(): number {\n    // take single reading as magnetXYZ\n    magnetXYZ = new Vector(0,0,0)\n    gravityXYZ = new Vector(0,0,0)\n    for (let i = 0; i < Window; i++) {\n        magnetXYZ.x += input.magneticForce(Dimension.X)\n        magnetXYZ.y += input.magneticForce(Dimension.Y)\n        magnetXYZ.z += input.magneticForce(Dimension.Z)\n        gravityXYZ.x += input.acceleration(Dimension.X)\n        gravityXYZ.y += input.acceleration(Dimension.Y)\n        gravityXYZ.z += input.acceleration(Dimension.Z)\n    }\n    magnetXYZ.x /= Window\n    magnetXYZ.y /= Window\n    magnetXYZ.z /= Window\n    gravityXYZ.x /= Window\n    gravityXYZ.y /= Window\n    gravityXYZ.z /= Window\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"raw test\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n    \n\n    return 333\n}\n\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    if (myName == \"zapop\"){\n        gxMag = 1042.89\n        gyMag = 1007.23\n        gzMag =  992.73\n        gxOff = -70.92\n        gyOff = 44.597\n        gzOff = 6.804      \n    }\n    if (myName == \"gateg\") {\n        gxMag = 1017.578\n        gyMag = 996.736\n        gzMag = 1026.315\n        gxOff = -25.411\n        gyOff = -3.251\n        gzOff = -1.300\n    }\n    if (myName == \"gigav\") {\n        gxMag = 1057.89\n        gyMag = 1023.98\n        gzMag = 1074.06\n        gxOff = -85.33\n        gyOff = 7.22\n        gzOff = -18.94\n    }\n    if (myName == \"zavov\") {\n        gxMag = 1049.285\n        gyMag = 1059.746\n        gzMag = 986.272\n        gxOff = -74.082\n        gyOff = 8.455\n        gzOff = -7.617\n    }\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let xData: number[] = []\n    let yData: number[] = []\n    let zData: number[] = []\n    let xTest: number[] = []\n    let yTest: number[] = []\n    let zTest: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            xData = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            yData = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            zData = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            xTest = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            yTest = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            zTest = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            xData = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            yData = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            zData = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            xTest = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            yTest = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            zTest = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n    }\n    let gxTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gyTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    let gzTest = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\n    // transpose the three arrays into array of triples\n    for (let i = 0; i < times.length; i++) {\n        let sample = new Sample(times[i], xData[i], yData[i], zData[i])\n        samples.push(sample)\n    }\n    // do the same for the test cases\n    for (let n = 0; n < xTest.length; n++) {\n        let reading = new Reading(xTest[n], yTest[n], zTest[n], gxTest[n], gyTest[n], gzTest[n])\n    }\n    return 0\n}\n\n// =============== FOREGROUND CODE =================\nlet count = 0\n/* set scaling and offsets\nif (simulating) { // taken from Bit:Commander\n    fxOff = -21.68\n    fyOff = 42.15\n    fzOff = -9.68\n    gxOff = 4.00\n    gyOff = 14.00\n    gzOff = -142.00\n    fxScale = 22.19\n    fyScale = 21.30\n    fzScale = 23.85\n    gxScale = 0.98\n    gyScale = 1.01\n    gzScale = 0.86\n} else {\n    calibrate()\n}\n\n\n\nbasic.clearScreen()\ndatalogger.log(\n    datalogger.createCV(\"data\", \"OFFSET\"),\n    datalogger.createCV(\"fx\", fxOff),\n    datalogger.createCV(\"fy\", fyOff),\n    datalogger.createCV(\"fz\", fzOff),\n    datalogger.createCV(\"gx\", gxOff),\n    datalogger.createCV(\"gy\", gyOff),\n    datalogger.createCV(\"gz\", gzOff))\n\n\ndatalogger.log(\n    datalogger.createCV(\"data\", \"SCALE\"),\n    datalogger.createCV(\"fx\", fxScale),\n    datalogger.createCV(\"fy\", fyScale),\n    datalogger.createCV(\"fz\", fzScale),\n    datalogger.createCV(\"gx\", gxScale),\n    datalogger.createCV(\"gy\", gyScale),\n    datalogger.createCV(\"gz\", gzScale))\n\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1727976735506,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are aligned, or ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    range: Vector   // amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        this.range.x = (xhi - xlo) / 2\n        this.range.y = (yhi - ylo) / 2\n        this.range.z = (zhi - zlo) / 2\n        this.strength = Math.sqrt((this.range.x * this.range.x) \n                                + (this.range.y * this.range.y) \n                                + (this.range.z * this.range.x))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        this.fieldOffset.x = (xhi + xlo) / 2\n        this.fieldOffset.y = (yhi + ylo) / 2\n        this.fieldOffset.z = (zhi + zlo) / 2\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM: number\n        let NN: number\n        let PP: number\n        let QQ: number\n        let RR: number\n        let SS: number\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    // adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.TakeBearing\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = reading.field\n    downXYZ = reading.pose\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into array of triples...\n    samples = []\n    for (let i = 0; i < times.length; i++) {\n        samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        times.push(times[i])\n    }\n\n    // adopt them, as if just scanned\n    scan.use(samples, times)\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nlet count = 0\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728023946387,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = (a.getMagnitude() * b.getMagnitude()) + a.dottedWith(b)\n        if (this.w > 0.0001) {\n            let axis = a.crossedWith(b)\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n            // vectors are aligned, or ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.i = -a.z\n            this.j = a.y\n            this.k = a.x\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        this.fieldOffset.x = (xhi + xlo) / 2\n        this.fieldOffset.y = (yhi + ylo) / 2\n        this.fieldOffset.z = (zhi + zlo) / 2\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM: number\n        let NN: number\n        let PP: number\n        let QQ: number\n        let RR: number\n        let SS: number\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    // adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = reading.field\n    downXYZ = reading.pose\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    rotateXYZtoENG.toAlignVectors(downXYZ, new Vector(0, 0, 1000))\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728136939551,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n    /*\n   Quaternion get_rotation_between(Vector3 u, Vector3 v)  {\n        float k_cos_theta = dot(u, v);\n        float k = sqrt(length_2(u) * length_2(v));\n        if (k_cos_theta / k == -1)\n        {\n            // 180 degree rotation around any orthogonal vector\n            return Quaternion(0, normalized(orthogonal(u)));\n        }\n\n        return normalized(Quaternion(k_cos_theta + k, cross(u, v)));\n    }\n\n    // another version:\n    return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n        } else if (dot > 0.999999) {\n            out.i = 0;\n            out.j = 0;\n            out.k = 0;\n            out.w = 1;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out.i = tmpvec3.x;\n            out.j = tmpvec3.y;\n            out.k = tmpvec3.z;\n            out.w = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n\n\n    */\n\n    \n    toAlignVectors(a: Vector, b: Vector) {\n        this.w = a.dottedWith(b)\n        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n        if (k < 0.0001) { // vectors align: use identity quaternion\n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.w = 0\n            this.i = -a.x\n            this.j = -a.y\n            this.k = -a.z\n        } else {\n            let axis = a.crossedWith(b)\n            this.w = dot\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        let offX = (xhi + xlo) / 2\n        let offY = (yhi + ylo) / 2\n        let offZ = (zhi + zlo) / 2\n        this.fieldOffset = new Vector(offX, offY, offZ)\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    /* adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }*/\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data...\n                scan.times = [] // .. and their timestamps\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            nextTask = Tasks.TakeBearing\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = new Vector(reading.field.x, reading.field.y, reading.field.z)\n    downXYZ = new Vector(reading.pose.x, reading.pose.y, reading.pose.z)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n    rotateXYZtoENG.toAlignVectors(downXYZ, vertical)\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    testIndex = 0\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728198977065,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align vector (a) onto (b)\n    // by rotating about an axis normal to their common plane\n  /*\n  /**\n  * Sets a quaternion to represent the shortest rotation from one\n  * vector to another.\n  *\n  * Both vectors are assumed to be unit length.\n  *\n  * @param {quat} out the receiving quaternion.\n  * @param {vec3} a the initial vector\n  * @param {vec3} b the destination vector\n  * @returns {quat} out\n  */\n\n  /*\n    rotationTo () {\n        var tmpvec3 = vec3.create();\n        var xUnitVec3 = vec3.fromValues(1, 0, 0);\n        var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n        return function (out, a, b) {\n            var dot = vec3.dot(a, b);\n            if (dot < -0.999999) {\n                vec3.cross(tmpvec3, xUnitVec3, a);\n                if (vec3.length(tmpvec3) < 0.000001)\n                    vec3.cross(tmpvec3, yUnitVec3, a);\n                vec3.normalize(tmpvec3, tmpvec3);\n                quat.setAxisAngle(out, tmpvec3, Math.PI);\n            } else if (dot > 0.999999) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n            } else {\n                vec3.cross(tmpvec3, a, b);\n                out[0] = tmpvec3[0];\n                out[1] = tmpvec3[1];\n                out[2] = tmpvec3[2];\n                out[3] = 1 + dot;\n                return quat.normalize(out, out);\n            }\n        };\n    })();\n    */\n\n\ntoAlignVectors(a: Vector, b: Vector) {\n    let dot: Vector\n    dot = a.dottedWith(b)\n    if (dot < 0.000001) { // vectors align: use identity quaternion\n        this.w = 1\n        this.i = 0\n        this.j = 0\n        this.k = 0\n    } else if (dot > 0.999999) \n\n\n\n\n\n\n        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n        if (k < 0.0001) { // vectors align: use identity quaternion\n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.w = 0\n            this.i = -a.x\n            this.j = -a.y\n            this.k = -a.z\n        } else {\n            let axis = a.crossedWith(b)\n            this.w = dot\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        let offX = (xhi + xlo) / 2\n        let offY = (yhi + ylo) / 2\n        let offZ = (zhi + zlo) / 2\n        this.fieldOffset = new Vector(offX, offY, offZ)\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    /* adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }*/\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data...\n                scan.times = [] // .. and their timestamps\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            nextTask = Tasks.TakeBearing\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = new Vector(reading.field.x, reading.field.y, reading.field.z)\n    downXYZ = new Vector(reading.pose.x, reading.pose.y, reading.pose.z)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n    rotateXYZtoENG.toAlignVectors(downXYZ, vertical)\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    testIndex = 0\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728232608678,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align unit vector (a) onto unit vector (b)\n    // by rotating about an axis normal to their common plane\n    // The axis is just their cross-product, and the angle is deived from their dot-product\n\n\n    /* Two special cases:\n      1. If (a) parallel to (b) (or very close), use the unit Quaternion (1,0,0,0)\n      2. If (a) opposite to (b) (or very close), we need a rotation by 180 degrees around any orthogonal axis\n  /*\n  /**\n  * Sets a quaternion to represent the shortest rotation from one\n  * vector to another.\n  *\n  * Both vectors are assumed to be unit length.\n  *\n  * @param {quat} out the receiving quaternion.\n  * @param {vec3} a the initial vector\n  * @param {vec3} b the destination vector\n  * @returns {quat} out\n  */\n\n  /*\n    rotationTo () {\n        var tmpvec3 = vec3.create();\n        var xUnitVec3 = vec3.fromValues(1, 0, 0);\n        var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n        return function (out, a, b) {\n            var dot = vec3.dot(a, b);\n            if (dot < -0.999999) {\n                vec3.cross(tmpvec3, xUnitVec3, a);\n                if (vec3.length(tmpvec3) < 0.000001)\n                    vec3.cross(tmpvec3, yUnitVec3, a);\n                vec3.normalize(tmpvec3, tmpvec3);\n                quat.setAxisAngle(out, tmpvec3, Math.PI);\n            } else if (dot > 0.999999) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n            } else {\n                vec3.cross(tmpvec3, a, b);\n                out[0] = tmpvec3[0];\n                out[1] = tmpvec3[1];\n                out[2] = tmpvec3[2];\n                out[3] = 1 + dot;\n                return quat.normalize(out, out);\n            }\n        };\n    })();\n\n\n\n    */\n\n\ntoAlignVectors(a: Vector, b: Vector) {\n    let dot: Vector\n    dot = a.dottedWith(b)\n    cross = a.crossedWith(b)\n    if (dot < 0.000001) { // vectors align: use identity quaternion\n        this.w = 1\n        this.i = 0\n        this.j = 0\n        this.k = 0\n    } else if (dot > 0.999999) \n\n\n\n\n\n\n        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n        if (k < 0.0001) { // vectors align: use identity quaternion\n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.w = 0\n            this.i = -a.x\n            this.j = -a.y\n            this.k = -a.z\n        } else {\n            let axis = a.crossedWith(b)\n            this.w = 1 + dot // gives half-angle after normalisation\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        let offX = (xhi + xlo) / 2\n        let offY = (yhi + ylo) / 2\n        let offZ = (zhi + zlo) / 2\n        this.fieldOffset = new Vector(offX, offY, offZ)\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    /* adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }*/\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data...\n                scan.times = [] // .. and their timestamps\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            nextTask = Tasks.TakeBearing\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = new Vector(reading.field.x, reading.field.y, reading.field.z)\n    downXYZ = new Vector(reading.pose.x, reading.pose.y, reading.pose.z)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n    rotateXYZtoENG.toAlignVectors(downXYZ, vertical)\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    testIndex = 0\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728285266737,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align unit vector (a) onto unit vector (b)\n    // by rotating about an axis normal to their common plane\n    // The axis is just their cross-product, and the angle is deived from their dot-product\n\n\n    /* Two special cases:\n      1. If (a) parallel to (b) (or very close), use the unit Quaternion (1,0,0,0)\n      2. If (a) opposite to (b) (or very close), we need a rotation by 180 degrees around any orthogonal axis\n  /*\n  /**\n  * Sets a quaternion to represent the shortest rotation from one\n  * vector to another.\n  *\n  * Both vectors are assumed to be unit length.\n  *\n  * @param {quat} out the receiving quaternion.\n  * @param {vec3} a the initial vector\n  * @param {vec3} b the destination vector\n  * @returns {quat} out\n  */\n\n  /*\n    rotationTo () {\n        var tmpvec3 = vec3.create();\n        var xUnitVec3 = vec3.fromValues(1, 0, 0);\n        var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n        return function (out, a, b) {\n            var dot = vec3.dot(a, b);\n            if (dot < -0.999999) { \n                vec3.cross(tmpvec3, xUnitVec3, a);\n                if (vec3.length(tmpvec3) < 0.000001)\n                    vec3.cross(tmpvec3, yUnitVec3, a);\n                vec3.normalize(tmpvec3, tmpvec3);\n                quat.setAxisAngle(out, tmpvec3, Math.PI);\n            } else if (dot > 0.999999) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 1;\n            } else {\n                vec3.cross(tmpvec3, a, b);\n                out[0] = tmpvec3[0];\n                out[1] = tmpvec3[1];\n                out[2] = tmpvec3[2];\n                out[3] = 1 + dot;\n                return quat.normalize(out, out);\n            }\n        };\n    })();\n\n\n\n    */\n\n\ntoAlignVectors(a: Vector, b: Vector) {\n    let cross: Vector\n    dot = a.dottedWith(b)\n    cross = a.crossedWith(b)\n    if (dot > 0.999999) { \n        // vectors align: use identity quaternion \n        this.w = 1\n        this.i = 0\n        this.j = 0\n        this.k = 0\n    } else if (dot < -0.999999) { \n        // vectors are opposites: we need 180-degree rotation about any orthogonal axis.\n        \n        // \n        // first try using the normal to the plane containing (a) and the x-axis\n        cross = a.crossedWith(new Vector(1,0,0))\n\n    }\n\n\n\n\n\n\n        let k = Math.sqrt(a.getMagnitude() * b.getMagnitude())\n        if (k < 0.0001) { // vectors align: use identity quaternion\n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else if (Math.abs(this.w/k) = -1) {\n            // vectors are ~180 degrees apart, so pick an arbitrary axis with a non-zero length\n            this.w = 0\n            this.i = -a.x\n            this.j = -a.y\n            this.k = -a.z\n        } else {\n            let axis = a.crossedWith(b)\n            this.w = 1 + dot // gives half-angle after normalisation\n            this.i = axis.x\n            this.j = axis.y\n            this.k = axis.z\n        } else {\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        let offX = (xhi + xlo) / 2\n        let offY = (yhi + ylo) / 2\n        let offZ = (zhi + zlo) / 2\n        this.fieldOffset = new Vector(offX, offY, offZ)\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    /* adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }*/\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data...\n                scan.times = [] // .. and their timestamps\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            nextTask = Tasks.TakeBearing\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = new Vector(reading.field.x, reading.field.y, reading.field.z)\n    downXYZ = new Vector(reading.pose.x, reading.pose.y, reading.pose.z)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n    rotateXYZtoENG.toAlignVectors(downXYZ, vertical)\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    testIndex = 0\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1728287431104,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"M:SciCt5=r_@qnW?L}Vn\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" id=\"z~fvBBKsP[m}2SF9+`sB\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\nThis code will form the basis for the extension \"heading.pxt\".\nThe top-level functionality will then be moved into a separate \"test.ts\" module.\n\n*/\n// =============  GLOBALS ===============\n\nconst Window = 7\nconst SampleGap = 20\nconst EnoughScanTime = 1500 // minimum acceptable scan-time\nconst EnoughSamples = 70 // fewest acceptable scan samples\nconst TooManySamples = 500 // don't be too greedy with memory!\nconst MarginalField = 10 // minimum acceptable field-strength for magnetometer readings\nconst TinyField = 2 // minimal field magnitude, considered to be a zero-crossing\n\nenum Tasks {\n    PerformScan,\n    SetNorth,\n    TakeBearing,\n}\nlet nextTask: Tasks = Tasks.PerformScan\n\nlet simulating = isSimulating() // true when debugging\n\nlet scan: Scan  // array of scanned magnetometer samples\nlet testReadings: Reading[] = [] // array of test readings\nlet testIndex: number // next testReading to use when simulating\n\n// Sensor Measurements\nlet magnetXYZ: Vector // current magnetic field\nlet gravityXYZ: Vector // current accelerometer pose\nlet startXYZ: Reading // reading of starting field and pose of the buggy (deemed north and upright)\n\nlet northXYZ: Vector // starting magnetic field of the buggy (while pointing \"North\")\nlet downXYZ: Vector // buggy's Down axis measured while upright and stationary(fixed, dependent on mounting)\n\n// calibrated correction adjustments for accelerometer readings (adopting explicit calibration values\n// previously measured externally by reading the extreme static values in each dimension)\nlet poseOffset: Vector // central offsets from origin in each dimension\nlet poseScaleY: number // multiplier to match Y readings with X\nlet poseScaleZ: number // multiplier to match Z readings with X\n\n\n\n// re-orientation rotations\nlet rotateXYZtoRFD: Quaternion // sensor [XYZ] to buggy's [Right,Front,Down] frame \nlet rotateRFDtoENG: Quaternion // buggy [Right,Front,Down] to world [East,North,Gravity] frame \nlet rotateXYZtoENG: Quaternion // sensor [XYZ] directly to world [East,North,Gravity] frame\n\nlet magnetENG: Vector\nlet gravityENG: Vector\nlet heading: number\n\n// ================ CLASSES ================\n\n/* 3-D vector, with methods for normalisation, dot-product and cross-product. \n*/\nclass Vector {\n    x: number\n    y: number\n    z: number\n\n    constructor(dx: number, dy: number, dz: number) {\n        this.x = dx\n        this.y = dy\n        this.z = dz\n    }\n\n    normalised(): Vector {\n        let r = this.getMagnitude()\n        if (r == 0) {\n            return new Vector(0, 0, 0)\n        } else {\n            return new Vector(this.x / r, this.y / r, this.z / r)\n        }\n    }\n\n    dottedWith(v: Vector): number {\n        return (this.x * v.x + this.y * v.y + this.z * v.z)\n    }\n\n    crossedWith(v: Vector): Vector {\n        let x = this.y * v.z - v.y * this.z\n        let y = this.z * v.x - v.z * this.x\n        let z = this.x * v.y - v.x * this.y\n        return new Vector(x, y, z)\n    }\n\n    // we are sometimes more interested in the square of the magnitude \n    getLengthSquared(): number {\n        return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z))\n    }\n\n    getMagnitude(): number {\n        return Math.sqrt(this.getLengthSquared())\n    }\n}\n\n/**\n* A Quaternion is a tool for manipulating rotations.\n* Initial construction is from an rotation about a given axis.\n* Tools are provided to make it represent an alignment between two vectors,\n* and to apply it to rotate a vector.\n*/\nclass Quaternion {\n    // the real part\n    w: number\n    // the three imaginary parts\n    i: number\n    j: number\n    k: number\n    // squares of components (precomputed for efficiency)\n    ww: number\n    ii: number\n    jj: number\n    kk: number\n    // doubled products of components (precomputed for efficiency)\n    wi2: number\n    wj2: number\n    wk2: number\n    ij2: number\n    jk2: number\n    ki2: number\n\n    // given a rotation-angle and an axis-direction, build a unit quaternion\n    constructor(angle: number, axis: Vector) {\n        let unitV = axis.normalised()\n        this.w = Math.cos(angle / 2)\n        let sinHalfAngle = Math.sin(angle / 2)\n        this.i = unitV.x * sinHalfAngle\n        this.j = unitV.y * sinHalfAngle\n        this.k = unitV.z * sinHalfAngle\n        this.precompute()\n    }\n\n    // compute the Quaternion needed to align unit vector (a) onto unit vector (b)\n    // by rotating about an axis normal to their common plane\n    // The axis is just their cross-product, and the angle is deived from their dot-product.\n    // We need to deal with two special cases:\n    //  - if (a) parallel to (b) (or very close), use the unit Quaternion (1,0,0,0)\n    //  - if (a) opposite to (b) (or very close), we need a rotation by 180 degrees around any orthogonal axis\n\n    toAlignVectors(a: Vector, b: Vector) {\n        let cross: Vector\n        let dot = a.dottedWith(b)\n        cross = a.crossedWith(b) // degenerates if vectors align \n        if (dot > 0.999999) {\n            // parallel vectors: use identity quaternion \n            this.w = 1\n            this.i = 0\n            this.j = 0\n            this.k = 0\n        } else if (dot < -0.999999) {\n            // anti-parallel vectors need 180-degree rotation about any orthogonal axis.\n            // first try using the normal to the plane through (a) and the x-axis\n            cross = a.crossedWith(new Vector(1, 0, 0))\n            // if by chance (a) WAS the x-axis, use the y-axis as our rotation axis\n            if (cross.getLengthSquared() < 0.00001) {\n                cross = new Vector(0, 1, 0)\n            }\n            this.i = cross.x\n            this.j = cross.y\n            this.k = cross.z\n            // the half-angle needed will be 90 degrees\n            this.w = Math.PI\n        } else {\n            // general case\n            this.i = cross.x\n            this.j = cross.y\n            this.k = cross.z\n            this.w = dot\n        }\n        this.normalise()\n        this.precompute()\n\n        datalogger.log(datalogger.createCV(\"w\", this.w),\n            datalogger.createCV(\"i\", this.i),\n            datalogger.createCV(\"j\", this.j),\n            datalogger.createCV(\"k\", this.k))\n    }\n\n\n\n    // use this Quaternion to generate a rotated Vector\n    appliedToVector(v: Vector): Vector {\n        let result = new Vector(0, 0, 0)\n        result.x\n            = v.x * (this.ww + this.ii - this.jj - this.kk)\n            + v.y * (this.ij2 - this.wk2)\n            + v.z * (this.ki2 + this.wj2)\n\n        result.y\n            = v.y * (this.ww + this.jj - this.kk - this.ii)\n            + v.z * (this.jk2 - this.wi2)\n            + v.x * (this.ij2 + this.wk2)\n\n        result.z\n            = v.z * (this.ww + this.kk - this.ii - this.jj)\n            + v.x * (this.ki2 - this.wj2)\n            + v.y * (this.wi2 + this.jk2)\n\n        return result\n    }\n\n    // for a unit Quaternion, the squares of all its components add up to 1.\n    normalise() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        let r = Math.sqrt(this.ww + this.ii + this.jj + this.kk)\n        this.w /= r\n        this.i /= r\n        this.j /= r\n        this.k /= r\n    }\n\n\n    // precompute squares and products (some doubled)...\n    precompute() {\n        this.ww = this.w * this.w\n        this.ii = this.i * this.i\n        this.jj = this.j * this.j\n        this.kk = this.k * this.k\n        this.wi2 = this.w * this.i * 2\n        this.wj2 = this.w * this.j * 2\n        this.wk2 = this.w * this.k * 2\n        this.ij2 = this.i * this.j * 2\n        this.ki2 = this.i * this.k * 2\n        this.jk2 = this.j * this.k * 2\n    }\n}\n\n// a Reading is a compound object containing synchronous 3-D readings from both the magnetometer and accelerometer\nclass Reading {\n    field: Vector // average magnetometer reading\n    pose: Vector // average accelerometer reading\n\n    constructor(fieldX: number, fieldY: number, fieldZ: number,\n        poseX: number, poseY: number, poseZ: number) {\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n        this.pose = new Vector(poseX, poseY, poseZ)\n    }\n}\n\n/* a Sample is a time-stamped 3-D reading from the magnetometer (one element of the scan array)\nclass Sample {\n    time: number\n    field: Vector\n\n    constructor(t: number, fieldX: number, fieldY: number, fieldZ: number) {\n        this.time = t\n        this.field = new Vector(fieldX, fieldY, fieldZ)\n    }\n}*/\n\n\n/* A Smoother object computes moving averages from a sequence of time-stamped vectors of values.\n    It is used to smooth out jittery sensors such as the magnetometer or accelerometer.\n    Timing irregularites due to scheduler interrupts demand this somewhat complex maths.\n    The number of readings to be averaged (window) and expected gap between readings (samplingGap)\n    together set the overall latency associated with the exponential averaging process\n    and govern the blending of new and old readings.\n    */\n\nclass Smoother {\n    dims: number; // dimensionality\n    averages: number[] = []; // the rolling averages\n    window: number; // number of samples needed to form a good average\n    samplingGap: number; // time gap between expected readings\n    latency: number // resulting time taken to collect a good moving average from scratch\n    lastTime: number; // timestamp of latest readings\n    lastInputs: number[] = []; // copy of latest set of readings\n\n    constructor(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.reset(startTime, window, samplingGap, initialValues)\n    }\n\n    // (re)initialise this Smoother\n    reset(startTime: number, window: number, samplingGap: number, initialValues: number[]) {\n        this.lastTime = startTime\n        this.window = window\n        this.samplingGap = samplingGap\n        this.latency = window * samplingGap\n        this.dims = initialValues.length\n        for (let dim = 0; dim < this.dims; dim++) {\n            this.averages[dim] = initialValues[dim]\n            this.lastInputs[dim] = initialValues[dim]\n        }\n    }\n\n    update(timeStamp: number, values: number[]): number[] {\n        // work out appropriate blend, based on time-step (guarding against zero!)\n        let timeFraction = (timeStamp - this.lastTime + 1) / this.latency\n        let keepOld = Math.exp(-timeFraction)\n        let inherited = (1 - keepOld) / timeFraction\n        // amplify the most recent sample's contribution to the inherited average\n        let boostLast = (inherited - keepOld)\n        let addNew = (1 - inherited)\n        // (blending proportions keepOld + boostLast + addNew will always add up to 100%)\n        // apply blending to all elements of old and new data arrays\n        let result: number[] = []\n        for (let i = 0; i < this.dims; i++) {\n            result.push((keepOld * this.averages[i])\n                + (boostLast * this.lastInputs[i])\n                + (addNew * values[i]))\n        }\n        // update history for next time around\n        this.averages = result\n        this.lastTime = timeStamp\n        this.lastInputs = values\n\n        return result\n    }\n}\n\n/** A Scan is a dataset of sequential magnetometer readings gathered while the buggy is spinning on the spot.\n * Methods are provided to acquire, scope and analyse this sequence to derive the correction parameters\n * for the magnetometer (used for future readings). \n * Analysis of the dataset also reveals how long each rotation took, and the orientation of the spin-axis \n * (measured in the sensor's XYZ frame).\n * \n*/\nclass Scan {\n    samples: Vector[] // sequence of magnetometer & accelerometer readings\n    times: number[] // matching sequence of time-stamps for fields[]\n    period: number // derived spin-rotation period in ms\n    downXYZ: Vector // spin-axis (giving the buggy's \"Down\" axis in sensor coordinates)\n    range: Vector   // field amplitudes in each dimension\n    strength: number // the average magnetic field-strength detected on a scan \n\n    // calibrated correction adjustments for magnetometer readings\n    fieldOffset: Vector  // central offsets from origin in each dimension\n    fieldScaleY: number // multiplier to match Y readings with X\n    fieldScaleZ: number // multiplier to match Z readings with X\n\n    fieldSmoother: Smoother // uses a Smoother to maintain a rolling average\n    constructor() {\n        this.samples = []\n        this.times = []\n    }\n\n    // SCAN METHODS\n\n\n    // Perform a scan for specified time\n    acquire(ms: number, dumpIt: boolean) {\n        let timeWas: number\n        let timeNow: number\n        this.samples = [] // start with empty array\n        this.times = []\n\n        // get initial reading\n        let timeStamp = input.runningTime()\n        let field: number[] = [\n            input.magneticForce(Dimension.X),\n            input.magneticForce(Dimension.Y),\n            input.magneticForce(Dimension.Z)]\n\n        this.fieldSmoother = new Smoother(timeStamp, Window, SampleGap, field)\n        let smooth: number[]\n\n        // after an initial settling period, continue cranking out updated moving averages... \n        let startTime = timeStamp + (Window * SampleGap)\n        let stopTime = timeStamp + ms\n\n        // ...until we run out of time (or space!)\n        while ((timeStamp < stopTime)\n            && (this.samples.length < TooManySamples)) {\n            // After processing, sleep until it's time for next sample.\n            // NOTE: here is where various system subprograms will get scheduled.\n            // If they need more time than we've offered, our next sample will get delayed!\n            // (This seems to incur extra delays of ~44 ms every 100ms, plus ~26ms every 400ms)\n\n            timeWas = timeStamp // remember time of latest sample\n            timeNow = input.runningTime()\n            basic.pause((timeWas + SampleGap) - timeNow) // pause for remainder of SampleGap (if any!)\n            timeStamp = input.runningTime() // take a fresh set of readings\n\n            field = [\n                input.magneticForce(Dimension.X),\n                input.magneticForce(Dimension.Y),\n                input.magneticForce(Dimension.Z)]\n            smooth = this.fieldSmoother.update(timeNow, field)\n\n            // only start recording once the moving average has stabilised\n            if (timeStamp > startTime) {\n                // store the averaged field values (as a deep copy!)\n                this.samples.push(new Vector(smooth[0], smooth[1], smooth[2]))\n                this.times.push(timeNow)  // timestamp it  \n            }\n        }\n\n        // dump this scan to the datalogger\n        if (dumpIt) {\n            for (let i = 0; i < this.samples.length; i++) {\n                datalogger.log(\n                    datalogger.createCV(\"data\", \"raw scan\"),\n                    datalogger.createCV(\"fx\", this.samples[i].x),\n                    datalogger.createCV(\"fy\", this.samples[i].y),\n                    datalogger.createCV(\"fz\", this.samples[i].z))\n            }\n        }\n    }\n\n\n    // Each dimension should track a sinusoidal wave of values (generally not centred on zero).\n    // This method finds the value ranges for each axis (usually NOT the full field-strength in any dimension)\n    // It also sets the global offsets needed to correctly re-centre biased future readings\n    scope() {\n        let xlo = 9999999\n        let ylo = 9999999\n        let zlo = 9999999\n        let xhi = -9999999\n        let yhi = -9999999\n        let zhi = -9999999\n        for (let i = 0; i < this.samples.length; i++) {\n            xhi = Math.max(xhi, this.samples[i].x)\n            yhi = Math.max(yhi, this.samples[i].y)\n            zhi = Math.max(zhi, this.samples[i].z)\n            xlo = Math.min(xlo, this.samples[i].x)\n            ylo = Math.min(ylo, this.samples[i].y)\n            zlo = Math.min(zlo, this.samples[i].z)\n        }\n\n        // derive RMS field-strength from the ranges detected in each axis\n        let rangeX = (xhi - xlo) / 2\n        let rangeY = (yhi - ylo) / 2\n        let rangeZ = (zhi - zlo) / 2\n        this.range = new Vector(rangeX, rangeY, rangeZ)\n        this.strength = Math.sqrt((rangeX * rangeX) + (rangeY * rangeY) + (rangeZ * rangeZ))\n\n        // offsets from the origin (due to \"hard-iron\" distortions) lie mid-way between extremes\n        let offX = (xhi + xlo) / 2\n        let offY = (yhi + ylo) / 2\n        let offZ = (zhi + zlo) / 2\n        this.fieldOffset = new Vector(offX, offY, offZ)\n    }\n\n    recentre() {\n        // re-centre all the scan samples, eliminating \"hard-iron\" environmental magnetic effects.\n        for (let i = 0; i < this.samples.length; i++) {\n            this.samples[i].x -= this.fieldOffset.x\n            this.samples[i].y -= this.fieldOffset.y\n            this.samples[i].z -= this.fieldOffset.z\n        }\n    }\n\n    // Method to analyse the scan-readings and derive the magnetometer scaling factors\n    // and the scan spin-axis (measured in the XYZ sensor frame).\n    analyse() {\n        /* given the set of six [X,Y,Z] measurements:\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n    \n        ...and knowing that: \n                X**2 + (yScale * Y)**2 + (zScale * Z)**2 = B**2 (the square of the field strength)\n        \n        ...we can (after some maths!) derive the calibration factors (relative to x):\n                yScale = sqrt((MMQQ - MMSS - QQRR) / (SSNN - SSPP - NNQQ))\n                zScale = sqrt((PPRR - PPMM - RRNN) / (SSNN - SSPP - NNQQ))\n        */\n\n        // we'll mostly be using the squares of the zero-crossing components\n        let MM = 0\n        let NN = 0\n        let PP = 0\n        let QQ = 0\n        let RR = 0\n        let SS = 0\n        // preserve history\n        let xWas: number\n        let yWas: number\n        let zWas: number\n\n        // First, collect the plane-crossings in each direction.\n        // Simultaneously, collect half-periods of rotation, which we will average.\n\n        // counts of zero-crossings detected in this scan\n        let nCrossXY = 0\n        let nCrossYZ = 0\n        let nCrossZX = 0\n        // time-stamps of first crossings (not yet found)\n        let xStart = -1\n        let yStart = -1\n        let zStart = -1\n        // timestamps of last crossings\n        let xFinish: number\n        let yFinish: number\n        let zFinish: number\n\n        // flags to inhibit clocking multiple jittery crossings \n        let needXY = true\n        let needYZ = true\n        let needZX = true\n\n        let x = this.samples[0].x\n        let y = this.samples[0].y\n        let z = this.samples[0].z\n        \n        for (let i = 0; i < this.samples.length; i++) {\n            xWas = x\n            yWas = y\n            zWas = z\n            x = this.samples[i].x\n            y = this.samples[i].y\n            z = this.samples[i].z\n\n            // avoid any exact zeroes (they only complicate comparisons!)\n            if (x == 0) x = xWas\n            if (y == 0) y = yWas\n            if (z == 0) z = zWas\n\n            // Look for the first transition of each half-cycle (i.e. where the sign flips)\n            // (jitter or near-axis alignment may cause repeated fluctuations, which we ignore)\n\n            if ((z * zWas < 0) && needXY) { // sign of z value flips when crossing the XY plane\n                MM += x ** 2\n                NN += y ** 2\n                nCrossXY++\n                zFinish = this.times[i]\n                if (zStart < 0) zStart = zFinish // start the clock...\n                needXY = false\n                // got this plane-crossing, so now only allow other planes to be detected\n                needYZ = true\n                needZX = true\n            }\n            if ((x * xWas < 0) && needYZ) { // sign of x value flips when crossing the YZ plane\n                PP += y ** 2\n                QQ += z ** 2\n                nCrossYZ++\n                xFinish = this.times[i]\n                if (xStart < 0) xStart = xFinish\n                needYZ = false\n                needXY = true\n                needZX = true\n            }\n            if ((y * yWas < 0) && needZX) { // sign of y value flips when crossing the ZX plane\n                RR += x ** 2\n                SS += z ** 2\n                nCrossZX++\n                yFinish = this.times[i]\n                if (yStart < 0) yStart = yFinish\n                needZX = false\n                needXY = true\n                needYZ = true\n            }\n        }\n        // average the squared crossing points\n        MM /= nCrossXY\n        NN /= nCrossXY\n        PP /= nCrossYZ\n        QQ /= nCrossYZ\n        RR /= nCrossZX\n        SS /= nCrossZX\n\n        // derive the average \"flip\" times (each making half a rotation)\n        let xFlip = (xFinish - xStart) / (nCrossYZ - 1)\n        let yFlip = (yFinish - yStart) / (nCrossZX - 1)\n        let zFlip = (zFinish - zStart) / (nCrossXY - 1)\n\n        // average the three half-periods, then double them to get our best measure for full period\n        this.period = (xFlip + yFlip + zFlip) / 1.5\n\n        // construct the relative scaling factors\n        let bottom = (NN * SS) - (SS * PP) - (NN * QQ)\n        this.fieldScaleY = Math.sqrt((MM * QQ) - (QQ * RR) - (SS * MM) / bottom)\n        this.fieldScaleZ = Math.sqrt((PP * RR) - (PP * MM) - (NN * RR) / bottom)\n\n        /* retrospectively rebalance the Y and Z components of the plane-crossing vectors\n                [M, N, -] when crossing the XY plane\n                [-, P, Q] when crossing the YZ plane\n                [R, -, S] when crossing the ZX plane\n        */\n        let M = Math.sqrt(MM)\n        let N = Math.sqrt(NN) * this.fieldScaleY\n        let P = Math.sqrt(PP) * this.fieldScaleY\n        let Q = Math.sqrt(QQ) * this.fieldScaleZ\n        let R = Math.sqrt(RR)\n        let S = Math.sqrt(MM) * this.fieldScaleZ\n\n        // Since the three crossing-points form a co-planar triangle lying in the Spin-Circle plane, we can take the \n        // cross-product of any two edges to derive dynamically the orthogonal rotation-axis (the buggy's \"Down\" axis).\n        // (We'll later compare this with the static reading taken when setNorth() is invoked.)\n        let I = (Q * N) - (N * S) + (S * P)\n        let J = (R * Q) - (Q * M) + (M * S)\n        let K = (N * R) - (R * P) + (P * M)\n\n        this.downXYZ = new Vector(I, J, K)\n        this.downXYZ = this.downXYZ.normalised()\n\n        let check = 0 // just a debug point...\n    }\n\n    /* adopt a previously-recorded dataset\n    use(samples: Vector[], times: number[]) {\n        this.samples = samples\n        this.times = times\n    }*/\n\n    // dump the correction parameters and spin-axis\n    dumpAnalysis() {\n        datalogger.log(\n            datalogger.createCV(\"yScale\", this.fieldScaleY),\n            datalogger.createCV(\"zScale\", this.fieldScaleZ),\n            datalogger.createCV(\"downX\", this.downXYZ.x),\n            datalogger.createCV(\"downY\", this.downXYZ.y),\n            datalogger.createCV(\"downZ\", this.downXYZ.z))\n    }\n    \n}\n\n\n// ============== INPUT HANDLERS ===============\ninput.onButtonPressed(Button.A, function() {\n    doNextTask()\n})\ninput.onButtonPressed(Button.B, function () {\n    dumpTestData()\n})\n\ninput.onButtonPressed(Button.AB, function () {\n    datalogger.deleteLog()\n    basic.showIcon(IconNames.No)\n    pause(2000)\n    basic.clearScreen()\n    nextTask = Tasks.PerformScan\n    characteriseAccelerometer() // adopt calibration data for well-known (to me!) microbits\n})\n\n\n\n\n/**\n     * Although fairly close, the magnetometer sensitivity in each axis direction varies by a few\n     * percent. By extracting plane-crossings from the scan-data this function calculates from first\n     * principles the global calibration factors: yScale and zScale.\n     * These are then used to correct the plane-crossings before using them to derive the spin-axis.\n     * As a by-product, the sample timestamps allow the average spin-rotation period to be measured.\n     *\n     * NOTE: There is no guarantee that the spin-axis is truly \"vertical\": the buggy may be operating\n     * on a tilted surface. Its \"Down\" axis would not then coincide with the world-frame \"Gravity\" axis.\n     * To establish this relationship, we will need (later) to call SetNorth() with the buggy at rest.\n    */\n\n// ============== FUNCTIONS ===============\n\n\n\nfunction doNextTask() {\n    let bearing: number\n    let result: number\n    switch (nextTask) {\n        case Tasks.PerformScan:\n            basic.showString(\"S\") // scan\n            pause(1000)\n            basic.clearScreen()\n            if (isSimulating) {\n                result = simulateScan(\"T07260757_dash70\")\n            } else {\n                scan.acquire(6000, true)\n            }\n            \n            scan.scope() // find extremes of rotational variation\n            // TODO. check here that scan.strength is sufficient\n\n            scan.recentre() // correct for \"hard-iron\" bias\n\n            scan.analyse()  // derive rotation-period and rotation-axis\n            result = 0\n            if (result != 0) {\n                basic.showNumber(result)\n            } else {\n                scan.samples = [] // release memory used for scan data...\n                scan.times = [] // .. and their timestamps\n                basic.showIcon(IconNames.Yes)\n                pause(1000)\n                nextTask = Tasks.SetNorth\n            }\n            break\n\n        case Tasks.SetNorth:\n            basic.showString(\"N\")\n            pause(500) // ensure accelerometer is at rest\n            setNorth()  // take a fix on \"North\" and the \"Down\" orientation\n            pause(1000)\n            basic.clearScreen()\n            nextTask = Tasks.TakeBearing\n            break\n\n        case Tasks.TakeBearing:\n            bearing = getHeading()\n            basic.showNumber(bearing)\n            pause(1000)\n            basic.clearScreen()\n            break\n\n    }\n}\n\n/***\n * function correctedField(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = 8.16\n        reading.y = 7.91\n        reading.z = 32.72\n    } else {\n        reading.x = (input.magneticForce(0) - fxOff)\n        reading.y = (input.magneticForce(1) - fyOff) * fyScale\n        reading.z = (input.magneticForce(2) - fzOff) * fzScale\n    }\n    return reading\n}\n\nfunction correctedGravity(): Vector {\n    let reading = new Vector(0, 0, 0)\n    if (simulating) {\n        reading.x = -23.53\n        reading.y = 30.43\n        reading.z = -762.48\n    } else {\n        reading.x = (input.acceleration(0) - poseOffset.x)\n        reading.y = (input.acceleration(1) - poseOffset.y) * gyScale\n        reading.z = (input.acceleration(2) - poseOffset.z) * gzScale\n    }\n    return reading\n}\n***/\n\n// either we're simulating, or we're shut in a magnetic shielding box!\nfunction isSimulating(): boolean {\n    let x = input.magneticForce(0)\n    let y = input.magneticForce(1)\n    let z = input.magneticForce(2)\n    return ((x == 0) && (y == 0) && (z == 0))\n}\n\n/* eventual user interfaces\n\nfunction scanClockwise(ms: number): number {\n\n    let nSamples = scan.samples.length\n\n    // Now analyse the scan-data to decide how best to use the magnetometer readings.\n    // we'll typically need about a couple of second's worth of scanned readings...\n    let scanDuration = scan.times[scan.samples.length - 1] = scan.times[0]\n    if ((this.samples.length < EnoughSamples) || (scanDuration < EnoughScanTime)) {\n        return -1 // \"NOT ENOUGH SCAN DATA\"\n    }\n\n    let strength = scan.scope()\n\n    // Complain if the scan didn't properly detect the Earth's magnetic field,\n    // (perhaps due to magnetic shielding?)\n    if (strength < MarginalField) {\n        return -2 // \"FIELD STRENGTH TOO WEAK\"\n    }\n}\n\n\n    // assess the scan-data to detect unequal axis sensitivity \n    // (also derives the scanPeriod, and the downXYZ spin-axis)\n    // analyseScan()\n\n    /* correct all the scan-data (for unequal axis sensitivity) by rescaling y & z values\n    for (let i = 0; i < this.samples.length; i++) {\n        scan[i].field.y *= yScale\n        scan[i].field.z *= zScale\n    }\n*/\n\n\nfunction getHeading() {\n    let reading: Reading = takeReading()\n    magnetXYZ = reading.field\n    gravityXYZ = reading.pose\n    datalogger.log(\n        datalogger.createCV(\"data\", \"XYZ vals\"),\n        datalogger.createCV(\"fx\", magnetXYZ.x),\n        datalogger.createCV(\"fy\", magnetXYZ.y),\n        datalogger.createCV(\"fz\", magnetXYZ.z),\n        datalogger.createCV(\"gx\", gravityXYZ.x),\n        datalogger.createCV(\"gy\", gravityXYZ.y),\n        datalogger.createCV(\"gz\", gravityXYZ.z))\n    //let dot = field.dottedWith(gravity)\n    //let cross = field.crossedWith(gravity)\n    magnetENG = rotateXYZtoENG.appliedToVector(magnetXYZ)\n    gravityENG = rotateXYZtoENG.appliedToVector(gravityXYZ)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"ENG vals\"),\n        datalogger.createCV(\"fx\", magnetENG.x),\n        datalogger.createCV(\"fy\", magnetENG.y),\n        datalogger.createCV(\"fz\", magnetENG.z),\n        datalogger.createCV(\"gx\", gravityENG.x),\n        datalogger.createCV(\"gy\", gravityENG.y),\n        datalogger.createCV(\"gz\", gravityENG.z))\n\n    heading = (2 * Math.PI + Math.atan2(magnetENG.y, magnetENG.x)) % (2 * Math.PI)\n    heading = heading * 180 / Math.PI\n    datalogger.log(\n        datalogger.createCV(\"heading\", heading))\n    return heading\n}\n\n\n// dump the test readings from this session to the datalogger\nfunction dumpTestData() {\n    for (let i = 0; i < testReadings.length; i++) {\n        datalogger.log(\n            datalogger.createCV(\"data\", \"test readings\"),\n            datalogger.createCV(\"fx\", testReadings[i].field.x),\n            datalogger.createCV(\"fy\", testReadings[i].field.y),\n            datalogger.createCV(\"fz\", testReadings[i].field.z),\n            datalogger.createCV(\"gx\", testReadings[i].pose.x),\n            datalogger.createCV(\"gy\", testReadings[i].pose.y),\n            datalogger.createCV(\"gz\", testReadings[i].pose.z))\n\n    }\n}\n\n// take (stable!) sensor readings for buggy \"Down\" axis pose and \"North\" magnetic field\n// (measured in the sensor's XYZ frame)\nfunction setNorth() {\n    let reading: Reading\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        reading = takeReading()\n    }\n    northXYZ = new Vector(reading.field.x, reading.field.y, reading.field.z)\n    downXYZ = new Vector(reading.pose.x, reading.pose.y, reading.pose.z)\n\n    datalogger.log(\n        datalogger.createCV(\"data\", \"N & DOWN\"),\n        datalogger.createCV(\"fx\", northXYZ.x),\n        datalogger.createCV(\"fy\", northXYZ.y),\n        datalogger.createCV(\"fz\", northXYZ.z),\n        datalogger.createCV(\"gx\", downXYZ.x),\n        datalogger.createCV(\"gy\", downXYZ.y),\n        datalogger.createCV(\"gz\", downXYZ.z))\n\n // compute rotation required to convert XYZ readings into the East-North-Gravity world-frame\n    let vertical = new Vector(0, 0, -1023)\n    rotateXYZtoENG = new Quaternion(0,vertical)\n    rotateXYZtoENG.toAlignVectors(downXYZ, vertical)\n}\n\n\n\n// take a single test reading in the XYZ sensor-frame\nfunction takeReading(): Reading {\n    let reading: Reading\n    // field accumulator\n    let fieldX: number\n    let fieldY: number\n    let fieldZ: number\n    // pose accumulator\n    let poseX: number\n    let poseY: number\n    let poseZ: number\n    if (simulating) {\n        reading = testReadings[testIndex]\n        testIndex++\n    } else {\n        for (let i = 0; i < Window; i++) {\n            fieldX += input.magneticForce(Dimension.X)\n            fieldY += input.magneticForce(Dimension.Y)\n            fieldZ += input.magneticForce(Dimension.Z)\n            poseX += input.acceleration(Dimension.X)\n            poseY += input.acceleration(Dimension.Y)\n            poseZ += input.acceleration(Dimension.Z)\n        }\n        fieldX /= Window\n        fieldY /= Window\n        fieldZ /= Window\n        poseX /= Window\n        poseY /= Window\n        poseZ /= Window\n    }\n\n    // apply corrections\n    fieldX -= scan.fieldOffset.x\n    fieldY = (fieldY - scan.fieldOffset.y) * scan.fieldScaleY\n    fieldZ = (fieldZ - scan.fieldOffset.x) * scan.fieldScaleZ\n    poseX -= poseOffset.x\n    poseY = (poseY - poseOffset.y) * poseScaleY\n    poseZ = (poseZ - poseOffset.z) * poseScaleY\n    return new Reading(fieldX, fieldY, fieldZ, poseX, poseY, poseZ)\n}\n\n// adopt extrnally-measured calibration (for some microbits I have known...)\nfunction characteriseAccelerometer() {\n    let myName = control.deviceName()\n    let dx = 0\n    let dy = 0\n    let dz = 0\n    switch (myName) {\n        case \"sim-\":\n            poseScaleY = 1\n            poseScaleZ = 1\n            dx = 0\n            dy = 0\n            dz = 0\n            break\n\n        case \"zapop\":\n            poseScaleY = 1042.89 / 1007.23\n            poseScaleZ = 1042.89 / 992.73\n            dx = -70.92\n            dy = 44.597\n            dz = 6.804\n            break\n\n        case \"gateg\":\n            poseScaleY = 1017.578 / 996.736\n            poseScaleZ = 1017.578 / 1026.315\n            dx = -25.411\n            dy = -3.251\n            dz = -1.300\n            break\n\n        case \"gigav\":\n            poseScaleY = 1057.89 / 1023.98\n            poseScaleZ = 1057.89 / 1074.06\n            dx = -85.33\n            dy = 7.22\n            dz = -18.94\n            break\n\n        case \"zavov\":\n            poseScaleY = 1049.285 / 1059.746\n            poseScaleZ = 1049.285 / 986.272\n            dx = -74.082\n            dy = 8.455\n            dz = -7.617\n            break\n\n        default: // presume perfection until proved otherwise!\n            poseScaleY = 1\n            poseScaleZ = 1\n            poseOffset.x = 0\n            poseOffset.y = 0\n            poseOffset.z = 0\n            break\n    } \n    poseOffset = new Vector(dx, dy, dz)\n}\n\nfunction simulateScan(dataset: string) {\n    let times: number[]\n    let samples: Vector[] = []\n    let testReading: Reading\n    let scanX: number[] = []\n    let scanY: number[] = []\n    let scanZ: number[] = []\n    let testFieldX: number[] = []\n    let testFieldY: number[] = []\n    let testFieldZ: number[] = []\n    let testPoseX: number[] = []\n    let testPoseY: number[] = []\n    let testPoseZ: number[] = []\n    switch (dataset) {\n\n        case \"T07141743_blup70\": // bottom-left upwards; dip=70\n            times = [32009, 32057, 32073, 32089, 32105, 32121, 32137, 32193, 32209, 32225, 32241, 32257, 32273, 32289, 32305, 32361, 32377, 32393, 32409, 32425, 32441, 32457, 32473, 32529, 32545, 32561, 32577, 32593, 32609, 32625, 32713, 32729, 32745, 32761, 32777, 32793, 32809, 32825, 32885, 32901, 32917, 32933, 32949, 32965, 32981, 33037, 33053, 33069, 33085, 33101, 33117, 33133, 33149, 33205, 33221, 33237, 33253, 33269, 33285, 33301, 33385, 33401, 33417, 33433, 33449, 33465, 33481, 33497, 33553, 33569, 33585, 33601, 33617, 33633, 33649, 33665, 33721, 33737, 33753, 33769, 33785, 33801, 33817, 33873, 33889, 33905, 33921, 33937, 33953, 33969, 33985, 34069, 34085, 34101, 34117, 34133, 34149, 34165, 34193, 34225, 34241, 34257, 34273, 34289, 34305, 34321, 34381, 34397, 34413, 34429, 34445, 34461, 34477, 34493, 34549, 34565, 34581, 34597, 34613, 34629, 34645, 34729, 34745, 34761, 34777, 34793, 34809, 34825, 34841, 34897, 34913, 34929, 34945, 34961, 34977, 34993, 35049, 35065, 35081, 35097, 35113, 35129, 35145, 35161, 35217, 35233, 35249, 35265, 35281, 35297, 35313, 35329, 35413, 35429, 35445, 35461, 35477, 35493, 35509, 35565, 35581, 35597, 35613, 35629, 35645, 35661, 35677, 35733, 35749, 35765, 35781, 35797, 35813, 35829, 35889, 35905, 35921, 35941, 35957, 35977, 35993, 36009, 36093, 36109, 36125, 36141, 36157, 36173, 36189, 36205, 36265, 36285, 36301, 36317, 36333, 36349, 36365, 36425, 36441, 36457, 36473, 36489, 36509, 36525, 36541, 36601, 36617, 36633, 36649, 36665, 36681, 36697, 36717, 36801, 36817, 36833, 36849, 36865, 36881, 36897, 36957, 36973, 36993, 37009, 37025, 37041, 37057, 37073, 37133, 37149, 37165, 37185, 37201, 37217, 37233, 37293, 37309, 37325, 37341, 37357, 37377, 37393, 37409, 37513, 37529, 37545, 37561, 37577, 37597, 37613, 37629, 37689, 37705, 37721, 37737, 37753, 37773, 37789, 37849]\n            scanX = [887.59, 889.13, 889.71, 890.29, 890.92, 891.59, 892.27, 894.78, 895.5, 896.22, 896.95, 897.69, 898.51, 899.29, 899.92, 902.1, 902.74, 903.37, 903.98, 904.58, 905.16, 905.7, 906.19, 907.75, 908.14, 908.47, 908.75, 909.03, 909.29, 909.5, 910.21, 910.23, 910.19, 910.13, 910.01, 909.81, 909.59, 909.38, 908.27, 907.95, 907.63, 907.23, 906.74, 906.24, 905.79, 904.17, 903.63, 903.04, 902.39, 901.71, 901.1, 900.47, 899.78, 897.25, 896.48, 895.71, 894.94, 894.18, 893.42, 892.63, 888.97, 888.33, 887.69, 887.06, 886.45, 885.88, 885.39, 884.91, 883.48, 883.16, 882.84, 882.57, 882.36, 882.23, 882.15, 882.08, 881.96, 881.99, 882.13, 882.31, 882.48, 882.68, 882.87, 883.82, 884.23, 884.68, 885.14, 885.63, 886.13, 886.65, 887.19, 890.34, 891.01, 891.75, 892.55, 893.35, 894.14, 894.94, 896.39, 898.01, 898.79, 899.56, 900.32, 901.05, 901.8, 902.54, 904.97, 905.53, 906.04, 906.5, 906.89, 907.31, 907.76, 908.13, 909.11, 909.33, 909.49, 909.6, 909.69, 909.74, 909.72, 909.25, 909.13, 908.98, 908.75, 908.48, 908.18, 907.89, 907.58, 906.27, 905.85, 905.39, 904.88, 904.39, 903.86, 903.32, 901.4, 900.8, 900.13, 899.43, 898.78, 898.14, 897.5, 896.82, 894.41, 893.76, 893.12, 892.48, 891.85, 891.17, 890.49, 889.84, 886.85, 886.33, 885.85, 885.4, 884.95, 884.48, 884.01, 882.74, 882.48, 882.23, 882.03, 881.87, 881.7, 881.53, 881.44, 881.36, 881.36, 881.42, 881.55, 881.72, 881.89, 882.06, 883.09, 883.45, 883.83, 884.43, 884.98, 885.72, 886.35, 886.94, 890.46, 891.23, 891.97, 892.68, 893.45, 894.29, 895.16, 896.04, 899.26, 900.29, 901.1, 901.88, 902.62, 903.3, 903.95, 906.16, 906.66, 907.11, 907.53, 907.91, 908.32, 908.62, 908.92, 909.63, 909.73, 909.74, 909.7, 909.68, 909.67, 909.62, 909.46, 908.19, 907.91, 907.64, 907.3, 906.94, 906.64, 906.29, 904.66, 904.21, 903.61, 903.11, 902.59, 902.04, 901.47, 900.89, 898.83, 898.25, 897.66, 896.93, 896.36, 895.78, 895.17, 892.83, 892.24, 891.69, 891.13, 890.52, 889.72, 889.11, 888.53, 885.11, 884.67, 884.28, 883.88, 883.49, 883.08, 882.74, 882.42, 881.65, 881.51, 881.38, 881.31, 881.27, 881.28, 881.32, 881.75, 881.16]\n            scanY = [1586.86, 1587.98, 1588.36, 1588.68, 1589, 1589.33, 1589.65, 1590.42, 1590.58, 1590.69, 1590.77, 1590.85, 1590.91, 1590.88, 1590.8, 1590.45, 1590.3, 1590.09, 1589.86, 1589.56, 1589.22, 1588.9, 1588.58, 1587.2, 1586.76, 1586.24, 1585.67, 1585.17, 1584.69, 1584.12, 1580.57, 1579.91, 1579.24, 1578.54, 1577.81, 1577.08, 1576.37, 1575.7, 1573.32, 1572.64, 1571.95, 1571.27, 1570.54, 1569.85, 1569.19, 1567.16, 1566.65, 1566.15, 1565.65, 1565.18, 1564.74, 1564.34, 1563.96, 1562.9, 1562.71, 1562.58, 1562.46, 1562.37, 1562.32, 1562.28, 1562.83, 1563.04, 1563.27, 1563.55, 1563.85, 1564.18, 1564.57, 1564.97, 1566.67, 1567.26, 1567.86, 1568.43, 1569.04, 1569.67, 1570.34, 1571.08, 1573.56, 1574.22, 1574.9, 1575.69, 1576.44, 1577.15, 1577.85, 1580.1, 1580.72, 1581.35, 1581.96, 1582.56, 1583.19, 1583.75, 1584.3, 1586.89, 1587.3, 1587.66, 1587.97, 1588.28, 1588.58, 1588.85, 1589.2, 1589.44, 1589.49, 1589.44, 1589.33, 1589.18, 1588.97, 1588.75, 1587.81, 1587.52, 1587.15, 1586.71, 1586.19, 1585.66, 1585.17, 1584.7, 1582.82, 1582.22, 1581.61, 1581.01, 1580.42, 1579.8, 1579.15, 1575.98, 1575.36, 1574.75, 1574.14, 1573.54, 1572.96, 1572.38, 1571.81, 1569.68, 1569.09, 1568.52, 1567.99, 1567.52, 1567.02, 1566.5, 1564.87, 1564.47, 1564.16, 1563.89, 1563.54, 1563.15, 1562.83, 1562.58, 1562.06, 1561.96, 1561.89, 1561.84, 1561.78, 1561.75, 1561.81, 1561.93, 1562.98, 1563.29, 1563.62, 1563.94, 1564.28, 1564.64, 1565.02, 1566.62, 1567.08, 1567.55, 1568.05, 1568.58, 1569.14, 1569.68, 1570.18, 1572.16, 1572.79, 1573.48, 1574.17, 1574.85, 1575.52, 1576.18, 1578.69, 1579.38, 1580.11, 1581.01, 1581.7, 1582.52, 1583.15, 1583.72, 1586.25, 1586.71, 1587.18, 1587.59, 1587.97, 1588.29, 1588.54, 1588.75, 1589.03, 1588.98, 1588.89, 1588.76, 1588.61, 1588.43, 1588.2, 1586.94, 1586.51, 1586.08, 1585.67, 1585.27, 1584.71, 1584.17, 1583.53, 1581.21, 1580.6, 1579.94, 1579.27, 1578.61, 1577.96, 1577.31, 1576.5, 1573.1, 1572.49, 1571.93, 1571.34, 1570.65, 1569.96, 1569.34, 1567.43, 1566.95, 1566.37, 1565.97, 1565.57, 1565.15, 1564.73, 1564.34, 1563.05, 1562.75, 1562.5, 1562.25, 1562.04, 1561.85, 1561.7, 1561.32, 1561.29, 1561.28, 1561.3, 1561.35, 1561.48, 1561.58, 1561.71, 1563.58, 1564, 1564.44, 1564.89, 1565.37, 1565.9, 1566.32, 1566.79, 1568.82, 1569.37, 1569.94, 1570.58, 1571.21, 1571.97, 1572.6, 1575.1, 1566.09]\n            scanZ = [424.65, 424.91, 425.05, 425.15, 425.24, 425.37, 425.57, 426.47, 426.72, 426.93, 427.14, 427.37, 427.62, 427.9, 428.19, 429.33, 429.66, 429.95, 430.25, 430.57, 430.88, 431.19, 431.54, 432.76, 433.13, 433.54, 433.92, 434.26, 434.56, 434.86, 436.42, 436.7, 436.97, 437.25, 437.52, 437.77, 437.99, 438.19, 438.85, 439.02, 439.16, 439.28, 439.38, 439.46, 439.57, 439.72, 439.7, 439.67, 439.6, 439.47, 439.38, 439.35, 439.31, 438.83, 438.62, 438.39, 438.15, 437.87, 437.58, 437.27, 435.39, 435.02, 434.7, 434.36, 434, 433.62, 433.21, 432.78, 431.34, 430.96, 430.6, 430.24, 429.84, 429.48, 429.16, 428.84, 427.79, 427.51, 427.26, 427, 426.75, 426.57, 426.44, 426.01, 425.91, 425.82, 425.7, 425.61, 425.55, 425.49, 425.45, 425.69, 425.8, 425.95, 426.12, 426.33, 426.55, 426.74, 427.16, 427.75, 428.05, 428.39, 428.81, 429.2, 429.55, 429.91, 431.31, 431.67, 432.02, 432.38, 432.72, 433.09, 433.45, 433.81, 435.05, 435.36, 435.68, 436.02, 436.32, 436.61, 436.92, 438.33, 438.53, 438.77, 438.97, 439.11, 439.29, 439.48, 439.61, 439.84, 439.93, 439.97, 439.96, 439.96, 439.95, 439.97, 439.8, 439.67, 439.55, 439.47, 439.33, 439.2, 439.08, 438.92, 438.25, 438.04, 437.84, 437.57, 437.28, 437, 436.68, 436.35, 434.66, 434.3, 433.91, 433.56, 433.23, 432.91, 432.58, 431.48, 431.21, 430.9, 430.59, 430.26, 429.91, 429.61, 429.34, 428.46, 428.2, 427.98, 427.74, 427.5, 427.33, 427.16, 426.47, 426.32, 426.18, 426, 425.91, 425.8, 425.74, 425.75, 426.1, 426.22, 426.34, 426.47, 426.66, 426.88, 427.1, 427.35, 428.54, 428.98, 429.35, 429.7, 430.04, 430.41, 430.79, 432.22, 432.61, 432.99, 433.35, 433.71, 434.16, 434.5, 434.81, 436.04, 436.39, 436.7, 436.95, 437.26, 437.6, 437.9, 438.22, 439.05, 439.15, 439.24, 439.37, 439.52, 439.68, 439.78, 439.89, 439.95, 440.02, 440.02, 439.95, 439.88, 439.85, 439.85, 439.58, 439.43, 439.29, 439.12, 438.97, 438.8, 438.59, 437.8, 437.55, 437.27, 437.06, 436.82, 436.41, 436.1, 435.79, 433.47, 433.13, 432.81, 432.47, 432.13, 431.72, 431.38, 431.05, 429.9, 429.59, 429.32, 429.04, 428.72, 428.38, 428.13, 427.27, 430.74]\n            testFieldX = [881.04, 880.44, 889.41, 901.18, 910.09, 911.06, 901.67, 889.44, 880.74, 880.39, 888.66, 900.99, 910.05, 910.09, 901.37, 889.26, 880.29, 879.88, 888.69, 900.51, 909.99, 909.77, 901.22, 888.58, 879.79]\n            testFieldY = [1566.06, 1577.64, 1588.18, 1591.76, 1585.86, 1573.95, 1562.89, 1559.31, 1565.21, 1576.89, 1587.86, 1591.16, 1584.79, 1573.18, 1562.72, 1559.14, 1565.25, 1576.5, 1587.41, 1590.28, 1584.86, 1572.92, 1562.46, 1558.41, 1564.11]\n            testFieldZ = [430.54, 425.51, 424.33, 428.21, 434.21, 439.48, 440.53, 437.04, 430.59, 425.85, 424.91, 428.08, 434.46, 439.11, 440.31, 436.91, 430.22, 425.46, 424.44, 427.63, 434.36, 439.48, 440.25, 436.84, 430.5]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []    \n            break\n\n        case \"T07260757_dash70\": // angled forward like a dash-board: dip=70\n            times = [9229, 9245, 9261, 9277, 9293, 9309, 9325, 9341, 9357, 9373, 9389, 9405, 9421, 9437, 9453, 9469, 9485, 9501, 9517, 9533, 9549, 9565, 9581, 9597, 9613, 9629, 9645, 9661, 9677, 9693, 9709, 9725, 9741, 9757, 9773, 9789, 9805, 9821, 9837, 9853, 9869, 9885, 9901, 9917, 9933, 9949, 9965, 9981, 9997, 10013, 10029, 10045, 10061, 10077, 10093, 10109, 10125, 10141, 10157, 10173, 10189, 10205, 10221, 10237, 10253, 10269, 10285, 10301, 10317, 10333, 10349, 10365, 10381, 10397, 10413, 10429, 10445, 10461, 10477, 10493, 10509, 10525, 10541, 10557, 10573, 10589, 10605, 10621, 10637, 10653, 10669, 10685, 10701, 10717, 10733, 10749, 10765, 10781, 10797, 10813, 10829, 10845, 10861, 10877, 10893, 10909, 10925, 10941, 10957, 10973, 10989, 11005, 11021, 11037, 11053, 11069, 11085, 11101, 11117, 11133, 11149, 11165, 11181, 11197, 11213, 11229, 11245, 11261, 11277, 11293, 11309, 11325, 11341, 11357, 11373, 11389, 11405, 11421, 11437, 11453, 11469, 11485, 11501, 11517, 11533, 11549, 11565, 11581, 11597, 11613, 11629, 11645, 11661, 11677, 11693, 11709, 11725, 11741, 11757, 11773, 11789, 11805, 11821, 11837, 11853, 11869, 11885, 11901, 11917, 11933, 11949, 11965, 11981, 11997, 12013, 12029, 12045, 12061, 12077, 12093, 12109, 12125, 12141, 12157, 12173, 12189, 12205, 12221, 12237, 12253, 12269, 12285, 12301, 12317, 12333, 12349, 12365, 12381, 12397, 12413, 12429, 12445, 12461, 12477, 12493, 12509, 12525, 12541, 12557, 12573, 12589, 12605, 12621, 12637, 12653, 12669, 12685, 12701, 12717, 12733, 12749, 12765, 12781, 12797, 12813, 12829, 12845, 12861, 12877, 12893, 12909, 12925, 12941, 12957, 12973, 12989, 13005, 13021, 13037, 13053, 13069, 13085, 13101, 13117, 13133, 13149, 13165, 13181, 13197, 13213, 13229, 13245, 13261, 13277, 13293, 13309, 13325, 13341, 13357, 13373, 13389, 13405, 13421, 13437, 13453, 13469, 13485, 13501, 13517, 13533, 13549, 13565, 13581, 13597, 13613, 13629, 13645, 13661, 13677, 13693, 13709, 13725, 13741, 13757, 13773, 13789, 13805, 13821, 13837, 13853, 13869, 13885, 13901, 13917, 13933, 13949, 13965, 13981, 13997, 14013, 14029, 14045, 14061, 14077, 14093, 14109, 14125, 14141, 14157, 14173, 14189, 14205, 14221, 14237, 14253, 14269, 14285, 14301, 14317, 14333, 14349, 14365, 14381, 14397, 14413, 14429, 14445, 14461, 14477, 14493, 14509, 14525, 14541, 14557, 14573, 14589, 14605, 14621, 14637, 14653, 14669, 14685, 14701, 14717, 14733, 14749, 14765, 14781, 14797, 14813, 14829, 14845, 14861, 14877, 14893, 14909, 14925, 14941, 14957, 14973, 14989, 15005, 15021, 15037]\n            scanX = [-17.069, -17.374, -17.698, -17.999, -18.321, -18.653, -18.97, -19.305, -19.637, -19.946, -20.281, -20.632, -20.946, -21.233, -21.501, -21.799, -22.115, -22.405, -22.722, -23.01, -23.227, -23.506, -23.784, -24.013, -24.254, -24.481, -24.675, -24.865, -25.065, -25.24, -25.394, -25.534, -25.669, -25.805, -25.949, -26.127, -26.288, -26.402, -26.507, -26.576, -26.6, -26.635, -26.693, -26.753, -26.807, -26.897, -27.024, -27.14, -27.245, -27.315, -27.347, -27.375, -27.408, -27.445, -27.484, -27.507, -27.509, -27.544, -27.581, -27.543, -27.469, -27.455, -27.441, -27.383, -27.349, -27.332, -27.309, -27.276, -27.199, -27.07, -26.919, -26.769, -26.638, -26.526, -26.377, -26.215, -26.094, -25.989, -25.848, -25.64, -25.398, -25.171, -24.977, -24.787, -24.56, -24.268, -24.003, -23.779, -23.55, -23.32, -23.084, -22.81, -22.521, -22.203, -21.849, -21.559, -21.254, -20.951, -20.632, -20.258, -19.95, -19.635, -19.215, -18.802, -18.43, -18.065, -17.698, -17.325, -16.951, -16.557, -16.159, -15.782, -15.359, -14.895, -14.472, -14.052, -13.637, -13.211, -12.771, -12.323, -11.882, -11.453, -11.029, -10.609, -10.146, -9.633, -9.085, -8.594, -8.184, -7.743, -7.243, -6.761, -6.341, -5.97, -5.545, -5.107, -4.74, -4.364, -3.99, -3.654, -3.301, -2.941, -2.612, -2.312, -2.057, -1.838, -1.618, -1.392, -1.145, -0.874, -0.615, -0.397, -0.212, -0.036, 0.158, 0.32, 0.423, 0.511, 0.631, 0.772, 0.881, 0.975, 1.06, 1.144, 1.208, 1.233, 1.283, 1.368, 1.405, 1.44, 1.458, 1.382, 1.281, 1.195, 1.11, 1.053, 0.98, 0.862, 0.747, 0.642, 0.494, 0.3, 0.116, -0.084, -0.3, -0.536, -0.778, -0.985, -1.174, -1.4, -1.658, -1.92, -2.231, -2.58, -2.905, -3.182, -3.428, -3.706, -4.038, -4.38, -4.752, -5.136, -5.52, -5.942, -6.387, -6.792, -7.182, -7.577, -7.957, -8.337, -8.743, -9.178, -9.588, -9.956, -10.326, -10.748, -11.205, -11.655, -12.078, -12.491, -12.9, -13.354, -13.851, -14.339, -14.803, -15.24, -15.658, -16.086, -16.529, -17.005, -17.499, -17.915, -18.29, -18.651, -18.988, -19.308, -19.653, -20, -20.33, -20.71, -21.109, -21.48, -21.791, -22.063, -22.324, -22.609, -22.921, -23.212, -23.504, -23.783, -24.031, -24.291, -24.554, -24.767, -24.963, -25.193, -25.457, -25.656, -25.773, -25.894, -26.043, -26.219, -26.385, -26.517, -26.625, -26.71, -26.788, -26.859, -26.917, -26.977, -27.018, -27.043, -27.038, -26.976, -26.879, -26.785, -26.679, -26.57, -26.489, -26.396, -26.238, -26.056, -25.883, -25.678, -25.42, -25.152, -24.907, -24.61, -24.295, -23.987, -23.634, -23.272, -22.93, -22.61, -22.272, -21.845, -21.398, -20.943, -20.463, -20.005, -19.561, -19.116, -18.585, -18.01, -17.518, -17.101, -16.654, -16.169, -15.653, -15.124, -14.608, -14.118, -13.644, -13.1, -12.565, -12.11, -11.654, -11.146, -10.617, -10.109, -9.632, -9.163, -8.65, -8.137, -7.649, -7.164, -6.708, -6.279, -5.835, -5.397, -4.977, -4.522, -4.062, -3.654, -3.276, -2.938, -2.588, -2.205, -1.882, -1.606, -1.321, -1.028, -0.748, -0.486, -0.254, -0.048, 0.159, 0.382, 0.597, 0.748, 0.859, 0.968, 1.073, 1.163, 1.218, 1.243, 1.179, 1.149, 1.193, 1.206, 1.206, 1.179, 1.122, 1.036]\n            scanY = [-4.611, -4.555, -4.504, -4.438, -4.365, -4.312, -4.302, -4.26, -4.176, -4.106, -3.995, -3.876, -3.76, -3.595, -3.425, -3.283, -3.16, -3.048, -2.932, -2.78, -2.616, -2.466, -2.322, -2.152, -1.957, -1.773, -1.625, -1.516, -1.37, -1.218, -1.131, -1.072, -0.957, -0.815, -0.698, -0.551, -0.425, -0.349, -0.232, -0.081, 0.044, 0.198, 0.424, 0.662, 0.826, 0.944, 1.065, 1.215, 1.397, 1.543, 1.704, 1.929, 2.147, 2.326, 2.49, 2.653, 2.847, 3.051, 3.236, 3.452, 3.688, 3.95, 4.2, 4.404, 4.635, 4.886, 5.127, 5.348, 5.556, 5.785, 5.993, 6.164, 6.36, 6.598, 6.801, 7.007, 7.26, 7.503, 7.719, 7.93, 8.155, 8.399, 8.648, 8.876, 9.056, 9.256, 9.515, 9.738, 9.91, 10.093, 10.306, 10.466, 10.607, 10.801, 10.998, 11.177, 11.367, 11.554, 11.737, 11.93, 12.067, 12.193, 12.36, 12.505, 12.651, 12.817, 12.982, 13.138, 13.242, 13.33, 13.437, 13.534, 13.596, 13.634, 13.641, 13.649, 13.688, 13.724, 13.784, 13.844, 13.873, 13.919, 13.921, 13.858, 13.787, 13.763, 13.772, 13.742, 13.694, 13.605, 13.497, 13.406, 13.283, 13.144, 13.025, 12.895, 12.792, 12.649, 12.442, 12.259, 12.059, 11.837, 11.642, 11.417, 11.14, 10.874, 10.645, 10.416, 10.148, 9.884, 9.649, 9.455, 9.244, 8.973, 8.714, 8.443, 8.151, 7.904, 7.659, 7.363, 7.067, 6.817, 6.601, 6.351, 6.058, 5.791, 5.527, 5.254, 4.991, 4.712, 4.458, 4.199, 3.924, 3.686, 3.469, 3.237, 3, 2.784, 2.533, 2.26, 2.01, 1.762, 1.489, 1.195, 0.907, 0.651, 0.424, 0.21, -0.005, -0.175, -0.29, -0.443, -0.653, -0.911, -1.159, -1.373, -1.58, -1.73, -1.861, -2.053, -2.22, -2.328, -2.492, -2.707, -2.91, -3.088, -3.217, -3.316, -3.44, -3.578, -3.685, -3.776, -3.925, -4.12, -4.257, -4.33, -4.378, -4.402, -4.41, -4.438, -4.483, -4.524, -4.587, -4.645, -4.672, -4.663, -4.662, -4.667, -4.653, -4.646, -4.633, -4.601, -4.547, -4.483, -4.399, -4.303, -4.242, -4.206, -4.126, -4.001, -3.868, -3.74, -3.603, -3.451, -3.301, -3.15, -2.966, -2.759, -2.597, -2.428, -2.223, -2.008, -1.794, -1.571, -1.329, -1.055, -0.819, -0.616, -0.392, -0.154, 0.122, 0.413, 0.711, 1.036, 1.365, 1.692, 1.996, 2.314, 2.662, 2.98, 3.297, 3.638, 3.989, 4.289, 4.563, 4.846, 5.157, 5.493, 5.806, 6.105, 6.424, 6.754, 7.055, 7.35, 7.671, 8.01, 8.333, 8.647, 8.913, 9.184, 9.482, 9.735, 9.959, 10.177, 10.442, 10.702, 10.94, 11.164, 11.342, 11.55, 11.793, 12.047, 12.279, 12.464, 12.673, 12.896, 13.026, 13.101, 13.201, 13.306, 13.408, 13.521, 13.584, 13.61, 13.693, 13.807, 13.885, 13.903, 13.887, 13.867, 13.848, 13.777, 13.661, 13.555, 13.452, 13.312, 13.145, 13.012, 12.877, 12.715, 12.528, 12.304, 12.081, 11.898, 11.703, 11.453, 11.239, 11.083, 10.887, 10.657, 10.44, 10.209, 9.912, 9.583, 9.27, 8.965, 8.639, 8.317, 7.99, 7.645, 7.345, 7.076, 6.785, 6.494, 6.241, 5.944, 5.608, 5.281, 5.004, 4.743, 4.46, 4.175, 3.862, 3.524]\n            scanZ = [80.422, 80.44, 80.463, 80.47, 80.444, 80.361, 80.313, 80.314, 80.308, 80.25, 80.165, 80.1, 80.028, 79.982, 79.966, 79.958, 79.938, 79.913, 79.89, 79.856, 79.825, 79.763, 79.728, 79.707, 79.663, 79.636, 79.571, 79.493, 79.414, 79.357, 79.317, 79.254, 79.197, 79.191, 79.172, 79.115, 79.11, 79.131, 79.13, 79.123, 79.11, 79.045, 78.954, 78.871, 78.795, 78.758, 78.704, 78.63, 78.588, 78.57, 78.519, 78.408, 78.321, 78.233, 78.121, 78.052, 77.988, 77.897, 77.788, 77.676, 77.586, 77.478, 77.346, 77.2, 77.087, 77.022, 76.997, 76.939, 76.882, 76.835, 76.74, 76.654, 76.561, 76.478, 76.374, 76.301, 76.239, 76.131, 76.045, 75.96, 75.863, 75.768, 75.675, 75.583, 75.519, 75.447, 75.329, 75.242, 75.195, 75.105, 75.051, 75.033, 74.957, 74.883, 74.827, 74.764, 74.693, 74.588, 74.533, 74.561, 74.506, 74.392, 74.308, 74.178, 74.04, 73.954, 73.921, 73.89, 73.764, 73.643, 73.585, 73.538, 73.469, 73.433, 73.432, 73.385, 73.317, 73.32, 73.335, 73.297, 73.283, 73.322, 73.356, 73.356, 73.342, 73.337, 73.331, 73.306, 73.284, 73.317, 73.398, 73.446, 73.444, 73.423, 73.416, 73.47, 73.571, 73.663, 73.727, 73.773, 73.861, 73.967, 74.097, 74.241, 74.374, 74.52, 74.66, 74.742, 74.804, 74.873, 74.911, 74.965, 75.086, 75.283, 75.454, 75.585, 75.717, 75.851, 75.94, 76.016, 76.144, 76.253, 76.327, 76.414, 76.48, 76.548, 76.709, 76.913, 77.053, 77.143, 77.217, 77.279, 77.389, 77.534, 77.633, 77.711, 77.842, 77.98, 78.053, 78.088, 78.126, 78.194, 78.302, 78.42, 78.527, 78.592, 78.599, 78.639, 78.681, 78.734, 78.84, 78.924, 78.974, 79.013, 79.076, 79.072, 78.992, 79.025, 79.105, 79.126, 79.186, 79.279, 79.337, 79.384, 79.467, 79.555, 79.629, 79.696, 79.751, 79.808, 79.826, 79.857, 79.944, 80.023, 80.082, 80.07, 80.034, 80.033, 80.039, 80.044, 80.076, 80.177, 80.214, 80.192, 80.21, 80.253, 80.305, 80.353, 80.43, 80.465, 80.447, 80.463, 80.456, 80.399, 80.38, 80.395, 80.428, 80.392, 80.308, 80.283, 80.267, 80.239, 80.208, 80.205, 80.195, 80.141, 80.098, 80.072, 80.055, 79.993, 79.951, 79.897, 79.771, 79.669, 79.608, 79.533, 79.405, 79.302, 79.241, 79.205, 79.132, 79.026, 78.93, 78.816, 78.705, 78.571, 78.443, 78.325, 78.179, 78.032, 77.891, 77.723, 77.571, 77.498, 77.416, 77.297, 77.175, 76.997, 76.823, 76.71, 76.593, 76.467, 76.398, 76.321, 76.179, 76.064, 75.984, 75.871, 75.749, 75.691, 75.61, 75.471, 75.338, 75.191, 75.036, 74.889, 74.801, 74.773, 74.74, 74.664, 74.536, 74.406, 74.281, 74.16, 74.057, 73.989, 73.919, 73.85, 73.813, 73.786, 73.741, 73.681, 73.679, 73.655, 73.596, 73.575, 73.549, 73.498, 73.473, 73.482, 73.483, 73.505, 73.524, 73.555, 73.576, 73.609, 73.691, 73.806, 73.943, 74.042, 74.099, 74.105, 74.079, 74.107, 74.212, 74.347, 74.449, 74.51, 74.619, 74.771, 74.869, 74.953, 75.108, 75.295, 75.446, 75.531, 75.577, 75.671, 75.796, 75.897, 76.082, 76.261, 76.348, 76.42, 76.479, 76.587, 76.723, 76.868, 77.032, 77.163, 77.262, 77.379, 77.512, 77.613]\n            testFieldX = [1.093, 1.029, 1.05, 1.929, 2.014, 2.164, 2.014, 2.229, 2.079, 0.814, 1.071, 1.05, -1.629, -1.157, -1.543, -4.221, -4.221, -4.2, -7.307, -7.136, -7.136, -10.543, -10.821, -10.843, -14.679, -14.743, -14.464, -17.85, -18.279, -17.743, -21.236, -21.15, -21.129, -24, -23.871, -24.107, -26.271, -26.164, -26.164, -27.45, -27.471, -27.536, -28.2, -27.879, -27.857, -27.3, -27.129, -27.686, -25.714, -25.479, -25.629, -22.714, -22.564, -22.8, -19.243, -19.5, -19.457, -15.321, -15.557, -14.914, -10.8, -10.929, -11.25, -7.5, -7.564, -7.436, -3.664, -3.75, -3.857, -1.071, -1.071, -0.621, 0.943, 0.814, 0.643]\n            testFieldY = [9.086, 8.764, 8.764, 6.664, 6.664, 6.643, 3.621, 3.964, 4.05, 1.671, 1.757, 1.543, -0.321, -0.793, -0.579, -2.229, -2.636, -2.636, -3.621, -3.6, -3.836, -4.5, -4.414, -4.457, -4.993, -5.143, -4.8, -4.607, -5.057, -4.714, -3.9, -3.9, -3.471, -2.186, -2.55, -2.486, -0.579, -0.514, -0.621, 1.779, 1.779, 1.671, 4.05, 4.114, 3.857, 6.707, 6.193, 6.321, 8.721, 9.3, 8.871, 11.421, 11.336, 11.336, 12.836, 12.921, 12.686, 14.4, 14.486, 14.014, 14.679, 14.914, 14.55, 14.379, 14.293, 14.336, 12.729, 12.879, 13.2, 11.271, 10.864, 10.671, 9.043, 8.743, 8.7]\n            testFieldZ = [75.514, 75.557, 75.043, 75.943, 76.093, 76.071, 77.293, 77.314, 77.271, 78.343, 78.236, 77.914, 78.771, 78.557, 78.771, 78.986, 79.114, 79.286, 79.35, 79.693, 79.371, 79.886, 79.779, 79.95, 80.207, 79.8, 79.971, 80.079, 79.864, 80.164, 79.929, 80.186, 80.464, 79.907, 79.929, 79.843, 79.65, 79.221, 79.393, 78.236, 78.214, 78.45, 77.336, 77.379, 77.55, 76.157, 76.35, 76.564, 75.364, 75.043, 75.664, 74.4, 74.229, 74.379, 73.95, 73.95, 73.629, 73.264, 73.05, 73.221, 72.879, 72.6, 73.157, 72.514, 72.643, 72.964, 73.779, 73.5, 73.457, 74.186, 74.529, 74.529, 74.979, 75.086, 75]\n            // poses were never captured...\n            testPoseX = []\n            testPoseY = []\n            testPoseZ = []\n            break\n    }\n    \n    // transpose the three arrays into the scan array of triples...\n    scan.samples = []\n    scan.times = []\n    for (let i = 0; i < times.length; i++) {\n        scan.samples.push(new Vector(scanX[i], scanY[i], scanZ[i]))\n        scan.times.push(times[i])\n    }\n\n    // assemble the array of test readings...\n    testReadings = []\n    for (let n = 0; n < testFieldX.length; n++) {\n        if (testPoseX.length > 0 ) {\n            testReading = new Reading(\n                testFieldX[n], testFieldY[n], testFieldZ[n], \n                testPoseX[n], testPoseY[n], testPoseZ[n])\n        } else { // this is an old test dataset, for which pose data was never captured\n            testReading = new Reading(testFieldX[n], testFieldY[n], testFieldZ[n], 0, 0, -1023) // for now, always pretend it was face-up!\n        }\n        testReadings.push(testReading)\n    }\n    testIndex = 0\n    return 0 // never fails!\n}\n\n\n\n// =============== FOREGROUND CODE =================\nscan = new Scan()\nbasic.clearScreen()\nbasic.showString(control.deviceName())\n\n/*\n* We are using three different 3D frames of reference:\n*\n*       XYZ: the microbit Sensor-Frame\n*       RFD: the buggy Body-Frame (Right, Front, Down)\n*       ENG: the World-Frame in which it is navigating (East, North, Gravity)\n*\n*/\n// await button-pressing...\n\n","README.md":"\n> Open this page at [https://grandpabond.github.io/gimbal/](https://grandpabond.github.io/gimbal/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/gimbal** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/gimbal** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt.json":"{\n    \"name\": \"gimbal\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.1.4\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}}],"shares":[],"lastSaveTime":1728287431143}